{
  "openapi" : "3.0.3",
  "info" : {
    "title" : "SimScale API",
    "description" : "# Introduction\nWelcome to the SimScale API documentation. API access is currently part of our paid Enterprise plan. However,\nif you have an idea for an integration or app and would like to become a development partner, please contact us\nat api@simscale.com!\n\n## Sandbox\nAn API sandbox is provided which allows to interact with all endpoints. All sandbox endpoints only return example\ndata and don't create or modify actual data, especially no actual simulations are started. To use the sandbox use\nthe `/sandbox` URL prefix with fixed api-key as `sandbox-example-api-key`.\n\n## Versioning\nThe generic version (currently `/v0`) defines the overall endpoints and data models. The generic version won't\nchange very often.\n\nFor the Simulation Spec and Meshing Spec data model schemas, separate version numbers are defined. These are\nincremented more frequently and independently of the generic version. You can see the supported schema versions in\nthe dropdown list at the top right corner of this page. You can use that dropdown list to generate API documentation\nfor different sets of schema versions.\n\nIt's possible to request the OpenAPI definition for a specific set of Simulation Spec and Meshing Spec schema\nversions by defining the `simulationSpecSchemaVersion` and `meshingSpecSchemaVersion` query parameters. For example:\n```\n/openapi.json?simulationSpecSchemaVersion=8.0&meshingSpecSchemaVersion=0.5\n```\n\n## API Documentation\nThe SimScale API is based on OpenAPI. It is a description format for REST APIs and describes the entire API,\nincluding endpoints, operations, and data models. That description format allows automatic generation of\ninteractive API documentation and client libraries. Currently, two formats of the API documentation are provided:\n[Swagger UI](/apidoc/swagger/index.html) and [Redoc](/apidoc/redoc/index.html).\n\nMore information about OpenAPI can be found at:\n* Official specification: <http://spec.openapis.org/oas/v3.0.3>\n* Additional documentation from Swagger: <https://swagger.io/docs/specification/about/>\n\n## Client Libraries (SDK)\nSimScale provides official SDKs and code examples in various languages:\n* Python SDK: <https://github.com/SimScaleGmbH/simscale-python-sdk>\n* C# SDK: <https://github.com/SimScaleGmbH/simscale-csharp-sdk>\n\nIt is also possible to generate client libraries that are fully functional, but less convenient to use than the SDK,\nfor other languages. Code generation toolkits can be found at:\n* <https://github.com/OpenAPITools/openapi-generator>\n* <https://github.com/swagger-api/swagger-codegen>\n\n## Compatibility with the Workbench\nCompatibility with the Workbench is not fully supported yet. In particular, there is no guarantee that Simulations\ncreated via the SimScale API can be modified using the Workbench.\n\nThe Simulation Spec schema changes frequently. If your Simulation model corresponds to a schema version other than\nthe latest one, modification using the Workbench will not be possible. You can still run simulations and continue\nediting your setup via the API or the SDK. This is to prevent any unexpected change to your model that would make it\nincompatible with your code.\n\nAs a workaround, you can duplicate the Simulation or Mesh Operation on the Workbench. Modification will be enabled\nfor the copy. The same can be achieved by copying the entire Project.\n\nFollow these instructions to update your models with the latest published schema version:\n* Python SDK: <https://github.com/SimScaleGmbH/simscale-python-sdk/wiki/How-to-enable-edit-capabilities-on-the-Workbench>\n* C# SDK: <https://github.com/SimScaleGmbH/simscale-csharp-sdk/wiki/How-to-enable-edit-capabilities-on-the-Workbench>\n\n**Important:** edit mode can still be disabled even if you are using the latest published Simulation Spec schema\nversion. This is because the Workbench might use a newer schema version that is not available yet to SimScale API\nclients. You will have to wait until a new Simulation Spec schema version is released.\n",
    "termsOfService" : "https://www.simscale.com/terms-and-conditions/",
    "version" : "0.0.0"
  },
  "servers" : [ {
    "url" : "/v0"
  } ],
  "security" : [ {
    "apiKey" : [ ]
  } ],
  "tags" : [ {
    "name" : "Projects",
    "description" : "Access to SimScale projects"
  }, {
    "name" : "Geometry Imports",
    "description" : "Import geometries"
  }, {
    "name" : "Geometries",
    "description" : "Information about geometries"
  }, {
    "name" : "Mesh Operations",
    "description" : "Perform mesh operations"
  }, {
    "name" : "Meshes",
    "description" : "Information about meshes"
  }, {
    "name" : "Simulations",
    "description" : "Setup of simulations"
  }, {
    "name" : "Simulation Runs",
    "description" : "Access to simulation runs"
  }, {
    "name" : "Storage",
    "description" : "Access to storage"
  }, {
    "name" : "Table Imports",
    "description" : "Import tables"
  }, {
    "name" : "Reports",
    "description" : "Access to reports"
  }, {
    "name" : "Materials",
    "description" : "Access to material groups and materials"
  } ],
  "paths" : {
    "/projects" : {
      "get" : {
        "tags" : [ "Projects" ],
        "summary" : "List projects",
        "operationId" : "getProjects",
        "parameters" : [ {
          "name" : "limit",
          "in" : "query",
          "description" : "The number of items to return.",
          "required" : false,
          "style" : "form",
          "explode" : true,
          "schema" : {
            "maximum" : 1000,
            "minimum" : 10,
            "type" : "integer",
            "default" : 100
          }
        }, {
          "name" : "page",
          "in" : "query",
          "description" : "The page number. Use in combination with limit.",
          "required" : false,
          "style" : "form",
          "explode" : true,
          "schema" : {
            "maximum" : 1000,
            "minimum" : 1,
            "type" : "integer",
            "default" : 1
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "content" : {
              "application/json" : {
                "schema" : {
                  "title" : "Projects",
                  "type" : "object",
                  "properties" : {
                    "_links" : {
                      "$ref" : "#/components/schemas/CollectionLinks"
                    },
                    "_meta" : {
                      "$ref" : "#/components/schemas/CollectionMeta"
                    },
                    "_embedded" : {
                      "type" : "array",
                      "items" : {
                        "$ref" : "#/components/schemas/Project"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post" : {
        "tags" : [ "Projects" ],
        "summary" : "Create a new project",
        "operationId" : "createProject",
        "requestBody" : {
          "description" : "Project to be created",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/Project"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Successful creation of the project",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Project"
                }
              }
            }
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          }
        }
      }
    },
    "/projects/{projectId}" : {
      "get" : {
        "tags" : [ "Projects" ],
        "summary" : "Get information about an existing project",
        "operationId" : "getProject",
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Project"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "put" : {
        "tags" : [ "Projects" ],
        "summary" : "Update an existing project",
        "operationId" : "updateProject",
        "requestBody" : {
          "description" : "Project to be updated",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/Project"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "Successful update of the project"
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      } ]
    },
    "/projects/{projectId}/geometryimports" : {
      "post" : {
        "tags" : [ "Geometry Imports" ],
        "summary" : "Import a new geometry",
        "description" : "Geometry import requires the following steps:\n1. Request a temporary storage location via `POST /storage`.\n2. Upload your CAD file using the HTTP `PUT` method to the `url` provided in the temporary storage location response object.\n3. Start the import via `POST /projects/{projectId}/geometryimports` and include the `storageId` provided in the temporary storage location response object.\n4. Check for the import status via `GET /projects/{projectId}/geometryimports/{geometryImportId}`.\n",
        "operationId" : "importGeometry",
        "requestBody" : {
          "description" : "Geometry import specification.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/GeometryImportRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "202" : {
            "description" : "Successful start of the import.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GeometryImportResponse"
                }
              }
            }
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      } ]
    },
    "/projects/{projectId}/geometryimports/{geometryImportId}" : {
      "get" : {
        "tags" : [ "Geometry Imports" ],
        "summary" : "Get information about the geometry import",
        "operationId" : "getGeometryImport",
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GeometryImportResponse"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/geometryImportId"
      } ]
    },
    "/projects/{projectId}/geometryimports/{geometryImportId}/eventlog" : {
      "get" : {
        "tags" : [ "Geometry Imports" ],
        "summary" : "Get the geometry import event log",
        "operationId" : "getGeometryImportEventLog",
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EventLogResponse"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/geometryImportId"
      } ]
    },
    "/projects/{projectId}/geometries" : {
      "get" : {
        "tags" : [ "Geometries" ],
        "summary" : "List geometries within a project",
        "description" : "Only valid geometries that can be used for a simulation setup are included.",
        "operationId" : "getGeometries",
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "content" : {
              "application/json" : {
                "schema" : {
                  "title" : "Geometries",
                  "type" : "object",
                  "properties" : {
                    "_links" : {
                      "$ref" : "#/components/schemas/CollectionLinks"
                    },
                    "_meta" : {
                      "$ref" : "#/components/schemas/CollectionMeta"
                    },
                    "_embedded" : {
                      "type" : "array",
                      "items" : {
                        "$ref" : "#/components/schemas/Geometry"
                      }
                    }
                  }
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/collectionLimit"
      }, {
        "$ref" : "#/components/parameters/collectionPage"
      }, {
        "$ref" : "#/components/parameters/projectId"
      } ]
    },
    "/projects/{projectId}/geometries/{geometryId}" : {
      "get" : {
        "tags" : [ "Geometries" ],
        "summary" : "Get information about the geometry",
        "operationId" : "getGeometry",
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Geometry"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "put" : {
        "tags" : [ "Geometries" ],
        "summary" : "Update geometry information",
        "operationId" : "updateGeometry",
        "requestBody" : {
          "description" : "Geometry information to be updated",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/Geometry"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "Successful update of the geometry information"
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/geometryId"
      } ]
    },
    "/projects/{projectId}/geometries/{geometryId}/mappings" : {
      "get" : {
        "tags" : [ "Geometries" ],
        "summary" : "Describe id mapping of the geometry",
        "description" : "Assignment of topological entities (faces, bodies) in the simulation setup is a non-trivial task.\nComplex models can consist of several assemblies which may contain multiple occurrences of bodies and their entities.\nIn order to describe an assignment unambiguously the full path from the root part of the model to the actual topological entity is required.\n\nSimScale generates unique internal names for all topological entities of a model during the geometry import which are used for assignments within the simulation spec.\nExamples of internal names are `B1_TE5` or `A1_I26_A5_I27_B102_TE196`.\n\nThis API endpoint allows to retrieve a mapping between the internal names and a detailed description of the entities which includes:\n* The topological entity class (body or face)\n* The original body and entity names\n* Entity attributes like `SDL/TYSA_NAME` or `SDL/TYSA_COLOUR`\n* The path from the root of the model\n\nPlease note that during geometry import the model's topology can be modified (e.g. facet split and other import options) which means that there is no 1:1 mapping between the internal and original names.\n",
        "operationId" : "getGeometryMappings",
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "content" : {
              "application/json" : {
                "schema" : {
                  "title" : "GeometryMappings",
                  "type" : "object",
                  "properties" : {
                    "_links" : {
                      "$ref" : "#/components/schemas/CollectionLinks"
                    },
                    "_meta" : {
                      "$ref" : "#/components/schemas/CollectionMeta"
                    },
                    "_embedded" : {
                      "type" : "array",
                      "items" : {
                        "$ref" : "#/components/schemas/EntityDescription"
                      }
                    }
                  }
                }
              }
            }
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/collectionLimit"
      }, {
        "$ref" : "#/components/parameters/collectionPage"
      }, {
        "$ref" : "#/components/parameters/class"
      }, {
        "$ref" : "#/components/parameters/bodies"
      }, {
        "$ref" : "#/components/parameters/entities"
      }, {
        "$ref" : "#/components/parameters/attributes"
      }, {
        "$ref" : "#/components/parameters/values"
      }, {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/geometryId"
      } ]
    },
    "/projects/{projectId}/geometryprimitives" : {
      "post" : {
        "tags" : [ "Simulations" ],
        "summary" : "Create a geometry primitive for reference within a Simulation spec.",
        "operationId" : "createGeometryPrimitive",
        "requestBody" : {
          "description" : "Geometry primitive specification.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/GeometryPrimitive"
              },
              "examples" : {
                "LocalCartesianBox" : {
                  "$ref" : "#/components/examples/LocalCartesianBox"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "Successful creation of the geometry primitive.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GeometryPrimitiveResponse"
                }
              }
            }
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      } ]
    },
    "/projects/{projectId}/tableimports" : {
      "post" : {
        "tags" : [ "Table Imports" ],
        "summary" : "Import a new table for reference within a Simulation spec.",
        "description" : "Table import requires the following steps:\n1. Request a temporary storage location via `POST /storage`.\n2. Upload your table definition using the HTTP `PUT` method to the `url` provided in the temporary storage location response object.\n3. Import via `POST /projects/{projectId}/tableimports` and include the `storageId` provided in the temporary storage location response object.\n",
        "operationId" : "importTable",
        "requestBody" : {
          "description" : "Table import specification.",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/TableImportRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "Successful import of the table.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TableImportResponse"
                }
              }
            }
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      } ]
    },
    "/projects/{projectId}/meshoperations" : {
      "get" : {
        "tags" : [ "Mesh Operations" ],
        "summary" : "List mesh operations for a project",
        "operationId" : "getMeshOperations",
        "parameters" : [ {
          "$ref" : "#/components/parameters/collectionLimit"
        }, {
          "$ref" : "#/components/parameters/collectionPage"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "content" : {
              "application/json" : {
                "schema" : {
                  "title" : "MeshOperations",
                  "type" : "object",
                  "properties" : {
                    "_links" : {
                      "$ref" : "#/components/schemas/CollectionLinks"
                    },
                    "_meta" : {
                      "$ref" : "#/components/schemas/CollectionMeta"
                    },
                    "_embedded" : {
                      "type" : "array",
                      "items" : {
                        "$ref" : "#/components/schemas/MeshOperation"
                      }
                    }
                  }
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "post" : {
        "tags" : [ "Mesh Operations" ],
        "summary" : "Create a mesh operation",
        "operationId" : "createMeshOperation",
        "requestBody" : {
          "description" : "Mesh operation to be created",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MeshOperation"
              },
              "example" : {
                "name" : "My first mesh operation"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Successful creation of the mesh operation",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MeshOperation"
                }
              }
            },
            "links" : {
              "getSimulationRun" : {
                "operationId" : "getMeshOperation",
                "parameters" : {
                  "projectId" : "$request.path.projectId",
                  "simulationId" : "$request.path.meshOperationId",
                  "runId" : "$response.body#/meshOperationId"
                },
                "description" : "The `meshOperationId` value returned in the response can be used as the `meshOperationId` parameter in `GET /projects/{projectId}/meshoperations/{meshOperationId}`.\n"
              }
            }
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      } ]
    },
    "/projects/{projectId}/meshoperations/{meshOperationId}" : {
      "get" : {
        "tags" : [ "Mesh Operations" ],
        "summary" : "Get information about the mesh operation",
        "operationId" : "getMeshOperation",
        "parameters" : [ {
          "$ref" : "#/components/parameters/meshingSpecSchemaVersion"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MeshOperation"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "put" : {
        "tags" : [ "Mesh Operations" ],
        "summary" : "Update information about the mesh operation",
        "operationId" : "updateMeshOperation",
        "requestBody" : {
          "description" : "Mesh operation to be updated",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MeshOperation"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "Successful update of the mesh operation"
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/meshOperationId"
      } ]
    },
    "/projects/{projectId}/meshoperations/{meshOperationId}/check" : {
      "post" : {
        "tags" : [ "Mesh Operations" ],
        "summary" : "Check the mesh operation setup",
        "operationId" : "checkMeshOperationSetup",
        "responses" : {
          "200" : {
            "description" : "Succcessful mesh operation check",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CheckResponse"
                }
              }
            }
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/meshOperationId"
      }, {
        "$ref" : "#/components/parameters/simulationIdQuery"
      } ]
    },
    "/projects/{projectId}/meshoperations/{meshOperationId}/estimate" : {
      "post" : {
        "tags" : [ "Mesh Operations" ],
        "summary" : "Estimate the mesh operation",
        "operationId" : "estimateMeshOperation",
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Estimation"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          },
          "422" : {
            "$ref" : "#/components/responses/UnprocessableEntity"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/meshOperationId"
      } ]
    },
    "/projects/{projectId}/meshoperations/{meshOperationId}/start" : {
      "post" : {
        "tags" : [ "Mesh Operations" ],
        "summary" : "Start the mesh operation",
        "operationId" : "startMeshOperation",
        "responses" : {
          "202" : {
            "description" : "Successful operation."
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/meshOperationId"
      }, {
        "$ref" : "#/components/parameters/simulationIdQuery"
      } ]
    },
    "/projects/{projectId}/meshoperations/{meshOperationId}/cancel" : {
      "post" : {
        "tags" : [ "Mesh Operations" ],
        "summary" : "Cancel the mesh operation",
        "operationId" : "cancelMeshOperation",
        "responses" : {
          "202" : {
            "description" : "Successful operation."
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/meshOperationId"
      } ]
    },
    "/projects/{projectId}/meshoperations/{meshOperationId}/eventlog" : {
      "get" : {
        "tags" : [ "Mesh Operations" ],
        "summary" : "Get the mesh operation event log",
        "operationId" : "getMeshOperationEventLog",
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EventLogResponse"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/meshOperationId"
      } ]
    },
    "/projects/{projectId}/meshoperations/{meshOperationId}/sdkcode" : {
      "get" : {
        "tags" : [ "Mesh Operations" ],
        "summary" : "Get Python SDK code for the mesh operation",
        "operationId" : "getMeshOperationSdkCode",
        "parameters" : [ {
          "$ref" : "#/components/parameters/sdkVersion"
        }, {
          "$ref" : "#/components/parameters/sdkLanguage"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "text/plain;charset=UTF-8" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/meshOperationId"
      } ]
    },
    "/projects/{projectId}/meshes" : {
      "get" : {
        "tags" : [ "Meshes" ],
        "summary" : "List meshes within a project",
        "description" : "Only finished and non-uploaded meshes are included.",
        "operationId" : "getMeshes",
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "content" : {
              "application/json" : {
                "schema" : {
                  "title" : "Meshes",
                  "type" : "object",
                  "properties" : {
                    "_links" : {
                      "$ref" : "#/components/schemas/CollectionLinks"
                    },
                    "_meta" : {
                      "$ref" : "#/components/schemas/CollectionMeta"
                    },
                    "_embedded" : {
                      "type" : "array",
                      "items" : {
                        "$ref" : "#/components/schemas/Mesh"
                      }
                    }
                  }
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/collectionLimit"
      }, {
        "$ref" : "#/components/parameters/collectionPage"
      }, {
        "$ref" : "#/components/parameters/projectId"
      } ]
    },
    "/projects/{projectId}/meshes/{meshId}" : {
      "get" : {
        "tags" : [ "Meshes" ],
        "summary" : "Get information about the mesh",
        "operationId" : "getMesh",
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Mesh"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/meshId"
      } ]
    },
    "/projects/{projectId}/simulations" : {
      "get" : {
        "tags" : [ "Simulations" ],
        "summary" : "List simulation setups within a project",
        "operationId" : "getSimulations",
        "parameters" : [ {
          "$ref" : "#/components/parameters/collectionLimit"
        }, {
          "$ref" : "#/components/parameters/collectionPage"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "content" : {
              "application/json" : {
                "schema" : {
                  "title" : "Simulations",
                  "type" : "object",
                  "properties" : {
                    "_links" : {
                      "$ref" : "#/components/schemas/CollectionLinks"
                    },
                    "_meta" : {
                      "$ref" : "#/components/schemas/CollectionMeta"
                    },
                    "_embedded" : {
                      "type" : "array",
                      "items" : {
                        "$ref" : "#/components/schemas/Simulation"
                      }
                    }
                  }
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "post" : {
        "tags" : [ "Simulations" ],
        "summary" : "Create a simulation setup",
        "operationId" : "createSimulation",
        "requestBody" : {
          "description" : "Simulation to be created",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SimulationSpec"
              },
              "examples" : {
                "windcomfort" : {
                  "$ref" : "#/components/examples/WindComfort"
                },
                "incompressible" : {
                  "$ref" : "#/components/examples/Incompressible"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Successful creation of the simulation setup",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Simulation"
                }
              }
            },
            "links" : {
              "getSimulation" : {
                "operationId" : "getSimulation",
                "parameters" : {
                  "projectId" : "$request.path.projectId",
                  "simulationId" : "$response.body#/simulationId"
                },
                "description" : "The `simulationId` value returned in the response can be used as the `simulationId` parameter in `GET /projects/{projectId}/simulations/{simulationId}`.\n"
              }
            }
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}" : {
      "get" : {
        "tags" : [ "Simulations" ],
        "summary" : "Get information about the simulation setup",
        "operationId" : "getSimulation",
        "parameters" : [ {
          "$ref" : "#/components/parameters/simulationSpecSchemaVersion"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SimulationSpec"
                },
                "examples" : {
                  "windcomfort" : {
                    "$ref" : "#/components/examples/WindComfort"
                  },
                  "incompressible" : {
                    "$ref" : "#/components/examples/Incompressible"
                  }
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "put" : {
        "tags" : [ "Simulations" ],
        "summary" : "Update information about the simulation setup",
        "operationId" : "updateSimulation",
        "requestBody" : {
          "description" : "Simulation to be updated",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SimulationSpec"
              },
              "examples" : {
                "windcomfort" : {
                  "$ref" : "#/components/examples/WindComfort"
                },
                "incompressible" : {
                  "$ref" : "#/components/examples/Incompressible"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "Successful update of the simulation"
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/check" : {
      "post" : {
        "tags" : [ "Simulations" ],
        "summary" : "Check the simulation setup",
        "operationId" : "checkSimulationSetup",
        "responses" : {
          "200" : {
            "description" : "Succcessful simulation check",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CheckResponse"
                }
              }
            }
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/estimate" : {
      "post" : {
        "tags" : [ "Simulations" ],
        "summary" : "Estimate the simulation setup",
        "operationId" : "estimateSimulationSetup",
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Estimation"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          },
          "422" : {
            "$ref" : "#/components/responses/UnprocessableEntity"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/materials" : {
      "post" : {
        "tags" : [ "Simulations" ],
        "summary" : "Update materials in the simulation setup",
        "operationId" : "updateSimulationMaterials",
        "requestBody" : {
          "description" : "Material update operations",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MaterialUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MaterialUpdateResponse"
                }
              }
            }
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      }, {
        "$ref" : "#/components/parameters/materialUpdatePreview"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/runs" : {
      "get" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "List simulation runs for a simulation",
        "operationId" : "getSimulationRuns",
        "parameters" : [ {
          "$ref" : "#/components/parameters/collectionLimit"
        }, {
          "$ref" : "#/components/parameters/collectionPage"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "content" : {
              "application/json" : {
                "schema" : {
                  "title" : "SimulationRuns",
                  "type" : "object",
                  "properties" : {
                    "_links" : {
                      "$ref" : "#/components/schemas/CollectionLinks"
                    },
                    "_meta" : {
                      "$ref" : "#/components/schemas/CollectionMeta"
                    },
                    "_embedded" : {
                      "type" : "array",
                      "items" : {
                        "$ref" : "#/components/schemas/SimulationRun"
                      }
                    }
                  }
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "post" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "Create a simulation run",
        "description" : "This operation creates a run in status `READY`, however the run is not automatically started. The run must be started explicitely using the `POST /projects/{projectId}/simulations/{simulationId}/runs/{runId}/start` endpoint.\n",
        "operationId" : "createSimulationRun",
        "requestBody" : {
          "description" : "Simulation run to be created",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SimulationRun"
              },
              "example" : {
                "name" : "My first simulation run"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Successful creation of the simulation run",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SimulationRun"
                }
              }
            },
            "links" : {
              "getSimulationRun" : {
                "operationId" : "getSimulationRun",
                "parameters" : {
                  "projectId" : "$request.path.projectId",
                  "simulationId" : "$request.path.simulationId",
                  "runId" : "$response.body#/runId"
                },
                "description" : "The `runId` value returned in the response can be used as the `runId` parameter in `GET /projects/{projectId}/simulations/{simulationId}/runs/{runId}`.\n"
              }
            }
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/runs/{runId}" : {
      "get" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "Get basic information about the simulation run",
        "operationId" : "getSimulationRun",
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SimulationRun"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "put" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "Update an existing simulation run",
        "operationId" : "updateSimulationRun",
        "requestBody" : {
          "description" : "Simulation run to be updated",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SimulationRun"
              },
              "example" : {
                "name" : "My first awesome simulation run"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "Successful update of the simulation run"
          },
          "400" : {
            "$ref" : "#/components/responses/BadRequest"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      }, {
        "$ref" : "#/components/parameters/runId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/runs/{runId}/eventlog" : {
      "get" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "Get the simulation run event log",
        "operationId" : "getSimulationRunEventLog",
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/EventLogResponse"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      }, {
        "$ref" : "#/components/parameters/runId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/sdkcode" : {
      "get" : {
        "tags" : [ "Simulations" ],
        "summary" : "Get Python SDK code for the simulation",
        "operationId" : "getSimulationSdkCode",
        "parameters" : [ {
          "$ref" : "#/components/parameters/sdkVersion"
        }, {
          "$ref" : "#/components/parameters/sdkLanguage"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "text/plain;charset=UTF-8" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/runs/{runId}/sdkcode" : {
      "get" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "Get Python SDK code for the simulation run",
        "operationId" : "getSimulationRunSdkCode",
        "parameters" : [ {
          "$ref" : "#/components/parameters/sdkVersion"
        }, {
          "$ref" : "#/components/parameters/sdkLanguage"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "text/plain;charset=UTF-8" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      }, {
        "$ref" : "#/components/parameters/runId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/runs/{runId}/spec" : {
      "get" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "Get the simulation run spec",
        "operationId" : "getSimulationRunSpec",
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SimulationSpec"
                },
                "examples" : {
                  "windcomfort" : {
                    "$ref" : "#/components/examples/WindComfort"
                  },
                  "incompressible" : {
                    "$ref" : "#/components/examples/Incompressible"
                  }
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      }, {
        "$ref" : "#/components/parameters/runId"
      }, {
        "$ref" : "#/components/parameters/simulationSpecSchemaVersion"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/runs/{runId}/start" : {
      "post" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "Start the simulation run",
        "operationId" : "startSimulationRun",
        "responses" : {
          "202" : {
            "description" : "Successful operation."
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      }, {
        "$ref" : "#/components/parameters/runId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/runs/{runId}/add-wind-data" : {
      "post" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "Add wind data to a simulation run (works only for PWC runs)",
        "description" : "You can use this endpoint to add wind data to an existing PWC run. This means that for the new run, only the statistical surface solution will be regenerated based on the new wind data, while the individual results of each direction will be kept from the original run. This endpoint is only used to trigger the execution of the new simulation run - before calling this endpoint make sure to update the simulation spec with the new wind data.",
        "operationId" : "addWindDataToSimulationRun",
        "requestBody" : {
          "description" : "Metadata of the newly created simulation run",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/WindData"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "202" : {
            "description" : "Successful operation.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SimulationRun"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      }, {
        "$ref" : "#/components/parameters/runId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/runs/{runId}/cancel" : {
      "post" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "Cancel the simulation run",
        "operationId" : "cancelSimulationRun",
        "responses" : {
          "202" : {
            "description" : "Successful operation."
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      }, {
        "$ref" : "#/components/parameters/runId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/runs/{runId}/results" : {
      "get" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "List available results for a simulation runs",
        "operationId" : "getSimulationRunResults",
        "parameters" : [ {
          "$ref" : "#/components/parameters/collectionLimit"
        }, {
          "$ref" : "#/components/parameters/collectionPage"
        }, {
          "$ref" : "#/components/parameters/resultType"
        }, {
          "$ref" : "#/components/parameters/resultCategory"
        }, {
          "$ref" : "#/components/parameters/resultQuantity"
        }, {
          "$ref" : "#/components/parameters/resultName"
        }, {
          "$ref" : "#/components/parameters/resultDirection"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "content" : {
              "application/json" : {
                "schema" : {
                  "title" : "SimulationRunResults",
                  "type" : "object",
                  "properties" : {
                    "_links" : {
                      "$ref" : "#/components/schemas/CollectionLinks"
                    },
                    "_meta" : {
                      "$ref" : "#/components/schemas/CollectionMeta"
                    },
                    "_embedded" : {
                      "type" : "array",
                      "example" : [ {
                        "type" : "SOLUTION_FIELD",
                        "resultId" : "840c840c-840c-840c-840c-840c840c840c",
                        "category" : "STATISTICAL_SURFACE_SOLUTION",
                        "modifiedAt" : "2020-03-04T17:29:42Z",
                        "download" : {
                          "format" : "PVD",
                          "uncompressedSizeInBytes" : 4000,
                          "url" : "https://httpbin.org/bytes/4000",
                          "compression" : "ZIP64"
                        }
                      }, {
                        "type" : "SOLUTION_FIELD",
                        "resultId" : "744e744e-744e-744e-744e-744e744e744e",
                        "category" : "TRANSIENT_SOLUTION",
                        "direction" : 0.0,
                        "modifiedAt" : "2020-03-04T17:29:42Z",
                        "download" : {
                          "format" : "ENSIGHT_GOLD",
                          "uncompressedSizeInBytes" : 8000,
                          "url" : "https://httpbin.org/bytes/8000",
                          "compression" : "ZIP64"
                        }
                      }, {
                        "type" : "PLOT",
                        "resultId" : "148a148a-148a-148a-148a-148a148a148a",
                        "category" : "PROBE_POINT_PLOT",
                        "name" : "Probe point 1",
                        "quantity" : "p",
                        "direction" : 0.0,
                        "modifiedAt" : "2020-03-04T17:29:42Z",
                        "download" : {
                          "format" : "CSV",
                          "uncompressedSizeInBytes" : 2000,
                          "url" : "https://httpbin.org/bytes/2000",
                          "compression" : "NONE"
                        }
                      }, {
                        "type" : "TABLE",
                        "resultId" : "670e670e-670e-670e-670e-670e670e670e",
                        "category" : "PROBE_POINT_PLOT",
                        "name" : "Probe point 1",
                        "direction" : 0.0,
                        "modifiedAt" : "2020-03-04T17:29:42Z",
                        "download" : {
                          "format" : "CSV",
                          "uncompressedSizeInBytes" : 1000,
                          "url" : "https://httpbin.org/bytes/1000",
                          "compression" : "NONE"
                        }
                      } ],
                      "items" : {
                        "$ref" : "#/components/schemas/OneOfSimulationRunResult"
                      }
                    }
                  }
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      }, {
        "$ref" : "#/components/parameters/runId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/runs/{runId}/subruns" : {
      "get" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "List of subruns of parametric runs",
        "operationId" : "getSimulationRunSubRuns",
        "parameters" : [ {
          "$ref" : "#/components/parameters/collectionLimit"
        }, {
          "$ref" : "#/components/parameters/collectionPage"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "content" : {
              "application/json" : {
                "schema" : {
                  "title" : "SimulationRuns",
                  "type" : "object",
                  "properties" : {
                    "_links" : {
                      "$ref" : "#/components/schemas/CollectionLinks"
                    },
                    "_meta" : {
                      "$ref" : "#/components/schemas/CollectionMeta"
                    },
                    "_embedded" : {
                      "type" : "array",
                      "items" : {
                        "$ref" : "#/components/schemas/SimulationRun"
                      }
                    }
                  }
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      }, {
        "$ref" : "#/components/parameters/runId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/runs/{runId}/subruns/{subRunId}/spec" : {
      "get" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "Get the simulation sub-run spec",
        "operationId" : "getSimulationRunSubRunSpec",
        "responses" : {
          "200" : {
            "description" : "Successful operation.",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SimulationSpec"
                },
                "examples" : {
                  "simerics" : {
                    "$ref" : "#/components/examples/Simerics"
                  }
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      }, {
        "$ref" : "#/components/parameters/runId"
      }, {
        "$ref" : "#/components/parameters/subRunId"
      }, {
        "$ref" : "#/components/parameters/simulationSpecSchemaVersion"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/runs/{runId}/subruns/{subRunId}/cancel" : {
      "post" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "Cancel the sub-run of a parametric run",
        "operationId" : "cancelSimulationRunSubRun",
        "responses" : {
          "202" : {
            "description" : "Successful operation."
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      }, {
        "$ref" : "#/components/parameters/runId"
      }, {
        "$ref" : "#/components/parameters/subRunId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/runs/{runId}/subruns/{subRunId}" : {
      "delete" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "Delete the sub-run of a parametric run",
        "operationId" : "deleteSimulationRunSubRun",
        "responses" : {
          "204" : {
            "description" : "No Content"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      }, {
        "$ref" : "#/components/parameters/runId"
      }, {
        "$ref" : "#/components/parameters/subRunId"
      } ]
    },
    "/projects/{projectId}/simulations/{simulationId}/runs/{runId}/subruns/{subRunId}/results" : {
      "get" : {
        "tags" : [ "Simulation Runs" ],
        "summary" : "Get the simulation sub-run results",
        "operationId" : "getSimulationRunSubRunResults",
        "parameters" : [ {
          "$ref" : "#/components/parameters/collectionLimit"
        }, {
          "$ref" : "#/components/parameters/collectionPage"
        }, {
          "$ref" : "#/components/parameters/resultType"
        }, {
          "$ref" : "#/components/parameters/resultCategory"
        }, {
          "$ref" : "#/components/parameters/resultQuantity"
        }, {
          "$ref" : "#/components/parameters/resultName"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "content" : {
              "application/json" : {
                "schema" : {
                  "title" : "SimulationRuns",
                  "type" : "object",
                  "properties" : {
                    "_links" : {
                      "$ref" : "#/components/schemas/CollectionLinks"
                    },
                    "_meta" : {
                      "$ref" : "#/components/schemas/CollectionMeta"
                    },
                    "_embedded" : {
                      "type" : "array",
                      "example" : [ {
                        "type" : "SOLUTION_FIELD",
                        "resultId" : "840c840c-840c-840c-840c-840c840c840c",
                        "category" : "STATISTICAL_SURFACE_SOLUTION",
                        "modifiedAt" : "2020-03-04T17:29:42Z",
                        "download" : {
                          "format" : "PVD",
                          "uncompressedSizeInBytes" : 4000,
                          "url" : "https://httpbin.org/bytes/4000",
                          "compression" : "ZIP64"
                        }
                      }, {
                        "type" : "SOLUTION_FIELD",
                        "resultId" : "744e744e-744e-744e-744e-744e744e744e",
                        "category" : "TRANSIENT_SOLUTION",
                        "direction" : 0.0,
                        "modifiedAt" : "2020-03-04T17:29:42Z",
                        "download" : {
                          "format" : "ENSIGHT_GOLD",
                          "uncompressedSizeInBytes" : 8000,
                          "url" : "https://httpbin.org/bytes/8000",
                          "compression" : "ZIP64"
                        }
                      }, {
                        "type" : "PLOT",
                        "resultId" : "148a148a-148a-148a-148a-148a148a148a",
                        "category" : "PROBE_POINT_PLOT",
                        "name" : "Probe point 1",
                        "quantity" : "p",
                        "direction" : 0.0,
                        "modifiedAt" : "2020-03-04T17:29:42Z",
                        "download" : {
                          "format" : "CSV",
                          "uncompressedSizeInBytes" : 2000,
                          "url" : "https://httpbin.org/bytes/2000",
                          "compression" : "NONE"
                        }
                      }, {
                        "type" : "TABLE",
                        "resultId" : "670e670e-670e-670e-670e-670e670e670e",
                        "category" : "PROBE_POINT_PLOT",
                        "name" : "Probe point 1",
                        "direction" : 0.0,
                        "modifiedAt" : "2020-03-04T17:29:42Z",
                        "download" : {
                          "format" : "CSV",
                          "uncompressedSizeInBytes" : 1000,
                          "url" : "https://httpbin.org/bytes/1000",
                          "compression" : "NONE"
                        }
                      } ],
                      "items" : {
                        "$ref" : "#/components/schemas/OneOfSimulationRunResult"
                      }
                    }
                  }
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "parameters" : [ {
        "$ref" : "#/components/parameters/projectId"
      }, {
        "$ref" : "#/components/parameters/simulationId"
      }, {
        "$ref" : "#/components/parameters/runId"
      }, {
        "$ref" : "#/components/parameters/subRunId"
      } ]
    },
    "/projects/{projectId}/reports" : {
      "get" : {
        "tags" : [ "Reports" ],
        "operationId" : "getReports",
        "parameters" : [ {
          "$ref" : "#/components/parameters/projectId"
        }, {
          "$ref" : "#/components/parameters/simulationIdOptional"
        }, {
          "$ref" : "#/components/parameters/runIdOptional"
        }, {
          "$ref" : "#/components/parameters/collectionLimit"
        }, {
          "$ref" : "#/components/parameters/collectionPage"
        } ],
        "responses" : {
          "200" : {
            "description" : "Ok",
            "content" : {
              "application/json" : {
                "schema" : {
                  "title" : "ReportResponses",
                  "type" : "object",
                  "properties" : {
                    "_links" : {
                      "$ref" : "#/components/schemas/CollectionLinks"
                    },
                    "_meta" : {
                      "$ref" : "#/components/schemas/CollectionMeta"
                    },
                    "_embedded" : {
                      "type" : "array",
                      "items" : {
                        "$ref" : "#/components/schemas/ReportResponse"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post" : {
        "tags" : [ "Reports" ],
        "operationId" : "createReport",
        "parameters" : [ {
          "$ref" : "#/components/parameters/projectId"
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ReportRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ReportResponse"
                }
              }
            }
          }
        }
      }
    },
    "/projects/{projectId}/reports/{reportId}" : {
      "get" : {
        "tags" : [ "Reports" ],
        "operationId" : "getReport",
        "parameters" : [ {
          "$ref" : "#/components/parameters/projectId"
        }, {
          "$ref" : "#/components/parameters/reportId"
        } ],
        "responses" : {
          "200" : {
            "description" : "Ok",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ReportResponse"
                }
              }
            }
          }
        }
      },
      "put" : {
        "tags" : [ "Reports" ],
        "operationId" : "updateReport",
        "parameters" : [ {
          "$ref" : "#/components/parameters/projectId"
        }, {
          "$ref" : "#/components/parameters/reportId"
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ReportRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "Accepted",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ReportResponse"
                }
              }
            }
          }
        }
      },
      "delete" : {
        "tags" : [ "Reports" ],
        "operationId" : "deleteReport",
        "parameters" : [ {
          "$ref" : "#/components/parameters/projectId"
        }, {
          "$ref" : "#/components/parameters/reportId"
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        }
      }
    },
    "/projects/{projectId}/reports/{reportId}/start" : {
      "post" : {
        "tags" : [ "Reports" ],
        "operationId" : "startReportJob",
        "parameters" : [ {
          "$ref" : "#/components/parameters/projectId"
        }, {
          "$ref" : "#/components/parameters/reportId"
        } ],
        "responses" : {
          "202" : {
            "description" : "Accepted"
          }
        }
      }
    },
    "/projects/{projectId}/reports/{reportId}/cancel" : {
      "post" : {
        "tags" : [ "Reports" ],
        "operationId" : "cancelReportJob",
        "parameters" : [ {
          "$ref" : "#/components/parameters/projectId"
        }, {
          "$ref" : "#/components/parameters/reportId"
        } ],
        "responses" : {
          "202" : {
            "description" : "Accepted"
          }
        }
      }
    },
    "/storage" : {
      "post" : {
        "tags" : [ "Storage" ],
        "summary" : "Create a temporary storage location",
        "operationId" : "createStorage",
        "responses" : {
          "201" : {
            "description" : "Successful creation of the temporaray storage location",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Storage"
                }
              }
            }
          }
        }
      }
    },
    "/materialgroups" : {
      "get" : {
        "tags" : [ "Materials" ],
        "summary" : "List all the material groups the user has access to",
        "operationId" : "getMaterialGroups",
        "parameters" : [ {
          "$ref" : "#/components/parameters/collectionLimit"
        }, {
          "$ref" : "#/components/parameters/collectionPage"
        } ],
        "responses" : {
          "200" : {
            "description" : "Ok",
            "content" : {
              "application/json" : {
                "schema" : {
                  "title" : "MaterialGroupListResponse",
                  "type" : "object",
                  "properties" : {
                    "_links" : {
                      "$ref" : "#/components/schemas/CollectionLinks"
                    },
                    "_meta" : {
                      "$ref" : "#/components/schemas/CollectionMeta"
                    },
                    "_embedded" : {
                      "type" : "array",
                      "items" : {
                        "$ref" : "#/components/schemas/MaterialGroupResponse"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post" : {
        "tags" : [ "Materials" ],
        "summary" : "Create new material group",
        "operationId" : "createMaterialGroup",
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CreateMaterialGroupRequest"
              }
            }
          }
        },
        "responses" : {
          "201" : {
            "description" : "Material group created successfully",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MaterialGroupResponse"
                }
              }
            }
          }
        }
      }
    },
    "/materialgroups/{materialGroupId}/materialgroups" : {
      "get" : {
        "tags" : [ "Materials" ],
        "summary" : "List all sub-groups of the specified material group",
        "operationId" : "getNestedMaterialGroups",
        "parameters" : [ {
          "$ref" : "#/components/parameters/materialGroupId"
        }, {
          "$ref" : "#/components/parameters/collectionLimit"
        }, {
          "$ref" : "#/components/parameters/collectionPage"
        } ],
        "responses" : {
          "200" : {
            "description" : "Ok",
            "content" : {
              "application/json" : {
                "schema" : {
                  "title" : "MaterialGroupListResponse",
                  "type" : "object",
                  "properties" : {
                    "_links" : {
                      "$ref" : "#/components/schemas/CollectionLinks"
                    },
                    "_meta" : {
                      "$ref" : "#/components/schemas/CollectionMeta"
                    },
                    "_embedded" : {
                      "type" : "array",
                      "items" : {
                        "$ref" : "#/components/schemas/MaterialGroupResponse"
                      }
                    }
                  }
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "post" : {
        "tags" : [ "Materials" ],
        "summary" : "Create a child material group for the specified parent group",
        "operationId" : "createNestedMaterialGroup",
        "parameters" : [ {
          "$ref" : "#/components/parameters/materialGroupId"
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CreateNestedMaterialGroupRequest"
              }
            }
          }
        },
        "responses" : {
          "201" : {
            "description" : "Nested material group created successfully",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MaterialGroupResponse"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      }
    },
    "/materialgroups/{materialGroupId}" : {
      "get" : {
        "tags" : [ "Materials" ],
        "summary" : "Fetch material group information",
        "operationId" : "getMaterialGroupMetadata",
        "parameters" : [ {
          "$ref" : "#/components/parameters/materialGroupId"
        } ],
        "responses" : {
          "200" : {
            "description" : "Ok",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MaterialGroupResponse"
                }
              }
            }
          },
          "404" : {
            "description" : "Material group was not found"
          }
        }
      },
      "put" : {
        "tags" : [ "Materials" ],
        "summary" : "Update material group information",
        "operationId" : "updateMaterialGroupMetadata",
        "parameters" : [ {
          "$ref" : "#/components/parameters/materialGroupId"
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UpdateMaterialGroupRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "Material group was successfully updated",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MaterialGroupResponse"
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "delete" : {
        "tags" : [ "Materials" ],
        "summary" : "Delete material group, sub-groups associated to it, and materials associated to the group and all sub-groups",
        "operationId" : "deleteMaterialGroup",
        "parameters" : [ {
          "$ref" : "#/components/parameters/materialGroupId"
        } ],
        "responses" : {
          "204" : {
            "description" : "Material group and related entities deleted successfully"
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      }
    },
    "/materialgroups/{materialGroupId}/materials" : {
      "get" : {
        "tags" : [ "Materials" ],
        "summary" : "List materials within the material group",
        "operationId" : "getMaterials",
        "parameters" : [ {
          "$ref" : "#/components/parameters/materialGroupId"
        }, {
          "$ref" : "#/components/parameters/collectionLimit"
        }, {
          "$ref" : "#/components/parameters/collectionPage"
        } ],
        "responses" : {
          "200" : {
            "description" : "Ok",
            "content" : {
              "application/json" : {
                "schema" : {
                  "title" : "MaterialListResponse",
                  "type" : "object",
                  "properties" : {
                    "_links" : {
                      "$ref" : "#/components/schemas/CollectionLinks"
                    },
                    "_meta" : {
                      "$ref" : "#/components/schemas/CollectionMeta"
                    },
                    "_embedded" : {
                      "type" : "array",
                      "items" : {
                        "$ref" : "#/components/schemas/MaterialResponse"
                      }
                    }
                  }
                }
              }
            }
          },
          "404" : {
            "$ref" : "#/components/responses/NotFound"
          }
        }
      },
      "post" : {
        "tags" : [ "Materials" ],
        "summary" : "Create a new material",
        "operationId" : "createMaterial",
        "parameters" : [ {
          "$ref" : "#/components/parameters/materialGroupId"
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CreateMaterialRequest"
              }
            }
          }
        },
        "responses" : {
          "201" : {
            "description" : "Material created successfully",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MaterialResponse"
                }
              }
            }
          },
          "404" : {
            "description" : "Material group was not found"
          }
        }
      }
    },
    "/materialgroups/{materialGroupId}/materials/{materialId}" : {
      "get" : {
        "tags" : [ "Materials" ],
        "summary" : "Get information about an existing material",
        "operationId" : "getMaterialData",
        "parameters" : [ {
          "$ref" : "#/components/parameters/materialGroupId"
        }, {
          "$ref" : "#/components/parameters/materialId"
        } ],
        "responses" : {
          "200" : {
            "description" : "Ok",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MaterialResponse"
                }
              }
            }
          },
          "404" : {
            "description" : "Material group or material was not found"
          }
        }
      },
      "put" : {
        "tags" : [ "Materials" ],
        "summary" : "Update an existing material",
        "operationId" : "updateMaterialData",
        "parameters" : [ {
          "$ref" : "#/components/parameters/materialGroupId"
        }, {
          "$ref" : "#/components/parameters/materialId"
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CreateMaterialRequest"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "Material was successfully updated",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MaterialResponse"
                }
              }
            }
          },
          "404" : {
            "description" : "Material group or material was not found"
          }
        }
      },
      "delete" : {
        "tags" : [ "Materials" ],
        "summary" : "Remove an existing material",
        "operationId" : "deleteMaterialData",
        "parameters" : [ {
          "$ref" : "#/components/parameters/materialGroupId"
        }, {
          "$ref" : "#/components/parameters/materialId"
        } ],
        "responses" : {
          "200" : {
            "description" : "Material was successfully updated"
          },
          "404" : {
            "description" : "Material group or material was not found"
          }
        }
      }
    }
  },
  "components" : {
    "schemas" : {
      "Project" : {
        "required" : [ "description", "measurementSystem", "name" ],
        "type" : "object",
        "properties" : {
          "projectId" : {
            "type" : "string",
            "readOnly" : true
          },
          "createdAt" : {
            "type" : "string",
            "format" : "date-time",
            "readOnly" : true
          },
          "name" : {
            "maxLength" : 250,
            "type" : "string",
            "description" : "The project title should contain the application you want to analyze as well as the simulation method you want to use, e.g. 'Heat exchanger - CHT simulation'.\n"
          },
          "description" : {
            "maxLength" : 2000,
            "type" : "string",
            "description" : "A meaningful description of the project."
          },
          "measurementSystem" : {
            "type" : "string",
            "description" : "The measurement system of the project. Can't be modifed.",
            "default" : "SI",
            "enum" : [ "SI", "US_CUSTOMARY" ]
          },
          "tags" : {
            "maxItems" : 12,
            "type" : "array",
            "items" : {
              "maxLength" : 50,
              "type" : "string"
            }
          }
        },
        "example" : {
          "projectId" : "1234123412341234",
          "createdAt" : "2020-01-01T01:00:00Z",
          "name" : "My first project",
          "description" : "My first project description",
          "measurementSystem" : "SI",
          "tags" : [ "FEA", "CFD" ]
        }
      },
      "Storage" : {
        "type" : "object",
        "properties" : {
          "url" : {
            "type" : "string",
            "description" : "The URL of the temporary storage location.",
            "format" : "uri",
            "readOnly" : true
          },
          "storageId" : {
            "minLength" : 1,
            "type" : "string",
            "description" : "The storage ID."
          },
          "expiresAt" : {
            "type" : "string",
            "description" : "The expiration time.",
            "format" : "date-time"
          }
        },
        "example" : {
          "url" : "https://httpbin.org/anything/asdfghjk?KeyId=ABC123&Signature=aZ09%2B%2F%3D&x-security-token=F%2B5%2FX&Expires=1583334977",
          "storageId" : "qwertyuiop1234567890",
          "expiresAt" : "2020-03-04T15:16:17Z"
        }
      },
      "Geometry" : {
        "type" : "object",
        "properties" : {
          "geometryId" : {
            "type" : "string",
            "format" : "uuid",
            "readOnly" : true
          },
          "name" : {
            "type" : "string",
            "description" : "The name of the geometry."
          },
          "createdAt" : {
            "type" : "string",
            "description" : "The time when the geometry was imported.",
            "format" : "date-time",
            "readOnly" : true
          },
          "format" : {
            "type" : "string",
            "description" : "The geometry format.",
            "readOnly" : true
          }
        },
        "example" : {
          "geometryId" : "159c159c-159c-159c-159c-159c159c159c",
          "name" : "My first geometry",
          "createdAt" : "2020-03-04T15:16:17Z",
          "format" : "STL"
        }
      },
      "GeometryImportRequest" : {
        "required" : [ "format", "inputUnit", "location", "name", "options" ],
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "The name of the imported geometry."
          },
          "location" : {
            "required" : [ "storageId" ],
            "type" : "object",
            "properties" : {
              "storageId" : {
                "minLength" : 1,
                "type" : "string",
                "description" : "The storage ID of the temporary storage location where the CAD file has been uploaded."
              }
            }
          },
          "format" : {
            "type" : "string",
            "description" : "The CAD format.",
            "enum" : [ "ACIS", "AUTODESK", "CATIA", "CREO", "IGES", "NX", "PARASOLID", "REVIT", "RHINOCEROS", "SOLIDEDGE", "SOLIDWORKS", "STEP", "STL" ]
          },
          "inputUnit" : {
            "$ref" : "#/components/schemas/GeometryUnit"
          },
          "options" : {
            "required" : [ "facetSplit", "improve", "optimizeForLBMSolver", "sewing" ],
            "type" : "object",
            "properties" : {
              "facetSplit" : {
                "type" : "boolean",
                "description" : "_Facet Split_ tries to split the faceted parts of a model. This means it can create new faces from original faces.\nIn this case it's not possible to use the original faces to make assignments.\n",
                "default" : false
              },
              "sewing" : {
                "type" : "boolean",
                "description" : "_Automatic Sewing_ is sewing faces or sheet bodies together.\nThis means that it can create one new face from two (or more) original faces, as well as one solid body from two (or more) original sheet bodies.\nIn this case, if the entities have the same ID, it will be inherited by the newly created entity.\nHowever if the original entities do not share the same ID, only one of these will be mapped to the new entity.\nThis might not be desirable if one would like to make assignments on the original entities and not on the new (sewn) entities.\n",
                "default" : false
              },
              "improve" : {
                "type" : "boolean",
                "description" : "This option tries to improve the topology (e.g. edges, vertices) and geometry of the model by adjusting tolerances, simplifying entities, etc.\nAs this option should improve CAD operations and data handling for all downstream applications it is recommended to use it on import.\nFor very complex models it can take a considerable amount of time though, therefore you can also opt-out and reconsider in case you face issues in geometry handling or meshing.\n",
                "default" : true
              },
              "optimizeForLBMSolver" : {
                "type" : "boolean",
                "description" : "This option allows you to import a *.stl file that is optimized for the Incompressible LBM and Wind Comfort analysis types.\nIt leaves out complex import steps like sewing and cleanup that are not required by the LBM solver and therefore also allows to import big and complex models fast.\n",
                "default" : false
              }
            },
            "description" : "CAD import options. Please refer to https://www.simscale.com/docs/cad-preparation/#cad-upload-options for a detailed description of the options."
          }
        },
        "example" : {
          "name" : "My first geometry",
          "location" : {
            "storageId" : "qwertyuiop1234567890"
          },
          "format" : "STL",
          "inputUnit" : "m",
          "options" : {
            "facetSplit" : false,
            "sewing" : false,
            "improve" : true,
            "optimizeForLBMSolver" : true
          }
        }
      },
      "GeometryImportResponse" : {
        "title" : "GeometryImportResponse",
        "required" : [ "geometryImportId", "status" ],
        "type" : "object",
        "properties" : {
          "geometryImportId" : {
            "type" : "string",
            "description" : "The ID of the geometry import operation.",
            "format" : "uuid",
            "readOnly" : true
          },
          "status" : {
            "$ref" : "#/components/schemas/Status"
          },
          "geometryId" : {
            "type" : "string",
            "description" : "The ID of the imported geometry when the import succeeded.",
            "format" : "uuid",
            "readOnly" : true
          },
          "failureReason" : {
            "$ref" : "#/components/schemas/LogEntry"
          }
        },
        "example" : {
          "geometryImportId" : "f48bf48b-f48b-f48b-f48b-f48bf48bf48b",
          "status" : "FINISHED",
          "geometryId" : "159c159c-159c-159c-159c-159c159c159c",
          "failureReason" : null
        }
      },
      "Mesh" : {
        "type" : "object",
        "properties" : {
          "meshId" : {
            "type" : "string",
            "description" : "The ID of the mesh.",
            "format" : "uuid",
            "readOnly" : true
          },
          "name" : {
            "type" : "string",
            "description" : "The name of the mesh."
          },
          "createdAt" : {
            "type" : "string",
            "description" : "The time when the mesh was imported.",
            "format" : "date-time",
            "readOnly" : true
          },
          "numberOfCells" : {
            "minimum" : 0,
            "type" : "integer",
            "description" : "Number of cells of the mesh.",
            "readOnly" : true
          },
          "numberOfNodes" : {
            "minimum" : 0,
            "type" : "integer",
            "description" : "Number of nodes of the mesh.",
            "readOnly" : true
          }
        },
        "example" : {
          "meshId" : "159c159c-159c-159c-159c-159c159c159c",
          "name" : "My first mesh",
          "createdAt" : "2020-03-04T15:16:17Z",
          "numberOfCells" : 20000,
          "numberOfNodes" : 30000
        }
      },
      "MeshOperation" : {
        "required" : [ "geometryId", "model", "name", "version" ],
        "type" : "object",
        "properties" : {
          "meshOperationId" : {
            "type" : "string",
            "description" : "The mesh operation ID.",
            "format" : "uuid",
            "readOnly" : true
          },
          "name" : {
            "type" : "string",
            "description" : "The name of the mesh operation."
          },
          "version" : {
            "type" : "string",
            "default" : "0.5"
          },
          "geometryId" : {
            "type" : "string",
            "description" : "The geometry ID of the mesh operation.",
            "format" : "uuid"
          },
          "model" : {
            "$ref" : "#/components/schemas/Algorithm"
          },
          "createdAt" : {
            "type" : "string",
            "description" : "The time the mesh operation was created.",
            "format" : "date-time",
            "readOnly" : true
          },
          "modifiedAt" : {
            "type" : "string",
            "description" : "The time the mesh operation was last modified.",
            "format" : "date-time",
            "readOnly" : true
          },
          "startedAt" : {
            "type" : "string",
            "description" : "The time the mesh operation was started.",
            "format" : "date-time",
            "readOnly" : true
          },
          "finishedAt" : {
            "type" : "string",
            "description" : "The time the mesh operation was finished.",
            "format" : "date-time",
            "readOnly" : true
          },
          "computeResource" : {
            "$ref" : "#/components/schemas/MeshOperationComputeResource"
          },
          "status" : {
            "$ref" : "#/components/schemas/Status"
          },
          "progress" : {
            "maximum" : 1,
            "minimum" : 0,
            "type" : "number",
            "description" : "The current progress while the mesh operation is in progress.",
            "readOnly" : true
          },
          "meshId" : {
            "type" : "string",
            "description" : "The ID of the generated mesh.",
            "format" : "uuid",
            "readOnly" : true
          }
        },
        "example" : {
          "meshOperationId" : "159c159c-159c-159c-159c-159c159c159c",
          "name" : "My Mesh Operation",
          "version" : 18,
          "geometryId" : "159c159c-159c-159c-159c-159c159c159c",
          "createdAt" : "2020-03-04T15:16:17Z",
          "startedAt" : "2020-03-04T15:17:18Z",
          "finishedAt" : "2020-03-04T17:29:42Z",
          "computeResource" : {
            "type" : "GPU_HOURS",
            "value" : 0.27
          },
          "model" : {
            "type" : "SIMMETRIX_MESHING_FLUID_V16",
            "sizing" : {
              "type" : "AUTOMATIC_V9",
              "fineness" : 3
            },
            "refinements" : [ ],
            "cellZones" : [ ],
            "automaticLayerSettings" : {
              "type" : "AUTOMATIC_LAYER_OFF"
            },
            "physicsBasedMeshing" : false,
            "hexCore" : true,
            "numOfProcessors" : -1,
            "advancedSimmetrixSettings" : {
              "smallFeatureTolerance" : {
                "value" : 1.0E-5,
                "unit" : "m"
              },
              "gapElements" : 0.05
            }
          },
          "status" : "FINISHED",
          "progress" : 1,
          "meshId" : "159c159c-159c-159c-159c-159c159c159c"
        }
      },
      "EntityDescription" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "The internal name of the entity."
          },
          "class" : {
            "type" : "string",
            "description" : "The topological entity class (body or face)."
          },
          "originateFrom" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OriginalEntityReference"
            }
          }
        },
        "example" : {
          "name" : "B1_TE1",
          "class" : "body",
          "originateFrom" : [ {
            "path" : [ ],
            "body" : "CentralPark",
            "entity" : "Tower",
            "attributeList" : [ ]
          } ]
        }
      },
      "OriginalEntityReference" : {
        "type" : "object",
        "properties" : {
          "path" : {
            "type" : "array",
            "description" : "The path from the root of the model.",
            "items" : {
              "$ref" : "#/components/schemas/BodyPath"
            }
          },
          "body" : {
            "type" : "string",
            "description" : "The original body name."
          },
          "entity" : {
            "type" : "string",
            "description" : "The original entity name."
          },
          "attributeList" : {
            "type" : "array",
            "description" : "The attributes assigned to the entity.",
            "items" : {
              "$ref" : "#/components/schemas/EntityAttribute"
            }
          }
        }
      },
      "BodyPath" : {
        "type" : "object",
        "properties" : {
          "assembly" : {
            "type" : "string"
          },
          "instance" : {
            "type" : "string"
          }
        }
      },
      "EntityAttribute" : {
        "type" : "object",
        "properties" : {
          "attribute" : {
            "type" : "string"
          },
          "value" : {
            "type" : "string"
          }
        }
      },
      "TableImportRequest" : {
        "title" : "TableImportRequest",
        "required" : [ "location" ],
        "type" : "object",
        "properties" : {
          "location" : {
            "required" : [ "storageId" ],
            "type" : "object",
            "properties" : {
              "storageId" : {
                "minLength" : 1,
                "type" : "string",
                "description" : "The storage ID of the temporary storage location where the table has been uploaded."
              }
            }
          }
        },
        "example" : {
          "location" : {
            "storageId" : "qwertyuiop1234567890"
          }
        }
      },
      "TableImportResponse" : {
        "title" : "TableImportResponse",
        "required" : [ "tableId" ],
        "type" : "object",
        "properties" : {
          "tableId" : {
            "type" : "string",
            "description" : "The ID of the imported table.",
            "format" : "uuid",
            "readOnly" : true
          }
        },
        "example" : {
          "tableId" : "159c159c-159c-159c-159c-159c159c159c"
        }
      },
      "GeometryPrimitiveResponse" : {
        "title" : "GeometryPrimitiveResponse",
        "required" : [ "geometryPrimitiveId" ],
        "type" : "object",
        "properties" : {
          "geometryPrimitiveId" : {
            "type" : "string",
            "description" : "The ID of the created geometry primitive.",
            "format" : "uuid",
            "readOnly" : true
          }
        },
        "example" : {
          "geometryPrimitiveId" : "159c159c-159c-159c-159c-159c159c159c"
        }
      },
      "SimulationSpec" : {
        "required" : [ "geometryId", "model", "name", "version" ],
        "type" : "object",
        "properties" : {
          "simulationId" : {
            "type" : "string",
            "format" : "uuid",
            "readOnly" : true
          },
          "name" : {
            "type" : "string"
          },
          "version" : {
            "type" : "string",
            "default" : "11.0"
          },
          "createdAt" : {
            "type" : "string",
            "format" : "date-time",
            "readOnly" : true
          },
          "modifiedAt" : {
            "type" : "string",
            "format" : "date-time",
            "readOnly" : true
          },
          "geometryId" : {
            "type" : "string",
            "format" : "uuid"
          },
          "meshId" : {
            "type" : "string",
            "description" : "The generated mesh ID which is to be used in the simulation. This field should be left empty for analysis types that do not require a generated mesh like 'INCOMPRESSIBLE_PACEFISH', 'WIND_COMFORT', and 'SIMERICS_ANALYSIS'.",
            "format" : "uuid"
          },
          "model" : {
            "$ref" : "#/components/schemas/Analysis"
          },
          "parameters" : {
            "$ref" : "#/components/schemas/Parameters"
          }
        }
      },
      "MaterialUpdateResponse" : {
        "required" : [ "spec", "tables" ],
        "type" : "object",
        "properties" : {
          "spec" : {
            "$ref" : "#/components/schemas/SimulationSpec"
          },
          "tables" : {
            "$ref" : "#/components/schemas/Tables"
          }
        },
        "description" : "Material update response schema"
      },
      "MaterialUpdateOperation" : {
        "required" : [ "path" ],
        "type" : "object",
        "properties" : {
          "path" : {
            "type" : "string",
            "description" : "JSON pointer (considering the `model` field as root) specifying where to add the material. If it points to a container (e.g. `/materials` or `/materials/solids`), the material will be added to that container.\nIf it points to an existing material instead (e.g. `/materials/0` or `/materials/solids/0`), the new material will replace the one the pointer points to.\n"
          },
          "materialData" : {
            "$ref" : "#/components/schemas/MaterialResponse"
          },
          "materialSpec" : {
            "type" : "object",
            "description" : "Material spec object that will be used as the base to apply the physical properties passed in `materialData`."
          },
          "reference" : {
            "$ref" : "#/components/schemas/MaterialUpdateOperationReference"
          }
        },
        "description" : "Material update operation, which can be either updating an existing material in the spec, or adding a new one. See the `path` property to learn how add/update operations are distinguished.\n"
      },
      "MaterialUpdateOperationReference" : {
        "type" : "object",
        "properties" : {
          "materialGroupId" : {
            "type" : "string",
            "description" : "Identifier of the material group",
            "example" : "internal:ef304761-dbde-495e-9891-9ee85e809cd5"
          },
          "materialId" : {
            "type" : "string",
            "description" : "Identifier of the material",
            "example" : "internal:69bb2bf0-6743-4bf8-b926-c0e447eeeeee"
          }
        },
        "description" : "Reference identifiers of the provided material and its material group"
      },
      "Tables" : {
        "type" : "array",
        "description" : "Tables containing parametric values, created during the material update operation(s). These tables are going to be used by the solvers during the simulation runs.",
        "items" : {
          "required" : [ "data", "id" ],
          "type" : "object",
          "properties" : {
            "id" : {
              "type" : "string",
              "format" : "uuid"
            },
            "data" : {
              "required" : [ "columnLabels", "rows" ],
              "type" : "object",
              "properties" : {
                "columnLabels" : {
                  "type" : "array",
                  "description" : "List of the table's columns",
                  "items" : {
                    "type" : "string"
                  }
                },
                "rows" : {
                  "type" : "array",
                  "description" : "Array of table rows.",
                  "items" : {
                    "required" : [ "elements" ],
                    "type" : "object",
                    "properties" : {
                      "elements" : {
                        "type" : "array",
                        "description" : "Values of the current row. These values are in the order specified by the `columnLabels` field.",
                        "items" : {
                          "type" : "string"
                        }
                      }
                    }
                  }
                }
              },
              "description" : "Table data"
            }
          }
        }
      },
      "InterpolationParameters" : {
        "type" : "object",
        "additionalProperties" : {
          "required" : [ "unit", "value" ],
          "type" : "object",
          "properties" : {
            "value" : {
              "type" : "number",
              "description" : "Numerical value of the property."
            },
            "unit" : {
              "type" : "string",
              "description" : "Unit of the property."
            }
          },
          "description" : "Value-unit pairs for the specified property."
        },
        "description" : "Parameters taken into account when some material property values need to be interpolated. When this object is part of a request, the parameters will be taken into account during interpolation,\nwhile when it's part of the response, the parameters show the values which were used (if any) during the interpolation. Note that the values used during interpolation might differ from what is requested.\n",
        "example" : "{'temperature': {'value': 150.0, 'unit': ''}}"
      },
      "Simulation" : {
        "type" : "object",
        "properties" : {
          "simulationId" : {
            "type" : "string",
            "format" : "uuid",
            "readOnly" : true
          },
          "name" : {
            "type" : "string",
            "description" : "The name of the simulation."
          }
        },
        "example" : {
          "simulationId" : "260d260d-260d-260d-260d-260d260d260d",
          "name" : "My first simulation"
        }
      },
      "WindData" : {
        "required" : [ "name" ],
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "The name of the newly created simulation run."
          }
        },
        "example" : {
          "name" : "PWC with new wind data"
        }
      },
      "SimulationRun" : {
        "required" : [ "name" ],
        "type" : "object",
        "properties" : {
          "runId" : {
            "type" : "string",
            "format" : "uuid",
            "readOnly" : true
          },
          "name" : {
            "type" : "string",
            "description" : "The name of the simulation run."
          },
          "createdAt" : {
            "type" : "string",
            "description" : "The time when the simulation run was created.",
            "format" : "date-time",
            "readOnly" : true
          },
          "startedAt" : {
            "type" : "string",
            "description" : "The time when the simulation run was started.",
            "format" : "date-time",
            "readOnly" : true
          },
          "finishedAt" : {
            "type" : "string",
            "description" : "The time when the simulation run was finished.",
            "format" : "date-time",
            "readOnly" : true
          },
          "duration" : {
            "type" : "string",
            "description" : "The actual duration of the simulation run.",
            "format" : "duration",
            "readOnly" : true
          },
          "computeResource" : {
            "$ref" : "#/components/schemas/SimulationRunComputeResource"
          },
          "status" : {
            "$ref" : "#/components/schemas/Status"
          },
          "progress" : {
            "maximum" : 1,
            "minimum" : 0,
            "type" : "number",
            "description" : "The current progress while the simulation run is in progress.",
            "readOnly" : true
          }
        },
        "example" : {
          "runId" : "37ae37ae-37ae-37ae-37ae-37ae37ae37ae",
          "name" : "My first simulation run",
          "createdAt" : "2020-03-04T15:16:17Z",
          "startedAt" : "2020-03-04T15:17:18Z",
          "finishedAt" : "2020-03-04T17:29:42Z",
          "duration" : "PT2H12M14S",
          "computeResource" : {
            "type" : "GPU_HOURS",
            "value" : 0.27
          },
          "status" : "FINISHED",
          "progress" : 1,
          "isContinuable" : false
        }
      },
      "SimulationRunComputeResource" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/ComputeResourceType"
          },
          "value" : {
            "type" : "number",
            "format" : "double",
            "readOnly" : true
          }
        },
        "description" : "The actual compute resources (CPUh or GPUh) consumed by the simulation run.",
        "readOnly" : true
      },
      "MeshOperationComputeResource" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/ComputeResourceType"
          },
          "value" : {
            "type" : "number",
            "format" : "double",
            "readOnly" : true
          }
        },
        "description" : "The actual compute resources (CPUh only) consumed by the mesh operation.",
        "readOnly" : true
      },
      "SimulationRunResultType" : {
        "title" : "Type",
        "type" : "string",
        "description" : "The result type.\nThe possible values are SOLUTION_FIELD, CONVERGENCE_PLOT, PLOT, TABLE.\n",
        "readOnly" : true
      },
      "SimulationRunResultCategory" : {
        "title" : "Category",
        "type" : "string",
        "description" : "The result category.\nFor solution fields values include 'SOLUTION', 'AVERAGED_SOLUTION', 'TRANSIENT_SOLUTION', 'STATISTICAL_SURFACE_SOLUTION', etc.\nFor convergence plots values include 'RESIDUALS_PLOT', 'NUMBER_OF_NEWTON_ITERATIONS', etc.\nFor plots values include 'FORCE_PLOT', 'FORCE_COEFFICIENTS_PLOT', 'PROBE_POINT_PLOT', 'AREA_AVERAGE', 'FACE_CALC', etc.\n",
        "readOnly" : true
      },
      "SimulationRunResultQuantity" : {
        "title" : "Quantity",
        "type" : "string",
        "description" : "The result quantity, only applies to plot result types.\nValid values include 'Ux', 'Uy', 'Uz', 'p', 'k', 'omega', 'T', 'displacement', 'von Mises stress', etc.\n",
        "readOnly" : true
      },
      "SimulationRunResultName" : {
        "title" : "Name",
        "type" : "string",
        "description" : "The name that was defined for extra simulation result outputs",
        "readOnly" : true
      },
      "SimulationRunResultDirection" : {
        "title" : "Direction",
        "type" : "number",
        "description" : "The result direction, only applies to Pedestrian Wind Comfort analysis",
        "readOnly" : true
      },
      "OneOfSimulationRunResult" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SOLUTION_FIELD" : "#/components/schemas/SimulationRunResultSolution",
            "CONVERGENCE_PLOT" : "#/components/schemas/SimulationRunResultConvergencePlot",
            "PLOT" : "#/components/schemas/SimulationRunResultPlot",
            "TABLE" : "#/components/schemas/SimulationRunResultTable"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SimulationRunResultSolution"
        }, {
          "$ref" : "#/components/schemas/SimulationRunResultConvergencePlot"
        }, {
          "$ref" : "#/components/schemas/SimulationRunResultPlot"
        }, {
          "$ref" : "#/components/schemas/SimulationRunResultTable"
        } ]
      },
      "SimulationRunResultSolution" : {
        "title" : "Solution",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "default" : "SOLUTION_FIELD"
          },
          "resultId" : {
            "type" : "string",
            "description" : "The result ID",
            "format" : "uuid"
          },
          "category" : {
            "$ref" : "#/components/schemas/SimulationRunResultCategory"
          },
          "direction" : {
            "$ref" : "#/components/schemas/SimulationRunResultDirection"
          },
          "modifiedAt" : {
            "type" : "string",
            "description" : "The time when the result was last modified.",
            "format" : "date-time",
            "readOnly" : true
          },
          "download" : {
            "$ref" : "#/components/schemas/SimulationRunResultDownload"
          }
        }
      },
      "SimulationRunResultConvergencePlot" : {
        "title" : "Convergence Plot",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "default" : "CONVERGENCE_PLOT"
          },
          "resultId" : {
            "type" : "string",
            "description" : "The result ID",
            "format" : "uuid"
          },
          "category" : {
            "$ref" : "#/components/schemas/SimulationRunResultCategory"
          },
          "direction" : {
            "$ref" : "#/components/schemas/SimulationRunResultDirection"
          },
          "modifiedAt" : {
            "type" : "string",
            "description" : "The time when the result was last modified.",
            "format" : "date-time",
            "readOnly" : true
          },
          "download" : {
            "$ref" : "#/components/schemas/SimulationRunResultDownload"
          }
        }
      },
      "SimulationRunResultPlot" : {
        "title" : "Plot",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "default" : "PLOT"
          },
          "resultId" : {
            "type" : "string",
            "description" : "The result ID",
            "format" : "uuid"
          },
          "category" : {
            "$ref" : "#/components/schemas/SimulationRunResultCategory"
          },
          "direction" : {
            "$ref" : "#/components/schemas/SimulationRunResultDirection"
          },
          "quantity" : {
            "$ref" : "#/components/schemas/SimulationRunResultQuantity"
          },
          "name" : {
            "$ref" : "#/components/schemas/SimulationRunResultName"
          },
          "modifiedAt" : {
            "type" : "string",
            "description" : "The time when the result was last modified.",
            "format" : "date-time",
            "readOnly" : true
          },
          "download" : {
            "$ref" : "#/components/schemas/SimulationRunResultDownload"
          }
        }
      },
      "SimulationRunResultTable" : {
        "title" : "Table",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "default" : "TABLE"
          },
          "resultId" : {
            "type" : "string",
            "description" : "The result ID",
            "format" : "uuid"
          },
          "category" : {
            "$ref" : "#/components/schemas/SimulationRunResultCategory"
          },
          "direction" : {
            "$ref" : "#/components/schemas/SimulationRunResultDirection"
          },
          "name" : {
            "$ref" : "#/components/schemas/SimulationRunResultName"
          },
          "modifiedAt" : {
            "type" : "string",
            "description" : "The time when the result was last modified.",
            "format" : "date-time",
            "readOnly" : true
          },
          "download" : {
            "$ref" : "#/components/schemas/SimulationRunResultDownload"
          }
        }
      },
      "SimulationRunResultDownload" : {
        "type" : "object",
        "properties" : {
          "format" : {
            "type" : "string",
            "description" : "The result format.\nValid values include `OPEN_FOAM`, `ENSIGHT_GOLD`, `PVD`, `VTM`, `CSV`.\n",
            "readOnly" : true
          },
          "uncompressedSizeInBytes" : {
            "type" : "integer",
            "description" : "The uncompressed size of the result content.",
            "format" : "int64",
            "readOnly" : true
          },
          "url" : {
            "type" : "string",
            "description" : "URL for downloading the result content.",
            "format" : "uri",
            "readOnly" : true
          },
          "compression" : {
            "type" : "string",
            "description" : "The compression used for the result download archive.",
            "readOnly" : true,
            "enum" : [ "NONE", "ZIP64" ]
          }
        }
      },
      "Estimation" : {
        "type" : "object",
        "properties" : {
          "duration" : {
            "$ref" : "#/components/schemas/Duration"
          },
          "computeResource" : {
            "$ref" : "#/components/schemas/ComputeResource"
          },
          "cellCount" : {
            "$ref" : "#/components/schemas/CellCount"
          },
          "totalRunCount" : {
            "type" : "integer",
            "description" : "The total number of jobs that will be triggered for this simulation run or mesh operation.",
            "readOnly" : true
          }
        },
        "example" : {
          "duration" : {
            "value" : "PT2H12M14S",
            "intervalMin" : "PT1H12M14S",
            "intervalMax" : "PT3H12M14S"
          },
          "computeResource" : {
            "type" : "GPU_HOURS",
            "value" : 0.27,
            "intervalMin" : 0.22,
            "intervalMax" : 0.32
          },
          "cellCount" : {
            "type" : "CELLS",
            "value" : 5361155,
            "intervalMin" : 4288924,
            "intervalMax" : 6433386
          },
          "totalRunCount" : 1
        }
      },
      "Duration" : {
        "type" : "object",
        "properties" : {
          "value" : {
            "type" : "string",
            "format" : "duration",
            "readOnly" : true
          },
          "intervalMin" : {
            "type" : "string",
            "format" : "duration",
            "readOnly" : true
          },
          "intervalMax" : {
            "type" : "string",
            "format" : "duration",
            "readOnly" : true
          }
        },
        "description" : "An interval with the estimated duration for a simulation run or a mesh operation."
      },
      "ComputeResource" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/ComputeResourceType"
          },
          "value" : {
            "type" : "number",
            "format" : "double",
            "readOnly" : true
          },
          "intervalMin" : {
            "type" : "number",
            "format" : "double",
            "readOnly" : true
          },
          "intervalMax" : {
            "type" : "number",
            "format" : "double",
            "readOnly" : true
          }
        },
        "description" : "An interval with the estimated compute resources (CPUh or GPUh) required to run the simulation."
      },
      "CellCount" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "readOnly" : true,
            "enum" : [ "CELLS" ]
          },
          "value" : {
            "type" : "integer",
            "format" : "int64",
            "readOnly" : true
          },
          "intervalMin" : {
            "type" : "integer",
            "format" : "int64",
            "readOnly" : true
          },
          "intervalMax" : {
            "type" : "integer",
            "format" : "int64",
            "readOnly" : true
          }
        },
        "description" : "An interval with the estimated cell count of the generated mesh."
      },
      "CollectionLinks" : {
        "title" : "Collection Links",
        "type" : "object",
        "properties" : {
          "first" : {
            "type" : "object",
            "properties" : {
              "href" : {
                "type" : "string",
                "description" : "First page of the collection.",
                "readOnly" : true,
                "example" : "/projects?page={firstPage}&limit={limit}"
              }
            }
          },
          "prev" : {
            "type" : "object",
            "properties" : {
              "href" : {
                "type" : "string",
                "description" : "Previous page in the collection.",
                "readOnly" : true,
                "example" : "/projects?page={previousPage}&limit={limit}"
              }
            }
          },
          "self" : {
            "type" : "object",
            "properties" : {
              "href" : {
                "type" : "string",
                "description" : "Current page of the collection.",
                "readOnly" : true,
                "example" : "/projects?page={currentPage}&limit={limit}"
              }
            }
          },
          "next" : {
            "type" : "object",
            "properties" : {
              "href" : {
                "type" : "string",
                "description" : "Next page in the collection.",
                "readOnly" : true,
                "example" : "/projects?page={nextPage}&limit={limit}"
              }
            }
          },
          "last" : {
            "type" : "object",
            "properties" : {
              "href" : {
                "type" : "string",
                "description" : "Last page of the collection.",
                "readOnly" : true,
                "example" : "/projects?page={lastPage}&limit={limit}"
              }
            }
          }
        }
      },
      "CollectionMeta" : {
        "title" : "Collection Meta Data",
        "type" : "object",
        "properties" : {
          "total" : {
            "type" : "integer",
            "description" : "Total number of resources in the collection.",
            "readOnly" : true
          }
        }
      },
      "ErrorResponse" : {
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SingleErrorResponse"
        }, {
          "$ref" : "#/components/schemas/MultipleErrorsResponse"
        } ]
      },
      "SingleErrorResponse" : {
        "title" : "Single error response",
        "type" : "object",
        "example" : {
          "severity" : "ERROR",
          "code" : "invalid-input",
          "message" : "description: invalid text input",
          "details" : {
            "path" : "$.description"
          },
          "trace" : "abcd1234"
        },
        "allOf" : [ {
          "$ref" : "#/components/schemas/LogEntry"
        }, {
          "type" : "object",
          "properties" : {
            "trace" : {
              "type" : "string",
              "readOnly" : true
            }
          }
        } ]
      },
      "MultipleErrorsResponse" : {
        "title" : "Multiple errors response",
        "required" : [ "severity entries" ],
        "type" : "object",
        "properties" : {
          "severity" : {
            "$ref" : "#/components/schemas/LogSeverity"
          },
          "entries" : {
            "minimum" : 1,
            "type" : "array",
            "readOnly" : true,
            "items" : {
              "$ref" : "#/components/schemas/LogEntry"
            }
          },
          "trace" : {
            "type" : "string",
            "readOnly" : true
          }
        },
        "example" : {
          "severity" : "ERROR",
          "entries" : [ {
            "severity" : "ERROR",
            "code" : "invalid-input",
            "message" : "Invalid text input",
            "details" : {
              "path" : "$.name"
            }
          }, {
            "severity" : "ERROR",
            "code" : "invalid-input",
            "message" : "Size must be between 0 and 250",
            "details" : {
              "path" : "$.description"
            }
          } ],
          "trace" : "abcd1234"
        }
      },
      "EventLogResponse" : {
        "title" : "Event log response",
        "required" : [ "entries" ],
        "type" : "object",
        "properties" : {
          "entries" : {
            "type" : "array",
            "readOnly" : true,
            "items" : {
              "$ref" : "#/components/schemas/LogEntry"
            }
          }
        },
        "example" : {
          "severity" : "ERROR",
          "entries" : [ {
            "severity" : "INFO",
            "code" : "MSG_NUMBER_OF_SIMULATION_CELLS",
            "message" : "Number of simulation cells: 12345"
          }, {
            "severity" : "SUCCESS",
            "code" : "MSG_OF_RUN_FINISHED",
            "message" : "Run finished."
          }, {
            "severity" : "WARNING",
            "code" : "MSG_WARN_INCORRECT_RESOLUTION_FOR_TURBULENCE_MODEL",
            "message" : "Mesh resolution might not be sufficient for correct turbulence modeling. Please check your results and consider refining the mesh. (Directions: 0.0, 90.0, 180.0, 270.0)"
          }, {
            "severity" : "ERROR",
            "code" : "MSG_SYSTEM_FAILURE"
          } ]
        }
      },
      "CheckResponse" : {
        "title" : "Simulation check response",
        "required" : [ "severity entries" ],
        "type" : "object",
        "properties" : {
          "severity" : {
            "$ref" : "#/components/schemas/LogSeverity"
          },
          "entries" : {
            "type" : "array",
            "readOnly" : true,
            "items" : {
              "$ref" : "#/components/schemas/LogEntry"
            }
          }
        },
        "example" : {
          "severity" : "WARNING",
          "entries" : [ {
            "severity" : "WARNING",
            "code" : "increase-simulation-end-time-to-ensure-2-fluid-passes",
            "message" : "End time should be increased by at least 195 s ...",
            "details" : {
              "path" : "$.model.simulationControl.endTime",
              "topoEntities" : [ ]
            }
          } ]
        }
      },
      "LogEntry" : {
        "required" : [ "severity code message" ],
        "type" : "object",
        "properties" : {
          "severity" : {
            "$ref" : "#/components/schemas/LogSeverity"
          },
          "code" : {
            "type" : "string",
            "description" : "Code for e.g. programmatic handling of error conditions.",
            "readOnly" : true
          },
          "message" : {
            "type" : "string",
            "description" : "Human-readable description of the entry.",
            "readOnly" : true
          },
          "details" : {
            "type" : "object",
            "additionalProperties" : true,
            "description" : "Additional data to interpret and handle the entry.",
            "readOnly" : true
          }
        }
      },
      "LogSeverity" : {
        "type" : "string",
        "readOnly" : true,
        "enum" : [ "INFO", "SUCCESS", "WARNING", "ERROR" ]
      },
      "GeometryUnit" : {
        "title" : "GeometryUnit",
        "type" : "string",
        "default" : "m",
        "enum" : [ "m", "cm", "mm", "ft", "in", "yd" ]
      },
      "ComputeResourceType" : {
        "type" : "string",
        "readOnly" : true,
        "enum" : [ "CPU_HOURS", "GPU_HOURS" ]
      },
      "Status" : {
        "type" : "string",
        "description" : "Status of the operation.",
        "readOnly" : true,
        "enum" : [ "READY", "QUEUED", "RUNNING", "FINISHED", "CANCELED", "FAILED" ]
      },
      "ReportModel" : {
        "type" : "object",
        "description" : "Note: This object is replaced at runtime with the actual report model schema which is\nfetched from reporting service.\n"
      },
      "ReportDownload" : {
        "type" : "object",
        "description" : "Note: This object is replaced at runtime with the actual report model schema which is\nfetched from reporting service.\n"
      },
      "MaterialUpdateRequest" : {
        "required" : [ "operations" ],
        "type" : "object",
        "properties" : {
          "operations" : {
            "minItems" : 1,
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MaterialUpdateOperation"
            }
          },
          "interpolationParameters" : {
            "$ref" : "#/components/schemas/InterpolationParameters"
          }
        },
        "description" : "Material update request schema"
      },
      "Parameters" : {
        "type" : "object",
        "additionalProperties" : {
          "$ref" : "#/components/schemas/OneOf_Parameters"
        }
      },
      "ParameterWithValues" : {
        "required" : [ "valueSource" ],
        "type" : "object",
        "properties" : {
          "valueSource" : {
            "type" : "string",
            "description" : "Schema name: ParameterWithValues",
            "default" : "CONFIGURATION"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "path" : {
            "type" : "string",
            "format" : "json-pointer"
          },
          "values" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/AnyOf_ParameterWithValuesValues"
            }
          }
        },
        "additionalProperties" : false
      },
      "ParameterWithValueGenerator" : {
        "required" : [ "valueSource" ],
        "type" : "object",
        "properties" : {
          "valueSource" : {
            "type" : "string",
            "description" : "Schema name: ParameterWithValueGenerator",
            "default" : "GENERATOR"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "path" : {
            "type" : "string",
            "format" : "json-pointer"
          },
          "valueGenerator" : {
            "$ref" : "#/components/schemas/NumericalSequenceParameterValueGenerator"
          }
        },
        "additionalProperties" : false
      },
      "NumericalSequenceParameterValueGenerator" : {
        "required" : [ "inclusive", "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NumericalSequenceParameterValueGenerator",
            "default" : "NUMERICAL_SEQUENCE"
          },
          "start" : {
            "type" : "number"
          },
          "end" : {
            "type" : "number"
          },
          "step" : {
            "type" : "number"
          },
          "inclusive" : {
            "type" : "boolean"
          }
        },
        "additionalProperties" : false
      },
      "OneOf_Parameters" : {
        "discriminator" : {
          "propertyName" : "valueSource",
          "mapping" : {
            "CONFIGURATION" : "#/components/schemas/ParameterWithValues",
            "GENERATOR" : "#/components/schemas/ParameterWithValueGenerator"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ParameterWithValues"
        }, {
          "$ref" : "#/components/schemas/ParameterWithValueGenerator"
        } ]
      },
      "AnyOf_ParameterWithValuesValues" : {
        "anyOf" : [ {
          "type" : "string"
        }, {
          "type" : "number"
        }, {
          "type" : "integer"
        }, {
          "type" : "object"
        }, {
          "type" : "array",
          "items" : { }
        }, {
          "type" : "boolean"
        } ]
      },
      "GeometryPrimitive" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CARTESIAN_BOX" : "#/components/schemas/CartesianBox",
            "ROTATABLE_CARTESIAN_BOX" : "#/components/schemas/RotatableCartesianBox",
            "LOCAL_CARTESIAN_BOX" : "#/components/schemas/LocalCartesianBox",
            "SPHERE" : "#/components/schemas/Sphere",
            "LOCAL_SPHERE" : "#/components/schemas/LocalSphere",
            "CYLINDER" : "#/components/schemas/Cylinder",
            "POINT" : "#/components/schemas/Point",
            "BOX" : "#/components/schemas/Box",
            "HALF_SPACE" : "#/components/schemas/HalfSpace",
            "LOCAL_HALF_SPACE" : "#/components/schemas/LocalHalfSpace"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CartesianBox"
        }, {
          "$ref" : "#/components/schemas/RotatableCartesianBox"
        }, {
          "$ref" : "#/components/schemas/LocalCartesianBox"
        }, {
          "$ref" : "#/components/schemas/Sphere"
        }, {
          "$ref" : "#/components/schemas/LocalSphere"
        }, {
          "$ref" : "#/components/schemas/Cylinder"
        }, {
          "$ref" : "#/components/schemas/Point"
        }, {
          "$ref" : "#/components/schemas/Box"
        }, {
          "$ref" : "#/components/schemas/HalfSpace"
        }, {
          "$ref" : "#/components/schemas/LocalHalfSpace"
        } ]
      },
      "CartesianBox" : {
        "title" : "Cartesian box",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CartesianBox",
            "default" : "CARTESIAN_BOX"
          },
          "id" : {
            "title" : "Id",
            "type" : "string",
            "format" : "uuid"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "min" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "max" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVector_Length" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/DecimalVector"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m", "in" ]
          }
        },
        "additionalProperties" : false
      },
      "DecimalVector" : {
        "type" : "object",
        "properties" : {
          "x" : {
            "title" : "X",
            "type" : "number"
          },
          "y" : {
            "title" : "Y",
            "type" : "number"
          },
          "z" : {
            "title" : "Z",
            "type" : "number"
          }
        },
        "additionalProperties" : false
      },
      "RotatableCartesianBox" : {
        "title" : "Rotatable cartesian box",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: RotatableCartesianBox",
            "default" : "ROTATABLE_CARTESIAN_BOX"
          },
          "id" : {
            "title" : "Id",
            "type" : "string",
            "format" : "uuid"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "min" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "max" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "rotationPoint" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "rotationAngles" : {
            "$ref" : "#/components/schemas/DimensionalVector_Angle"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVector_Angle" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/DecimalVector"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "rad", "" ]
          }
        },
        "additionalProperties" : false
      },
      "LocalCartesianBox" : {
        "title" : "Local cartesian box",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: LocalCartesianBox",
            "default" : "LOCAL_CARTESIAN_BOX"
          },
          "id" : {
            "title" : "Id",
            "type" : "string",
            "format" : "uuid"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "orientationReference" : {
            "title" : "Orientation reference",
            "type" : "string",
            "default" : "GEOMETRY",
            "enum" : [ "GEOMETRY", "FLOW_DOMAIN" ]
          },
          "min" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "max" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          }
        },
        "additionalProperties" : false
      },
      "Sphere" : {
        "title" : "Sphere",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: Sphere",
            "default" : "SPHERE"
          },
          "id" : {
            "title" : "Id",
            "type" : "string",
            "format" : "uuid"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "center" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "radius" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_Length" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m", "in" ]
          }
        },
        "additionalProperties" : false
      },
      "LocalSphere" : {
        "title" : "Local sphere",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: LocalSphere",
            "default" : "LOCAL_SPHERE"
          },
          "id" : {
            "title" : "Id",
            "type" : "string",
            "format" : "uuid"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "orientationReference" : {
            "title" : "Orientation reference",
            "type" : "string",
            "default" : "GEOMETRY",
            "enum" : [ "GEOMETRY", "FLOW_DOMAIN" ]
          },
          "center" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "radius" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "Cylinder" : {
        "title" : "Cylinder",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: Cylinder",
            "default" : "CYLINDER"
          },
          "id" : {
            "title" : "Id",
            "type" : "string",
            "format" : "uuid"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "reference" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "axis" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "radius" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "Point" : {
        "title" : "Point",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: Point",
            "default" : "POINT"
          },
          "id" : {
            "title" : "Id",
            "type" : "string",
            "format" : "uuid"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "center" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          }
        },
        "additionalProperties" : false
      },
      "Box" : {
        "title" : "Box",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: Box",
            "default" : "BOX"
          },
          "id" : {
            "title" : "Id",
            "type" : "string",
            "format" : "uuid"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "scale" : {
            "$ref" : "#/components/schemas/DecimalVector"
          },
          "translation" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "rotationAxis" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "rotationAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_Angle" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "rad", "" ]
          }
        },
        "additionalProperties" : false
      },
      "HalfSpace" : {
        "title" : "Slice",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: HalfSpace",
            "default" : "HALF_SPACE"
          },
          "id" : {
            "title" : "Id",
            "type" : "string",
            "format" : "uuid"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "referencePoint" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "normal" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          }
        },
        "additionalProperties" : false
      },
      "LocalHalfSpace" : {
        "title" : "Local slice",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: LocalHalfSpace",
            "default" : "LOCAL_HALF_SPACE"
          },
          "id" : {
            "title" : "Id",
            "type" : "string",
            "format" : "uuid"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "orientationReference" : {
            "title" : "Orientation reference",
            "type" : "string",
            "default" : "GEOMETRY",
            "enum" : [ "GEOMETRY", "FLOW_DOMAIN" ]
          },
          "referencePoint" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "normal" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          }
        },
        "additionalProperties" : false
      },
      "Algorithm" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SIMMETRIX_MESHING_FLUID_V16" : "#/components/schemas/SimmetrixMeshingFluid",
            "SIMMETRIX_MESHING_SOLID" : "#/components/schemas/SimmetrixMeshingSolid",
            "HEX_DOMINANT_SNAPPY_V5" : "#/components/schemas/HexDominantSnappy"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SimmetrixMeshingFluid"
        }, {
          "$ref" : "#/components/schemas/SimmetrixMeshingSolid"
        }, {
          "$ref" : "#/components/schemas/HexDominantSnappy"
        } ]
      },
      "SimmetrixMeshingFluid" : {
        "title" : "Standard",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SimmetrixMeshingFluid",
            "default" : "SIMMETRIX_MESHING_FLUID_V16"
          },
          "sizing" : {
            "$ref" : "#/components/schemas/OneOf_SimmetrixMeshingFluidSizing"
          },
          "refinements" : {
            "title" : "Refinements",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_SimmetrixMeshingFluidRefinements"
            }
          },
          "cellZones" : {
            "title" : "Cell zones",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SimmetrixCellZones"
            },
            "x-showWhen" : [ "physicsBasedMeshing == false" ]
          },
          "automaticLayerSettings" : {
            "$ref" : "#/components/schemas/OneOf_SimmetrixMeshingFluidAutomaticLayerSettings"
          },
          "physicsBasedMeshing" : {
            "title" : "Physics-based meshing",
            "type" : "boolean",
            "description" : "Physics-based meshing takes setup information like materials, boundary conditions, and source terms into account to size the mesh accordingly. When enabled, the following adaptations will be made:</p><ul><li>Refinements on inlets and outlets</li><li>Different sizing for solid and fluid regions in CHT simulations</li></ul> <br>When toggled on users dont have to worry about creating a <a href='https://www.simscale.com/docs/simulation-setup/simulation-control/' target='_blank'>separate cell zone</a>.",
            "default" : true
          },
          "hexCore" : {
            "title" : "Hex element core",
            "type" : "boolean",
            "description" : "<p>If <a href='https://www.simscale.com/docs/simulation-setup/meshing/standard/#hexcore' target='_blank'><b>Hex element core</b></a> is activated, the interior of the mesh gets covered by <a href='https://www.simscale.com/docs/simulation-setup/meshing/standard/#hexcore' target='_blank'><b>hexahedral elements</b></a>. The transition to the triangulated surface mesh is covered by tetrahedral and pyramid elements.<img src=\"/spec/resources/help/imgs/simmetrix-hexcore.png\" class=\"helpPopupImage\"/>Meshclip through a hex-core mesh.</p>",
            "default" : true
          },
          "numOfProcessors" : {
            "title" : "Number of processors",
            "type" : "integer",
            "description" : "<p>Selecting more processor cores might speed up the meshing process. Choosing a smaller computation instance will save core hours. <a href='https://www.simscale.com/docs/simulation-setup/meshing/#number-of-processors' target='_blank'>Learn more</a>.</p>",
            "format" : "int64",
            "default" : -1,
            "enum" : [ -1, 4, 8, 16, 32, 64, 96 ]
          },
          "advancedSimmetrixSettings" : {
            "$ref" : "#/components/schemas/AdvancedSimmetrixFluidSettings"
          }
        },
        "additionalProperties" : false
      },
      "AutomaticMeshSizingSimmetrix" : {
        "title" : "Automatic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AutomaticMeshSizingSimmetrix",
            "default" : "AUTOMATIC_V9"
          },
          "fineness" : {
            "title" : "Fineness",
            "maximum" : 10,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Adjust the overall mesh sizing from coarse (value: 0) to fine (10).</p>",
            "default" : 5,
            "x-divisibleBy" : 0.1
          }
        },
        "additionalProperties" : false
      },
      "ManualMeshSizingSimmetrix" : {
        "title" : "Manual",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ManualMeshSizingSimmetrix",
            "default" : "MANUAL"
          },
          "maximumEdgeLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "minimumEdgeLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "RegionRefinementWithLength" : {
        "title" : "Region refinement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "A <b>region refinement</b> can be used to refine the mesh in a given area. The refinement area needs to be defined either via an existing solid or a geometry primitive.\n\nSchema name: RegionRefinementWithLength",
            "default" : "REGION_LENGTH"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Region refinement"
          },
          "refinement" : {
            "$ref" : "#/components/schemas/OneOf_RegionRefinementWithLengthRefinement"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE" ]
            }
          }
        },
        "additionalProperties" : false,
        "description" : "A <b>region refinement</b> can be used to refine the mesh in a given area. The refinement area needs to be defined either via an existing solid or a geometry primitive."
      },
      "InsideRegionRefinementWithLength" : {
        "title" : "Inside",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: InsideRegionRefinementWithLength",
            "default" : "INSIDE"
          },
          "length" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "DistanceRegionRefinementWithLength" : {
        "title" : "Distance",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: DistanceRegionRefinementWithLength",
            "default" : "DISTANCE"
          },
          "distanceRefinementLengths" : {
            "title" : "Distance refinement lengths",
            "type" : "array",
            "description" : "Define the desired cell edge length based on the distance to the surface of the assigned volumes. The distances need to be specified in <u>descending order</u> from top to bottom in the table.",
            "items" : {
              "$ref" : "#/components/schemas/RefinementLength"
            },
            "default" : [ {
              "distance" : {
                "value" : 0,
                "unit" : "m"
              },
              "length" : {
                "value" : 1,
                "unit" : "m"
              }
            } ]
          }
        },
        "additionalProperties" : false
      },
      "RefinementLength" : {
        "type" : "object",
        "properties" : {
          "distance" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "length" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "OutsideRegionRefinementWithLength" : {
        "title" : "Outside",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: OutsideRegionRefinementWithLength",
            "default" : "OUTSIDE"
          },
          "length" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "TopologicalReference" : {
        "type" : "object",
        "properties" : {
          "entities" : {
            "title" : "Entities",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "sets" : {
            "title" : "Sets",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            }
          }
        },
        "additionalProperties" : false
      },
      "SimmetrixLocalSizingRefinement" : {
        "title" : "Local element size",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Refine specific faces of interest or complex geometrical shapes by defining a local element size. This will ensure a relatively uniform mesh.\n\nSchema name: SimmetrixLocalSizingRefinement",
            "default" : "SIMMETRIX_LOCAL_SIZING_V10"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Local element size"
          },
          "maxElementSize" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "Refine specific faces of interest or complex geometrical shapes by defining a local element size. This will ensure a relatively uniform mesh."
      },
      "SimmetrixBoundaryLayerRefinement" : {
        "title" : "Inflate boundary layer",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p><a href='https://www.simscale.com/docs/simulation-setup/meshing/standard/#layer-inflation' target='_blank'><b>Layer inflation</b></a> allows the creation of prismatic boundary layers for certain mesh regions.</p><p>Prismatic layers are mostly used in CFD simulations on no-slip walls in order to efficiently capture the boundary layer velocity profile, but they may be also used in certain structural simulations like stamping or deep-drawing processes.</p><p><img src=\"/spec/resources/help/imgs/simmetrix-layers.png\" class=\"helpPopupImage\"/> The figure shows a sample mesh with boundary layers added.</p>\n\nSchema name: SimmetrixBoundaryLayerRefinement",
            "default" : "SIMMETRIX_BOUNDARY_LAYER_V13"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Inflate boundary layer"
          },
          "numberOfLayers" : {
            "title" : "Number of layers",
            "maximum" : 20,
            "exclusiveMaximum" : false,
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "The <i>Number of layers</i> defines how many prismatic boundary layers should be created. 3 is default.",
            "default" : 3
          },
          "totalRelativeThickness" : {
            "title" : "Overall relative thickness",
            "type" : "number",
            "description" : "It defines the thickness of all prismatic boundary layers combined in relation to the local element size.<img src=\"/spec/resources/help/imgs/simmetrix-overall-layer-thickness.png\" class=\"helpPopupImage\"/>Example 3-layer thickness of 40% (0.4) of the local mesh size.",
            "default" : 0.4
          },
          "layerType" : {
            "$ref" : "#/components/schemas/OneOf_SimmetrixBoundaryLayerRefinementLayerType"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<p><a href='https://www.simscale.com/docs/simulation-setup/meshing/standard/#layer-inflation' target='_blank'><b>Layer inflation</b></a> allows the creation of prismatic boundary layers for certain mesh regions.</p><p>Prismatic layers are mostly used in CFD simulations on no-slip walls in order to efficiently capture the boundary layer velocity profile, but they may be also used in certain structural simulations like stamping or deep-drawing processes.</p><p><img src=\"/spec/resources/help/imgs/simmetrix-layers.png\" class=\"helpPopupImage\"/> The figure shows a sample mesh with boundary layers added.</p>"
      },
      "FractionalHeight1" : {
        "title" : "Specify first layer thickness",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FractionalHeight1",
            "default" : "FRACTIONAL_HEIGHT_1"
          },
          "firstLayerSize" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "FractionalHeight2" : {
        "title" : "Specify growth rate",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FractionalHeight2",
            "default" : "FRACTIONAL_HEIGHT_2"
          },
          "growthRate" : {
            "title" : "Growth rate",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "The <i>Growth rate</i> defines the thickness ratio between adjacent boundary layer cells. It needs to be always greater than 1 such that the layer thickness increases towards the interior of the mesh. For the same number of layers and overall thickness the larger the growth rate is inversely proportional to the first cell thickness. <img src=\"/spec/resources/help/imgs/simmetrix-layer-growth-rate.png\" class=\"helpPopupImage\"/>Example of each cell being 1.5 times thicker than its adjacent.",
            "default" : 1.5
          }
        },
        "additionalProperties" : false
      },
      "SimmetrixCellZones" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SimmetrixCellZones",
            "default" : "SIMMETRIX_CELL_ZONES"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Zone"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "AutomaticLayerOn" : {
        "title" : "On",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AutomaticLayerOn",
            "default" : "AUTOMATIC_LAYER_ON"
          },
          "numberOfLayers" : {
            "title" : "Number of layers",
            "maximum" : 20,
            "exclusiveMaximum" : false,
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "The <i>Number of layers</i> defines how many prismatic boundary layers should be created. 3 is default.",
            "default" : 3
          },
          "totalRelativeThickness" : {
            "title" : "Overall relative thickness",
            "type" : "number",
            "description" : "It defines the thickness of all prismatic boundary layers combined in relation to the local element size.<img src=\"/spec/resources/help/imgs/simmetrix-overall-layer-thickness.png\" class=\"helpPopupImage\"/>Example 3-layer thickness of 40% (0.4) of the local mesh size.",
            "default" : 0.4
          },
          "layerType" : {
            "$ref" : "#/components/schemas/OneOf_AutomaticLayerOnLayerType"
          }
        },
        "additionalProperties" : false
      },
      "AutomaticLayerOff" : {
        "title" : "Off",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AutomaticLayerOff",
            "default" : "AUTOMATIC_LAYER_OFF"
          }
        },
        "additionalProperties" : false
      },
      "AdvancedSimmetrixFluidSettings" : {
        "type" : "object",
        "properties" : {
          "smallFeatureTolerance" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "gapElements" : {
            "title" : "Gap refinement factor",
            "maximum" : 4,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Define a target number of elements across the thickness of thin gaps. <a href='https://www.simscale.com/docs/simulation-setup/meshing/standard/#gap-refinement-factor' target='_blank'>Learn more</a>.<img src=\"/spec/resources/help/imgs/simmetrix-gap-elements.png\" class=\"helpPopupImage\"/>Example of gap refinements applied with a target of 4 elements across the thickness</p>",
            "default" : 0.05
          },
          "globalGradationRate" : {
            "title" : "Global gradation rate",
            "maximum" : 3,
            "exclusiveMaximum" : false,
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Adjust the transition from small to large cells. This value is the ratio between the size of two adjacent cells. The allowed range is 1.0 - 3.0. 1.0 would produce a uniform mesh with the smallest size everywhere. This is generally not recommended, as it may produce very large meshes.</p>",
            "default" : 1.22
          }
        },
        "additionalProperties" : false
      },
      "SimmetrixMeshingSolid" : {
        "title" : "Standard",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SimmetrixMeshingSolid",
            "default" : "SIMMETRIX_MESHING_SOLID"
          },
          "sizing" : {
            "$ref" : "#/components/schemas/OneOf_SimmetrixMeshingSolidSizing"
          },
          "refinements" : {
            "title" : "Refinements",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_SimmetrixMeshingSolidRefinements"
            }
          },
          "secondOrder" : {
            "title" : "2nd order elements",
            "type" : "boolean",
            "description" : "<p>The <a href='https://www.simscale.com/docs/simulation-setup/meshing/standard/#order' target='_blank'><b>mesh order</b></a> defines the shape and the number of nodes of the mesh elements. For a fast, rough analysis choose <i>first order</i> only. Activate <i>2nd order elements</i> for higher quality results</p>",
            "default" : false
          },
          "enableShellMeshing" : {
            "title" : "Enable shell meshing",
            "type" : "boolean",
            "default" : false
          },
          "surfaceElementType" : {
            "title" : "Surface element type",
            "type" : "string",
            "default" : "TRIANGULAR",
            "enum" : [ "TRIANGULAR", "QUADDOMINANT" ],
            "x-showWhen" : [ "enableShellMeshing == true" ]
          },
          "numOfProcessors" : {
            "title" : "Number of processors",
            "type" : "integer",
            "description" : "<p>Selecting more processor cores might speed up the meshing process. Choosing a smaller computation instance will save core hours. <a href='https://www.simscale.com/docs/simulation-setup/meshing/#number-of-processors' target='_blank'>Learn more</a>.</p>",
            "format" : "int64",
            "default" : -1,
            "enum" : [ -1, 4, 8, 16, 32, 64, 96 ]
          },
          "advancedSimmetrixSettings" : {
            "$ref" : "#/components/schemas/AdvancedSimmetrixSolidSettings"
          }
        },
        "additionalProperties" : false
      },
      "AdvancedSimmetrixSolidSettings" : {
        "type" : "object",
        "properties" : {
          "smallFeatureTolerance" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "gapElements" : {
            "title" : "Gap refinement factor",
            "maximum" : 4,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Define a target number of elements across the thickness of thin gaps. <a href='https://www.simscale.com/docs/simulation-setup/meshing/standard/#gap-refinement-factor' target='_blank'>Learn more</a>.<img src=\"/spec/resources/help/imgs/simmetrix-gap-elements.png\" class=\"helpPopupImage\"/>Example of gap refinements applied with a target of 4 elements across the thickness</p>",
            "default" : 0
          },
          "globalGradationRate" : {
            "title" : "Global gradation rate",
            "maximum" : 3,
            "exclusiveMaximum" : false,
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Adjust the transition from small to large cells. This value is the ratio between the size of two adjacent cells. The allowed range is 1.0 - 3.0. 1.0 would produce a uniform mesh with the smallest size everywhere. This is generally not recommended, as it may produce very large meshes.</p>",
            "default" : 1.22
          }
        },
        "additionalProperties" : false
      },
      "AutomaticMeshSizing" : {
        "title" : "Automatic mesh sizing",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AutomaticMeshSizing",
            "default" : "AUTOMATIC"
          },
          "fineness" : {
            "title" : "Fineness",
            "type" : "string",
            "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/#local-mesh-refinements' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>",
            "default" : "COARSE",
            "enum" : [ "VERY_COARSE", "COARSE", "MODERATE", "FINE", "VERY_FINE" ]
          }
        },
        "additionalProperties" : false
      },
      "ManualMeshSizing" : {
        "title" : "Manual mesh sizing",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ManualMeshSizing",
            "default" : "MANUAL"
          },
          "minimumEdgeLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "maximumEdgeLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "grading" : {
            "$ref" : "#/components/schemas/OneOf_ManualMeshSizingGrading"
          }
        },
        "additionalProperties" : false
      },
      "AutomaticMeshGrading" : {
        "title" : "Automatic mesh grading",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AutomaticMeshGrading",
            "default" : "AUTOMATIC"
          },
          "fineness" : {
            "title" : "Fineness",
            "type" : "string",
            "description" : "<p>The <b><a href='https://www.simscale.com/docs/simulation-setup/meshing/tet-dominant/#grading' target='_blank'>mesh grading</a></b> specifies how fine details of the geometry are resolved and also influences the quality of the resulting elements.</p><ul><li><p>If you select the <b>automatic</b> grading, you can specify how fine your mesh should be (ranging from <i>1 - very coarse</i> to <i>5 - very fine</i>) and all additional parameters will be set automatically.</li><li><p>For full control over the underlying parameters <i>number of segements per edge</i>, <i>number of segements per radius</i> and <i>growth rate</i> you can choose the <b>manual</b> mesh grading option.</p></li></ul><p><img src=\"/spec/resources/help/imgs/mesh_grading_comparison.png\" class=\"helpPopupImage\"/> The figure shows meshes for grading <i>1 - very coarse</i> (left) and <i>5 - very fine</i> (right).</p>",
            "default" : "COARSE",
            "enum" : [ "VERY_COARSE", "COARSE", "MODERATE", "FINE", "VERY_FINE" ]
          }
        },
        "additionalProperties" : false
      },
      "ManualMeshGrading" : {
        "title" : "Manual mesh grading",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ManualMeshGrading",
            "default" : "MANUAL"
          },
          "numberOfSegmentsPerEdge" : {
            "title" : "Number of segments per edge",
            "maximum" : 1000000,
            "exclusiveMaximum" : false,
            "minimum" : 0.2,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>This value defines the minimum number of elements along a <b>geometry edge</b>.</p>",
            "default" : 0.5
          },
          "numberOfSegmentsPerRadius" : {
            "title" : "Number of segments per radius",
            "maximum" : 1000000,
            "exclusiveMaximum" : false,
            "minimum" : 0.2,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>This value defines the minimum number of elements along a <b>geometry radius</b>.</p>",
            "default" : 1.5
          },
          "growthRate" : {
            "title" : "Growth rate",
            "maximum" : 10,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>The <b>growth rate</b> determines how large the allowed difference in element size between neighbouring elements is. For example a value of 0.2 allows the edges of neighbouring elements to differ by 20%.</p><p>If a large value is chosen, features requiring a finer mesh, like holes or fillets, will have a very local influence on the element size whereas for a small mesh grading those features will influence the element sizes in a wider area around them.</p><p>Choosing a smaller value will thus lead to a higher number of elements but also result in a better overall mesh quality.</p><p><img src=\"/spec/resources/help/imgs/growth_rate_comparison.png\" class=\"helpPopupImage\"/> The figure shows meshes for growth rate <i>2</i> (left) and <i>0.2</i> (right).</p>",
            "default" : 0.5
          }
        },
        "additionalProperties" : false
      },
      "LayerRefinement" : {
        "title" : "Layer inflation",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p><a href='https://www.simscale.com/docs/simulation-setup/meshing/tet-dominant/#layer-inflation' target='_blank'><b>Layer inflation</b></a> allows the creation of prismatic boundary layers for certain mesh regions.</p><p>Prismatic layers are mostly used in CFD simulations on no-slip walls in order to efficiently capture the boundary layer velocity profile, but they may be also used in certain structural simulations like stamping or deep-drawing processes.</p><p><img src=\"/spec/resources/help/imgs/boundary-layer.png\" class=\"helpPopupImage\"/> The figure shows a sample mesh with boundary layers added.</p>\n\nSchema name: LayerRefinement",
            "default" : "LAYER_INFLATION"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Layer inflation"
          },
          "totalThickness" : {
            "title" : "Total thickness",
            "maximum" : 1000000,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "This parameter controls the <b>overall thickness</b> of all the generated boundary layers together. This value must be smaller than the minimal geometry thickness at the specified locations, otherwise the meshing will fail.",
            "default" : 0.01
          },
          "layers" : {
            "title" : "Layers",
            "maximum" : 1000000,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "The number of <b>layers</b> defines how many prismatic boundary layers should be created.",
            "default" : 5
          },
          "stretchFactor" : {
            "title" : "Stretch factor",
            "maximum" : 1000000,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>The <b>stretch factor</b> determines how the boundary layers grow in thickness from the wall to the internal mesh. The larger the ratio, the larger each element layer will be in comparison to the neighbouring layer closer to the wall.</p><p><img src=\"/spec/resources/help/imgs/shm_bl_expansion-ratio.png\" class=\"helpPopupImage\"/> The figure shows a ratio of 1.3.</p>",
            "default" : 1.3
          },
          "allowQuadrangles" : {
            "title" : "Allow quadrangles",
            "type" : "boolean",
            "description" : "<p>This parameter determines if <a href='https://www.simscale.com/docs/simulation-setup/meshing/tet-dominant/#quadrangles' target='_blank'><b>quadrangular surface elements</b></a> shall be allowed. When disabled, only triangles will be used. Meshing with triangles only is usually more robust while quadrangular elements may lead to better results.</p><p><img src=\"/spec/resources/help/imgs/allow_quads_comparison.png\" class=\"helpPopupImage\"/> The figure shows sample meshes with quadrangular surface elements disallowed (left) and allowed (right).</p>",
            "default" : false
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<p><a href='https://www.simscale.com/docs/simulation-setup/meshing/tet-dominant/#layer-inflation' target='_blank'><b>Layer inflation</b></a> allows the creation of prismatic boundary layers for certain mesh regions.</p><p>Prismatic layers are mostly used in CFD simulations on no-slip walls in order to efficiently capture the boundary layer velocity profile, but they may be also used in certain structural simulations like stamping or deep-drawing processes.</p><p><img src=\"/spec/resources/help/imgs/boundary-layer.png\" class=\"helpPopupImage\"/> The figure shows a sample mesh with boundary layers added.</p>"
      },
      "SubmeshRefinement" : {
        "title" : "Local element size",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>The refinement type <a href='https://www.simscale.com/docs/simulation-setup/meshing/tet-dominant/#local-element-size' target='_blank'><b>local element size</b></a> allows the definition of local mesh sizings on particular faces or solids. This can be used to increase the mesh efficiency by using smaller elements only where needed, for example on contact surfaces, fillets or other regions with potentially large stress gradients.</p><p><img src=\"/spec/resources/help/imgs/local_element_size.png\" class=\"helpPopupImage\"/> The figure shows a mesh of a bolted connection with local refinements on the contact surfaces.</p>\n\nSchema name: SubmeshRefinement",
            "default" : "SUBMESH"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Local element size"
          },
          "sizing" : {
            "$ref" : "#/components/schemas/OneOf_SubmeshRefinementSizing"
          },
          "allowQuadrangles" : {
            "title" : "Allow quadrangles",
            "type" : "boolean",
            "description" : "<p>This parameter determines if <a href='https://www.simscale.com/docs/simulation-setup/meshing/tet-dominant/#quadrangles' target='_blank'><b>quadrangular surface elements</b></a> shall be allowed. When disabled, only triangles will be used. Meshing with triangles only is usually more robust while quadrangular elements may lead to better results.</p><p><img src=\"/spec/resources/help/imgs/allow_quads_comparison.png\" class=\"helpPopupImage\"/> The figure shows sample meshes with quadrangular surface elements disallowed (left) and allowed (right).</p>",
            "default" : false
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>The refinement type <a href='https://www.simscale.com/docs/simulation-setup/meshing/tet-dominant/#local-element-size' target='_blank'><b>local element size</b></a> allows the definition of local mesh sizings on particular faces or solids. This can be used to increase the mesh efficiency by using smaller elements only where needed, for example on contact surfaces, fillets or other regions with potentially large stress gradients.</p><p><img src=\"/spec/resources/help/imgs/local_element_size.png\" class=\"helpPopupImage\"/> The figure shows a mesh of a bolted connection with local refinements on the contact surfaces.</p>"
      },
      "HexDominantSnappy" : {
        "title" : "Hex-dominant",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: HexDominantSnappy",
            "default" : "HEX_DOMINANT_SNAPPY_V5"
          },
          "meshingMode" : {
            "title" : "Meshing mode",
            "type" : "string",
            "description" : "<p>The <a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#meshing-mode' target='_blank'>meshing mode</a> defines how the mesher should generate the mesh.</p><ul><li>The <b>Internal</b> mode will create the mesh <u>inside</u> of the geometry body. If the CAD consists of multiple solids, the mesher will attempt to create a multiregion mesh which is suitable for conjugate heat transfer analyses. Use this mode if the CAD model already represents the final fluid domain.</li><li><b>External</b> meshing will create the mesh <u>outside</u> of the bodies. The absolute dimensions of the mesh are determined by the <i>Background Mesh Box</i>. Use this mode in case you want to extract the fluid domain around your model.</li><li>The option <b>Material point</b> allows you to define a point inside the domain where the mesh will be placed. It can be used to select which part (or enclosed volume) of the model or should be meshed. The mesh will surround the material point and extend until the boundaries of the body. The location of the material point is defined by the <i>Material Point</i> geometry primitive.</li></ul>",
            "default" : "INTERNAL",
            "enum" : [ "INTERNAL" ]
          },
          "sizing" : {
            "$ref" : "#/components/schemas/OneOf_HexDominantSnappySizing"
          },
          "physicsBasedMeshing" : {
            "title" : "Automatic boundary layers",
            "type" : "boolean",
            "description" : "Physics-based meshing takes setup information like materials, boundary conditions, and source terms into account to size the mesh accordingly. When enabled, the following adaptations will be made:</p><ul><li>Refinements on inlets and outlets</li><li>Different sizing for solid and fluid regions in CHT simulations</li></ul> <br>When toggled on users dont have to worry about creating a <a href='https://www.simscale.com/docs/simulation-setup/simulation-control/' target='_blank'>separate cell zone</a>.",
            "default" : true,
            "x-showWhen" : [ "meshingMode == INTERNAL" ]
          },
          "numOfProcessors" : {
            "title" : "Number of processors",
            "type" : "integer",
            "description" : "<p>Selecting more processor cores might speed up the meshing process. Choosing a smaller computation instance will save core hours. <a href='https://www.simscale.com/docs/simulation-setup/meshing/#number-of-processors' target='_blank'>Learn more</a>.</p>",
            "format" : "int64",
            "default" : -1,
            "enum" : [ -1, 4, 8, 16, 32, 64, 96 ]
          },
          "refinements" : {
            "title" : "Refinements",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_HexDominantSnappyRefinements"
            }
          }
        },
        "additionalProperties" : false
      },
      "AutomaticMeshSizingHexDominantSnappy" : {
        "title" : "Automatic mesh sizing",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AutomaticMeshSizingHexDominantSnappy",
            "default" : "AUTOMATIC"
          },
          "fineness" : {
            "title" : "Fineness",
            "type" : "string",
            "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/#local-mesh-refinements' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>",
            "default" : "COARSE",
            "enum" : [ "VERY_COARSE", "COARSE", "MODERATE", "FINE", "VERY_FINE" ]
          }
        },
        "additionalProperties" : false
      },
      "ManualMeshSizingHexDominantSnappy" : {
        "title" : "Manual mesh sizing",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ManualMeshSizingHexDominantSnappy",
            "default" : "MANUAL"
          },
          "minimumEdgeLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "maximumEdgeLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "SurfaceRefinementHexDominantSnappy" : {
        "title" : "Surface refinement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "A <a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#surface-refinement' target='_blank'><b>surface refinement</b></a> can be used to refine the mesh near the surfaces of assigned faces and/or solids. A surface refinement can also be used to create a <u>cell zone</u>.\n\nSchema name: SurfaceRefinementHexDominantSnappy",
            "default" : "SURFACE_HEX_DOMINANT_SNAPPY_V3"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Surface refinement"
          },
          "minLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "maxLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "cellZone" : {
            "$ref" : "#/components/schemas/OneOf_SurfaceRefinementHexDominantSnappyCellZone"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "A <a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#surface-refinement' target='_blank'><b>surface refinement</b></a> can be used to refine the mesh near the surfaces of assigned faces and/or solids. A surface refinement can also be used to create a <u>cell zone</u>."
      },
      "WithoutCellZone" : {
        "title" : "Without cell zone",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WithoutCellZone",
            "default" : "WITHOUT_CELL_ZONE"
          }
        },
        "additionalProperties" : false
      },
      "WithCellZone" : {
        "title" : "With cell zone",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WithCellZone",
            "default" : "WITH_CELL_ZONE_V11"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Zone"
          }
        },
        "additionalProperties" : false
      },
      "FeatureRefinementHexDominantSnappy" : {
        "title" : "Feature refinement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "A <a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#feature-refinement' target='_blank'><b>feature refinement</b></a> can be used to refine the geometrys feature edges. All edges whose adjacent surface normals form an angle of less than 150 will be refined.\n\nSchema name: FeatureRefinementHexDominantSnappy",
            "default" : "FEATURE_HEX_DOMINANT_SNAPPY"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Feature refinement"
          },
          "distanceRefinementLengths" : {
            "title" : "Distance refinement lengths",
            "type" : "array",
            "description" : "Specify the desired <b>target cell edge length</b> based on the <b>distance</b> to the feature edges. The edge and surface mesh will then be refined up until the specified distance in all directions from the edges.",
            "items" : {
              "$ref" : "#/components/schemas/RefinementLength"
            },
            "default" : [ {
              "distance" : {
                "value" : 1,
                "unit" : "m"
              },
              "length" : {
                "value" : 1,
                "unit" : "m"
              }
            } ]
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "A <a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#feature-refinement' target='_blank'><b>feature refinement</b></a> can be used to refine the geometrys feature edges. All edges whose adjacent surface normals form an angle of less than 150 will be refined."
      },
      "LayerAdditionHexDominantSnappy" : {
        "title" : "Inflate boundary layer",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#layers-refinement' target='_blank'><b>Inflated boundary layers</b></a> are used to resolve the boundary layer near walls (no-slip) which are in contact with the fluid. Using boundary layers is generally recommended for turbulent simulations.\n\nSchema name: LayerAdditionHexDominantSnappy",
            "default" : "LAYER_ADDITION_HEX_DOMINANT_SNAPPY"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Inflate boundary layer"
          },
          "layers" : {
            "title" : "Layers",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "The number of <b>layers</b> defines how many boundary layers should be created.",
            "default" : 5
          },
          "expansionRatio" : {
            "title" : "Expansion ratio",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>The <b>Expansion ratio</b> determines how the boundary layers grow in thickness from the wall to the internal mesh. The larger the ratio, the larger each cell layer will be in comparison to the neighbouring layer closer to the wall.</p><p><img src=\"/spec/resources/help/imgs/shm_bl_expansion-ratio.png\" class=\"helpPopupImage\"/> The figure shows a ratio of 1.3.</p>",
            "default" : 1.3
          },
          "minThickness" : {
            "title" : "Min thickness",
            "maximum" : 2,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "Specifies the <b>overall minimum thickness of all layers combined</b>. In case the overall thickness falls below this minimum thickness, no layers will be added for the affected areas.",
            "default" : 0
          },
          "firstLayerThickness" : {
            "title" : "Surface layer relative thickness",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "Specifies the height (thickness) of the <b>first layer</b> that is closest to the surface. The first layer thickness is specified <b>relative</b> to the neighboring volume cell size after refinements.",
            "default" : 0.055
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#layers-refinement' target='_blank'><b>Inflated boundary layers</b></a> are used to resolve the boundary layer near walls (no-slip) which are in contact with the fluid. Using boundary layers is generally recommended for turbulent simulations."
      },
      "Resolution" : {
        "required" : [ "x", "y", "z" ],
        "type" : "object",
        "properties" : {
          "x" : {
            "title" : "X",
            "type" : "integer",
            "description" : "<p>Specify the number of cells in x direction for the <a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/main-settings-for-hex-dominant-parametric/#main-properties' target='_blank'>base mesh</a>.</p>"
          },
          "y" : {
            "title" : "Y",
            "type" : "integer",
            "description" : "<p>Specify the number of cells in y direction for the <a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/main-settings-for-hex-dominant-parametric/#main-properties' target='_blank'>base mesh</a>.</p>"
          },
          "z" : {
            "title" : "Z",
            "type" : "integer",
            "description" : "<p><p>Specify the number of cells in z direction for the <a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/main-settings-for-hex-dominant-parametric/#main-properties' target='_blank'>base mesh</a>.</p>"
          }
        },
        "additionalProperties" : false
      },
      "CastellatedMeshControls" : {
        "type" : "object",
        "properties" : {
          "maxLocalCells" : {
            "title" : "Max local cells",
            "maximum" : 2000000000,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the maximal number of cells per processor during refinement</p>",
            "default" : 40000000
          },
          "maxGlobalCells" : {
            "title" : "Max global cells",
            "maximum" : 2000000000,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the maximum possible number of cells summed upon all processors. Note that this is before the castellation step (see documentation, so the actual number of cells after castellation might be considerably less.</p>",
            "default" : 100000000
          },
          "minRefinementCells" : {
            "title" : "Min refinement cells",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>If in a refinement iteration the number of cells selected for refinement is under this value, the refinement stops. Provide a small value to ensure that all surfaces are refined to the proper level.</p>",
            "default" : 1
          },
          "maxLoadUnbalance" : {
            "title" : "Max load unbalance",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Define a fraction indicating the maximum allowable load imbalance between processors working on this job. A value of 0 will force rebalancing for even a slight imbalance.</p>",
            "default" : 0.2
          },
          "cellsBetweenLevels" : {
            "title" : "Cells between levels",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>This parameter specifies the number of layers of cells between different levels of refinement (see documentation).</p>",
            "default" : 3
          },
          "resolveFeatureAngle" : {
            "title" : "Resolve feature angle",
            "maximum" : 180,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Cells that face multiple intersections with an intersection angle greater than this angle will be refined to the max level. Use this parameter to resolve sharp features to the maximum level of surface refinement specified (see documentation).</p>",
            "default" : 30
          },
          "allowFreeStandingZoneFaces" : {
            "title" : "Allow free standing zone faces",
            "type" : "boolean",
            "description" : "<p>Decide whether you want to allow zone faces that share the same owner and neighbour cell zone. Allowing this can lead to problem when zone faces are snapped to features. This parameter is ignored when no faceZones are present.</p>",
            "default" : false
          }
        },
        "additionalProperties" : false
      },
      "SnapControls" : {
        "type" : "object",
        "properties" : {
          "meshToGeometryConformationIterations" : {
            "title" : "Mesh to geometry conformation iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the max number of iterations to ensure that the mesh conforms to the geometry. Higher values lead to a better conforming mesh.</p>",
            "default" : 5
          },
          "tolerance" : {
            "title" : "Tolerance",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>This parameter describes a distance (relative to the local maximum mesh edge length) within which the algorithm looks for a geometry point to snap the mesh to. Higher values lead to better snapping but are costlier.</p>",
            "default" : 2
          },
          "solverIterations" : {
            "title" : "Solver iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>This parameter defines the number of displacement relaxation iterations during the meshing process. Higher values lead to enhanced mesh quality but increase the computing time.</p>",
            "default" : 150
          },
          "relaxIterations" : {
            "title" : "Relax iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>This parameter defines the max number of iterations to remove bad mesh points (see documentation).</p>",
            "default" : 8
          },
          "maxMexConformationIterations" : {
            "title" : "Max mesh conformation iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>This parameter defines the max number of iterations done to ensure that the mesh conforms to the geometry.</p>",
            "default" : 10
          },
          "implicitFeatureSnap" : {
            "title" : "Implicit feature snap",
            "type" : "boolean",
            "description" : "<p>Activating this makes the snapping algorithm detecting geometrical features by sampling the surface. This might be time-consuming. The other option is to create a feature refinement which also enables feature snapping.</p>",
            "default" : true
          },
          "explicitFeatureSnap" : {
            "title" : "Explicit feature snap",
            "type" : "boolean",
            "description" : "<p>Use the explicitly given feature refinements for feature snapping. An explicit feature refinement can be added under 'Mesh refinement'. Specifying a feature refinement results in sharp mesh edges even with a refinement level of zero.</p>",
            "default" : false
          },
          "detectFeaturesBetweenMultipleSurfaces" : {
            "title" : "Detect features between multiple surfaces",
            "type" : "boolean",
            "description" : "<p>Also detect features between multiple surfaces. This is relevant when you want to create a mesh with multiple regions - used for example in the conjugate heat transfer solver. Needs 'Use feature refinement for snapping' turned on!</p>",
            "default" : true
          }
        },
        "additionalProperties" : false
      },
      "LayerAddingControls" : {
        "type" : "object",
        "properties" : {
          "relativeSize" : {
            "title" : "Layer size",
            "type" : "boolean",
            "description" : "<p>If turned on, the length parameters for layer refinements (e.g. 'Thickness of the final layer', 'Minimum overall layer thickness') are multiplied by the local cell size outside that layer. Else, they are used as absolute lengths.</p>",
            "default" : true
          },
          "maxCancelledLayersNearSharpFeatures" : {
            "title" : "Max cancelled layers near sharp features",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>If the algorithm faces difficulty generating layers, this is the maximum number of layers that are NOT generated in that region. Such cases might occur near sharp features. Set to 0 to force layer generation for all cases.</p>",
            "default" : 0
          },
          "featureAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "slipFeatureAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "relaxIterations" : {
            "title" : "Relax iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Specify the maximum number of relaxation iterations for the snapping process for layers.</p>",
            "default" : 8
          },
          "surfaceNormalsMaxSmoothingIterations" : {
            "title" : "Surface normals max smoothing iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Specify the maximum number of smoothing iterations for the surface normals.</p>",
            "default" : 2
          },
          "internalMeshMaxSmoothingIterations" : {
            "title" : "Internal mesh max smoothing iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Specify the number of smoothing iterations for the interior mesh movement. This movement occurs in order to make space for layers.</p>",
            "default" : 5
          },
          "layerThicknessMaxSmoothingIterations" : {
            "title" : "Layer thickness max smoothing iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>This specifies the number of iterations for smoothing of the overall layer thickness over different surface patches.</p>",
            "default" : 10
          },
          "maxFaceThicknessRatio" : {
            "title" : "Max face thickness ratio",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Specify the maximum allowable face aspect ratio beyond which layers will not be added.</p>",
            "default" : 0.5
          },
          "maxThicknessToMedialRatio" : {
            "title" : "Max thickness to medial ratio",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>The medial length is a measure of the aspect ratio for a non-quadrilateral face. This parameter prevents layer addition for non-quad faces that are highly anisotropic.</p>",
            "default" : 0.3
          },
          "minMedianAxisAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "bufferCellsNoExtrude" : {
            "title" : "Buffer cells between refinement levels",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>This parameter specifies the number of buffer cells to be extruded at cell-faces where layers terminate. Set to < 0 to disable.</p>",
            "default" : 0
          },
          "layerAdditionMaxIterations" : {
            "title" : "Layer addition max iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Specify the overall layer addition iteration number. The algorithm will abort definitely as soon as this number is reached. In this case, the mesh might be illegal.</p>",
            "default" : 50
          },
          "maxIterationsWithStrictQualityControls" : {
            "title" : "Max iterations with strict quality controls",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>This parameter specifies the maximum number of layer iterations that are done with the mesh quality controls. On exceeding these, the algorithm switches to less strict controls specified in the 'relaxed' category.</p>",
            "default" : 20
          }
        },
        "additionalProperties" : false
      },
      "MeshQualityControls" : {
        "type" : "object",
        "properties" : {
          "maxNonOrthogonality" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "maxBoundarySkewness" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "maxInternalSkewness" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "maxConcaveness" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "minVolume" : {
            "$ref" : "#/components/schemas/Dimensional_Volume"
          },
          "minTetQuality" : {
            "title" : "Min tet quality",
            "type" : "number",
            "description" : "<p>Define a minimum tetrahedron quality for cells (see documentation). Choose a low negative number to disable this check, e.g. -1e30.</p>",
            "default" : -1000000000000000000000000000000
          },
          "minFaceArea" : {
            "$ref" : "#/components/schemas/Dimensional_Area"
          },
          "minFaceTwist" : {
            "title" : "Min face twist",
            "type" : "number",
            "description" : "<p>Define the minimum cosine of face twist allowed (see documentation). Set to a value smaller than -1 to disable. The value results from the dot product of the face normal and the face centre triangles normal.</p>",
            "default" : 0.01
          },
          "minDeterminant" : {
            "title" : "Min determinant",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Define the minimum normalised cell determinant. Choose a value between 0 and 1. Hex corresponds to 1.</p>",
            "default" : 0.001
          },
          "minFaceWeight" : {
            "title" : "Min face weight",
            "maximum" : 0.5,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>The face weight specifies the distribution of a face's contribution to its two neighbouring cells. A very small face weight would mean that the neighbouring cells are disproportionately different in size. Choose a value between 0 and 0.5. 0.5 refers to a face with neighbouring cells of the same size.</p>",
            "default" : 0.02
          },
          "minVolumeRatio" : {
            "title" : "Min volume ratio",
            "type" : "number",
            "description" : "<p>This parameter specifies the minimum allowed volume ratio between two adjacent cells. Choose a value between 0 and 1. 1 means that the neighbouring cells have the same volume.</p>",
            "default" : 0.01
          },
          "minTriangleTwist" : {
            "title" : "Min triangle twist",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "type" : "number",
            "description" : "<p>Same as Min Face Twist, but for adjacent triangular faces (see documentation). Choose a value below -1 to disable this feature.</p>",
            "default" : -1
          },
          "errorDistributionIterations" : {
            "title" : "Error distribution iterations",
            "type" : "integer",
            "description" : "<p>Define the number of error distribution iterations.</p>",
            "default" : 4
          },
          "errorReduction" : {
            "title" : "Error reduction",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>This parameter specifies how much the displacement is scaled at error locations.</p>",
            "default" : 0.75
          },
          "relaxedMaxNonOrthogonality" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "mergeTolerance" : {
            "title" : "Merge tolerance",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>This parameters specifies the accuracy of face merging as a fraction of the initial bounding box.</p>",
            "default" : 1.0E-6
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_Volume" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m", "in" ]
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_Area" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m", "in" ]
          }
        },
        "additionalProperties" : false
      },
      "BoundingBoxLayerAddition" : {
        "title" : "Bounding box layer addition",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This option enables layer refinement on the faces of the bounding box. This refinement is useful if the bounding box itself provides walls of the flow domain. It is often used for external aerodynamic cases where the floor is considered as a wall and hence the mesh should be refined with layers in the vicinity.\n\nSchema name: BoundingBoxLayerAddition",
            "default" : "BOUNDING_BOX_LAYER_ADDITION"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Bounding box layer addition"
          },
          "face" : {
            "title" : "Face",
            "type" : "string",
            "description" : "This option selects the face of the bounding box on which layers will be added. A face is selected by its normal (denoted by the respective coordinate system axis) and its position (denoted by min or max).",
            "default" : "XMIN",
            "enum" : [ "XMIN", "XMAX", "YMIN", "YMAX", "ZMIN", "ZMAX" ]
          },
          "layers" : {
            "title" : "Layers",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "The number of <b>layers</b> defines how many boundary layers should be created.",
            "default" : 5
          },
          "expansionRatio" : {
            "title" : "Expansion ratio",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>The <b>Expansion ratio</b> determines how the boundary layers grow in thickness from the wall to the internal mesh. The larger the ratio, the larger each cell layer will be in comparison to the neighbouring layer closer to the wall.</p><p><img src=\"/spec/resources/help/imgs/shm_bl_expansion-ratio.png\" class=\"helpPopupImage\"/> The figure shows a ratio of 1.3.</p>",
            "default" : 1.3
          },
          "minThickness" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "finalThickness" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false,
        "description" : "This option enables layer refinement on the faces of the bounding box. This refinement is useful if the bounding box itself provides walls of the flow domain. It is often used for external aerodynamic cases where the floor is considered as a wall and hence the mesh should be refined with layers in the vicinity."
      },
      "FeatureRefinement" : {
        "title" : "Feature refinement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "A <a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#feature-refinement' target='_blank'><b>feature refinement</b></a> can be used to refine the geometrys feature edges. All edges whose adjacent surface normals form an angle of less than 150 will be refined.\n\nSchema name: FeatureRefinement",
            "default" : "FEATURE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Feature refinement"
          },
          "includedAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "distanceRefinementLevels" : {
            "title" : "Distance refinement levels",
            "type" : "array",
            "description" : "<p>This dynamic table allows you to add refinements to the mesh associated with the features (e.g. edges) in a specific distance to the features. Therefore specify the distance in the left box and the associated refinement level on the right (the higher, the finer). The pair (0,0) would mean that a refinement with level 0 would be introduced directly at the features of the mesh.</p>",
            "items" : {
              "$ref" : "#/components/schemas/RefinementLevel"
            },
            "default" : [ {
              "distance" : {
                "value" : 1,
                "unit" : "m"
              },
              "level" : 1
            } ]
          }
        },
        "additionalProperties" : false,
        "description" : "A <a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#feature-refinement' target='_blank'><b>feature refinement</b></a> can be used to refine the geometrys feature edges. All edges whose adjacent surface normals form an angle of less than 150 will be refined."
      },
      "RefinementLevel" : {
        "type" : "object",
        "properties" : {
          "distance" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "level" : {
            "title" : "Level",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 1
          }
        },
        "additionalProperties" : false
      },
      "LayerAddition" : {
        "title" : "Inflate boundary layer",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#layers-refinement' target='_blank'><b>Inflated boundary layers</b></a> are used to resolve the boundary layer near walls (no-slip) which are in contact with the fluid. Using boundary layers is generally recommended for turbulent simulations.\n\nSchema name: LayerAddition",
            "default" : "LAYER_ADDITION"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Inflate boundary layer"
          },
          "layers" : {
            "title" : "Layers",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "The number of <b>layers</b> defines how many boundary layers should be created.",
            "default" : 5
          },
          "expansionRatio" : {
            "title" : "Expansion ratio",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>The <b>Expansion ratio</b> determines how the boundary layers grow in thickness from the wall to the internal mesh. The larger the ratio, the larger each cell layer will be in comparison to the neighbouring layer closer to the wall.</p><p><img src=\"/spec/resources/help/imgs/shm_bl_expansion-ratio.png\" class=\"helpPopupImage\"/> The figure shows a ratio of 1.3.</p>",
            "default" : 1.3
          },
          "minThickness" : {
            "title" : "Min thickness",
            "maximum" : 2,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>This is the overall minimum thickness of all added layers. If for any case the overall layer thickness is smaller than this value, the layer addition process is stopped and no layers are added. In case the 'Use relative size for layers?' option in the global settings is set to 'true', this thickness is relative to the undistorted size of the cells in the internal mesh directly next to the boundary layer.</p>",
            "default" : 0.01
          },
          "finalLayerThickness" : {
            "title" : "Final layer thickness",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Specify the desired final layer thickness farthest away from the wall on which the boundary layer is grown. If the 'Layer Size' toggle in the hex-parametric global settings is turned on, this thickness is relative to the undistorted size of the cells in the internal mesh directly next to the boundary layer.</p>",
            "default" : 0.3
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#layers-refinement' target='_blank'><b>Inflated boundary layers</b></a> are used to resolve the boundary layer near walls (no-slip) which are in contact with the fluid. Using boundary layers is generally recommended for turbulent simulations."
      },
      "RegionRefinementWithLevels" : {
        "title" : "Region refinement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "A <a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#region-refinement' target='_blank'><b>region refinement</b></a> can be used to refine the mesh in a given area. The refinement area needs to be defined either via a geometry primitive or an existing solid (Hex-dominant only).\n\nSchema name: RegionRefinementWithLevels",
            "default" : "REGION_LEVELS"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Region refinement"
          },
          "refinement" : {
            "$ref" : "#/components/schemas/OneOf_RegionRefinementWithLevelsRefinement"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE" ]
            }
          }
        },
        "additionalProperties" : false,
        "description" : "A <a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#region-refinement' target='_blank'><b>region refinement</b></a> can be used to refine the mesh in a given area. The refinement area needs to be defined either via a geometry primitive or an existing solid (Hex-dominant only)."
      },
      "InsideRegionRefinementWithLevels" : {
        "title" : "Inside",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: InsideRegionRefinementWithLevels",
            "default" : "INSIDE"
          },
          "level" : {
            "title" : "Level",
            "type" : "integer",
            "default" : 1
          }
        },
        "additionalProperties" : false
      },
      "DistanceRegionRefinementWithLevels" : {
        "title" : "Distance",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: DistanceRegionRefinementWithLevels",
            "default" : "DISTANCE"
          },
          "distanceRefinementLevels" : {
            "title" : "Distance refinement levels",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RefinementLevel"
            },
            "default" : [ {
              "distance" : {
                "value" : 1,
                "unit" : "m"
              },
              "level" : 1
            } ]
          }
        },
        "additionalProperties" : false
      },
      "OutsideRegionRefinementWithLevels" : {
        "title" : "Outside",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: OutsideRegionRefinementWithLevels",
            "default" : "OUTSIDE"
          },
          "level" : {
            "title" : "Level",
            "type" : "integer",
            "default" : 1
          }
        },
        "additionalProperties" : false
      },
      "SurfaceRefinement" : {
        "title" : "Surface refinement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "A <a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#surface-refinement' target='_blank'><b>surface refinement</b></a> can be used to refine the mesh near the surfaces of assigned faces and/or solids. A surface refinement can also be used to create a <u>cell zone</u>.\n\nSchema name: SurfaceRefinement",
            "default" : "SURFACE_V3"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Surface refinement"
          },
          "minLevel" : {
            "title" : "Min level",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Specify surface-wise the minimum refinement level for this surface.</p>",
            "default" : 1
          },
          "maxLevel" : {
            "title" : "Max level",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Specify surface-wise the maximum refinement level for this surface.</p>",
            "default" : 2
          },
          "cellZone" : {
            "$ref" : "#/components/schemas/OneOf_SurfaceRefinementCellZone"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "A <a href='https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#surface-refinement' target='_blank'><b>surface refinement</b></a> can be used to refine the mesh near the surfaces of assigned faces and/or solids. A surface refinement can also be used to create a <u>cell zone</u>."
      },
      "DebugMeshSizingSimmetrix" : {
        "title" : "Debug",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: DebugMeshSizingSimmetrix",
            "default" : "DEBUG"
          },
          "maximumEdgeLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "minimumEdgeLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "chordalError" : {
            "title" : "Chordal error",
            "maximum" : 0.5,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.4
          },
          "minCurvRef" : {
            "title" : "Min curv ref",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0
          },
          "gradationRate" : {
            "title" : "Gradation rate",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.66
          },
          "proxRefFactor" : {
            "title" : "Prox ref factor",
            "maximum" : 4,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0
          },
          "minProxSize" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "smallFeatureTol" : {
            "title" : "Small feature tol",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0
          },
          "layerAdjustmentBehaviour" : {
            "title" : "Layer adjustment behaviour",
            "type" : "string",
            "default" : "SHRINKING",
            "enum" : [ "SHRINKING", "TRIMMING" ]
          },
          "layerHeightGradationRate" : {
            "title" : "Layer height gradation rate",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.66
          },
          "surfSkewness" : {
            "title" : "Surf skewness",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.7
          },
          "volLenRatio" : {
            "title" : "Vol len ratio",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.15
          }
        },
        "additionalProperties" : false
      },
      "OneOf_RegionRefinementWithLevelsRefinement" : {
        "title" : "Refinement mode",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "INSIDE" : "#/components/schemas/InsideRegionRefinementWithLevels",
            "DISTANCE" : "#/components/schemas/DistanceRegionRefinementWithLevels",
            "OUTSIDE" : "#/components/schemas/OutsideRegionRefinementWithLevels"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/InsideRegionRefinementWithLevels"
        }, {
          "$ref" : "#/components/schemas/DistanceRegionRefinementWithLevels"
        }, {
          "$ref" : "#/components/schemas/OutsideRegionRefinementWithLevels"
        } ]
      },
      "OneOf_SubmeshRefinementSizing" : {
        "title" : "Sizing",
        "description" : "<p>Choose how your mesh element sizes should be defined:</p><ul><li><p>If you select the <b>automatic</b> sizing, you can specify how fine your mesh should be (ranging from <i>1 - very coarse</i> to <i>5 - very fine</i>) and all additional parameters will be set automatically according to the chosen fineness and the geometry features.</ul></p><ul><li><p>For full control over the mesh sizing, select the <b>manual</b> option. Here you can in addition to the <i>minimum edge length</i> and <i>maximum edge length</i> define the <i>mesh grading</i> in a very detailed manner.</ul></p><p><img src=\"/spec/resources/help/imgs/mesh_fineness_comparison.png\" class=\"helpPopupImage\"/> The figure shows meshes for fineness <i>1 - very coarse</i> (left) and <i>5 - very fine</i> (right).</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC" : "#/components/schemas/AutomaticMeshSizing",
            "MANUAL" : "#/components/schemas/ManualMeshSizing"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutomaticMeshSizing"
        }, {
          "$ref" : "#/components/schemas/ManualMeshSizing"
        } ]
      },
      "OneOf_SimmetrixMeshingFluidSizing" : {
        "title" : "Sizing",
        "description" : "<p>Define how to control the overall <a href='https://www.simscale.com/docs/simulation-setup/meshing/standard/#sizing-and-fineness' target='_blank'><b>mesh sizing</b></a>:</p><ul> <li><p><b>Automatic:</b> Element sizing is controlled by <b>automatic fineness levels</b> that take the geometrical properties into account.</p></li> <li><p><b>Manual:</b> Element sizing is controlled by <b>maximum and minimum edge length</b>.</p></li></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC_V9" : "#/components/schemas/AutomaticMeshSizingSimmetrix",
            "MANUAL" : "#/components/schemas/ManualMeshSizingSimmetrix"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutomaticMeshSizingSimmetrix"
        }, {
          "$ref" : "#/components/schemas/ManualMeshSizingSimmetrix"
        } ]
      },
      "OneOf_SimmetrixMeshingFluidRefinements" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "REGION_LENGTH" : "#/components/schemas/RegionRefinementWithLength",
            "SIMMETRIX_LOCAL_SIZING_V10" : "#/components/schemas/SimmetrixLocalSizingRefinement",
            "SIMMETRIX_BOUNDARY_LAYER_V13" : "#/components/schemas/SimmetrixBoundaryLayerRefinement"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/RegionRefinementWithLength"
        }, {
          "$ref" : "#/components/schemas/SimmetrixLocalSizingRefinement"
        }, {
          "$ref" : "#/components/schemas/SimmetrixBoundaryLayerRefinement"
        } ]
      },
      "OneOf_SimmetrixMeshingFluidAutomaticLayerSettings" : {
        "title" : "Automatic boundary layers",
        "description" : "This toggle enables the automatic creation of boundary layers at no-slip walls. When toggled on, the meshing is started together with the simulation run.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC_LAYER_ON" : "#/components/schemas/AutomaticLayerOn",
            "AUTOMATIC_LAYER_OFF" : "#/components/schemas/AutomaticLayerOff"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutomaticLayerOn"
        }, {
          "$ref" : "#/components/schemas/AutomaticLayerOff"
        } ],
        "x-subtypeBooleanChooser" : {
          "trueOption" : "AUTOMATIC_LAYER_ON",
          "falseOption" : "AUTOMATIC_LAYER_OFF"
        }
      },
      "OneOf_RegionRefinementWithLengthRefinement" : {
        "title" : "Refinement mode",
        "description" : "<p>Choose between the following refinement modes:</p><ul><li><b>Inside:</b> Refines all volume mesh cells inside the selected volumes up to the specified cell edge length.</li><li><b>Outside:</b> Refines the mesh cells outside of the specified area up to the specified cell edge length.</li><li><b>Distance:</b> Refines mesh cells according to the distance to the surface of the assigned volume(s). The <i>Distance</i> mode can accommodate different refinement levels at multiple distances.</li></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "INSIDE" : "#/components/schemas/InsideRegionRefinementWithLength",
            "DISTANCE" : "#/components/schemas/DistanceRegionRefinementWithLength",
            "OUTSIDE" : "#/components/schemas/OutsideRegionRefinementWithLength"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/InsideRegionRefinementWithLength"
        }, {
          "$ref" : "#/components/schemas/DistanceRegionRefinementWithLength"
        }, {
          "$ref" : "#/components/schemas/OutsideRegionRefinementWithLength"
        } ]
      },
      "OneOf_SimmetrixBoundaryLayerRefinementLayerType" : {
        "title" : "Layer gradation control",
        "description" : "<p>Define how the layers should be distributed within the overall layer thickness:</p><ul><li><p><b>Specify growth rate</b>: Define the growth rate between adjacent layers. </p></li> <li><p><b>Specify first layer thickness:</b> Define the absolute thickness of the first layer. The remaining layers are distributed automatically. Choose this option for example to strictly control the y+ value. </p></li></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FRACTIONAL_HEIGHT_1" : "#/components/schemas/FractionalHeight1",
            "FRACTIONAL_HEIGHT_2" : "#/components/schemas/FractionalHeight2"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FractionalHeight1"
        }, {
          "$ref" : "#/components/schemas/FractionalHeight2"
        } ]
      },
      "OneOf_SimmetrixMeshingSolidSizing" : {
        "title" : "Sizing",
        "description" : "<p>Define how to control the overall <a href='https://www.simscale.com/docs/simulation-setup/meshing/standard/#sizing-and-fineness' target='_blank'><b>mesh sizing</b></a>:</p><ul> <li><p><b>Automatic:</b> Element sizing is controlled by <b>automatic fineness levels</b> that take the geometrical properties into account.</p></li> <li><p><b>Manual:</b> Element sizing is controlled by <b>maximum and minimum edge length</b>.</p></li></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC_V9" : "#/components/schemas/AutomaticMeshSizingSimmetrix",
            "MANUAL" : "#/components/schemas/ManualMeshSizingSimmetrix"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutomaticMeshSizingSimmetrix"
        }, {
          "$ref" : "#/components/schemas/ManualMeshSizingSimmetrix"
        } ]
      },
      "OneOf_SimmetrixMeshingSolidRefinements" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "REGION_LENGTH" : "#/components/schemas/RegionRefinementWithLength",
            "SIMMETRIX_LOCAL_SIZING_V10" : "#/components/schemas/SimmetrixLocalSizingRefinement",
            "SIMMETRIX_BOUNDARY_LAYER_V13" : "#/components/schemas/SimmetrixBoundaryLayerRefinement"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/RegionRefinementWithLength"
        }, {
          "$ref" : "#/components/schemas/SimmetrixLocalSizingRefinement"
        }, {
          "$ref" : "#/components/schemas/SimmetrixBoundaryLayerRefinement"
        } ]
      },
      "OneOf_ManualMeshSizingGrading" : {
        "title" : "Grading",
        "description" : "<p>The <b><a href='https://www.simscale.com/docs/simulation-setup/meshing/tet-dominant/#grading' target='_blank'>mesh grading</a></b> specifies how fine details of the geometry are resolved and also influences the quality of the resulting elements.</p><ul><li><p>If you select the <b>automatic</b> grading, you can specify how fine your mesh should be (ranging from <i>1 - very coarse</i> to <i>5 - very fine</i>) and all additional parameters will be set automatically.</li><li><p>For full control over the underlying parameters <i>number of segements per edge</i>, <i>number of segements per radius</i> and <i>growth rate</i> you can choose the <b>manual</b> mesh grading option.</p></li></ul><p><img src=\"/spec/resources/help/imgs/mesh_grading_comparison.png\" class=\"helpPopupImage\"/> The figure shows meshes for grading <i>1 - very coarse</i> (left) and <i>5 - very fine</i> (right).</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC" : "#/components/schemas/AutomaticMeshGrading",
            "MANUAL" : "#/components/schemas/ManualMeshGrading"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutomaticMeshGrading"
        }, {
          "$ref" : "#/components/schemas/ManualMeshGrading"
        } ]
      },
      "OneOf_SurfaceRefinementCellZone" : {
        "title" : "Cell zone",
        "description" : "<p>You can create cell zones in your mesh by assigning this option to one or more of your CAD bodies. They can be later defined as Rotating Zones or Porosity Volumes, among others. Check these options under Advanced Concepts in the simulation tree.<p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "WITHOUT_CELL_ZONE" : "#/components/schemas/WithoutCellZone",
            "WITH_CELL_ZONE_V11" : "#/components/schemas/WithCellZone"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/WithoutCellZone"
        }, {
          "$ref" : "#/components/schemas/WithCellZone"
        } ]
      },
      "OneOf_AutomaticLayerOnLayerType" : {
        "title" : "Layer gradation control",
        "description" : "<p>Define how the layers should be distributed within the overall layer thickness:</p><ul><li><p><b>Specify growth rate</b>: Define the growth rate between adjacent layers. </p></li> <li><p><b>Specify first layer thickness:</b> Define the absolute thickness of the first layer. The remaining layers are distributed automatically. Choose this option for example to strictly control the y+ value. </p></li></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FRACTIONAL_HEIGHT_1" : "#/components/schemas/FractionalHeight1",
            "FRACTIONAL_HEIGHT_2" : "#/components/schemas/FractionalHeight2"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FractionalHeight1"
        }, {
          "$ref" : "#/components/schemas/FractionalHeight2"
        } ]
      },
      "OneOf_HexDominantSnappySizing" : {
        "title" : "Sizing",
        "description" : "<p>Choose how your mesh element sizes should be defined:</p><ul><li><p>If you select the <b>automatic</b> sizing, you can specify how fine your mesh should be (ranging from <i>1 - very coarse</i> to <i>5 - very fine</i>) and all additional parameters will be set automatically according to the chosen fineness and the geometry features.</ul></p><ul><li><p>For full control over the mesh sizing, select the <b>manual</b> option. Here you can in addition to the <i>minimum edge length</i> and <i>maximum edge length</i> define the <i>mesh grading</i> in a very detailed manner.</ul></p><p><img src=\"/spec/resources/help/imgs/mesh_fineness_comparison.png\" class=\"helpPopupImage\"/> The figure shows meshes for fineness <i>1 - very coarse</i> (left) and <i>5 - very fine</i> (right).</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC" : "#/components/schemas/AutomaticMeshSizingHexDominantSnappy",
            "MANUAL" : "#/components/schemas/ManualMeshSizingHexDominantSnappy"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutomaticMeshSizingHexDominantSnappy"
        }, {
          "$ref" : "#/components/schemas/ManualMeshSizingHexDominantSnappy"
        } ]
      },
      "OneOf_HexDominantSnappyRefinements" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "REGION_LENGTH" : "#/components/schemas/RegionRefinementWithLength",
            "SURFACE_HEX_DOMINANT_SNAPPY_V3" : "#/components/schemas/SurfaceRefinementHexDominantSnappy",
            "FEATURE_HEX_DOMINANT_SNAPPY" : "#/components/schemas/FeatureRefinementHexDominantSnappy",
            "LAYER_ADDITION_HEX_DOMINANT_SNAPPY" : "#/components/schemas/LayerAdditionHexDominantSnappy"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/RegionRefinementWithLength"
        }, {
          "$ref" : "#/components/schemas/SurfaceRefinementHexDominantSnappy"
        }, {
          "$ref" : "#/components/schemas/FeatureRefinementHexDominantSnappy"
        }, {
          "$ref" : "#/components/schemas/LayerAdditionHexDominantSnappy"
        } ]
      },
      "OneOf_SurfaceRefinementHexDominantSnappyCellZone" : {
        "title" : "Cell zone",
        "description" : "<p>You can create cell zones in your mesh by assigning this option to one or more of your CAD bodies. They can be later defined as Rotating Zones or Porosity Volumes, among others. Check these options under Advanced Concepts in the simulation tree.<p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "WITHOUT_CELL_ZONE" : "#/components/schemas/WithoutCellZone",
            "WITH_CELL_ZONE_V11" : "#/components/schemas/WithCellZone"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/WithoutCellZone"
        }, {
          "$ref" : "#/components/schemas/WithCellZone"
        } ]
      },
      "Analysis" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "STATIC_ANALYSIS" : "#/components/schemas/StaticAnalysis",
            "DYNAMIC_ANALYSIS" : "#/components/schemas/DynamicAnalysis",
            "HEAT_TRANSFER" : "#/components/schemas/HeatTransfer",
            "THERMAL_MECHANICAL" : "#/components/schemas/ThermalMechanical",
            "INCOMPRESSIBLE" : "#/components/schemas/Incompressible",
            "INCOMPRESSIBLE_PACEFISH" : "#/components/schemas/IncompressiblePacefish",
            "SIMERICS_ANALYSIS" : "#/components/schemas/SimericsAnalysis",
            "WIND_COMFORT" : "#/components/schemas/WindComfort",
            "COMPRESSIBLE" : "#/components/schemas/Compressible",
            "CONVECTIVE_HEAT_TRANSFER" : "#/components/schemas/ConvectiveHeatTransfer",
            "CONJUGATE_HEAT_TRANSFER" : "#/components/schemas/ConjugateHeatTransfer",
            "COUPLED_CONJUGATE_HEAT_TRANSFER" : "#/components/schemas/CoupledConjugateHeatTransfer",
            "EMBEDDED_BOUNDARY" : "#/components/schemas/EmbeddedBoundary",
            "MULTIPHASE" : "#/components/schemas/Multiphase",
            "HARMONIC_ANALYSIS" : "#/components/schemas/HarmonicAnalysis",
            "FREQUENCY_ANALYSIS" : "#/components/schemas/FrequencyAnalysis"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/StaticAnalysis"
        }, {
          "$ref" : "#/components/schemas/DynamicAnalysis"
        }, {
          "$ref" : "#/components/schemas/HeatTransfer"
        }, {
          "$ref" : "#/components/schemas/ThermalMechanical"
        }, {
          "$ref" : "#/components/schemas/Incompressible"
        }, {
          "$ref" : "#/components/schemas/IncompressiblePacefish"
        }, {
          "$ref" : "#/components/schemas/SimericsAnalysis"
        }, {
          "$ref" : "#/components/schemas/WindComfort"
        }, {
          "$ref" : "#/components/schemas/Compressible"
        }, {
          "$ref" : "#/components/schemas/ConvectiveHeatTransfer"
        }, {
          "$ref" : "#/components/schemas/ConjugateHeatTransfer"
        }, {
          "$ref" : "#/components/schemas/CoupledConjugateHeatTransfer"
        }, {
          "$ref" : "#/components/schemas/EmbeddedBoundary"
        }, {
          "$ref" : "#/components/schemas/Multiphase"
        }, {
          "$ref" : "#/components/schemas/HarmonicAnalysis"
        }, {
          "$ref" : "#/components/schemas/FrequencyAnalysis"
        } ]
      },
      "StaticAnalysis" : {
        "title" : "Static",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: StaticAnalysis",
            "default" : "STATIC_ANALYSIS"
          },
          "nonLinearAnalysis" : {
            "title" : "Nonlinear analysis",
            "type" : "boolean",
            "description" : "<p>Choose if your analysis should feature any kind of <b>nonlinearity</b> like <b>physical contacts, nonlinear materials</b> as hyperelasticity or plasticity or <b>large rotations</b> and <b>large deformations, temperature dependant material properties</b> or <b>temperature dependant boundary conditions</b>. For a <b>linear analysis</b> none of those nonlinearities are available.</p>",
            "default" : false
          },
          "connectionGroups" : {
            "title" : "Connection groups",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_StaticAnalysisConnectionGroups"
            }
          },
          "elementTechnology" : {
            "$ref" : "#/components/schemas/SolidElementTechnology"
          },
          "model" : {
            "$ref" : "#/components/schemas/SolidModel"
          },
          "materials" : {
            "title" : "Materials",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SolidMaterial"
            }
          },
          "initialConditions" : {
            "$ref" : "#/components/schemas/SolidInitialConditions"
          },
          "boundaryConditions" : {
            "title" : "Boundary conditions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_StaticAnalysisBoundaryConditions"
            }
          },
          "numerics" : {
            "$ref" : "#/components/schemas/SolidNumerics"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/SolidSimulationControl"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/SolidResultControl"
          },
          "meshOrder" : {
            "title" : "Mesh order",
            "type" : "string",
            "default" : "NONE",
            "enum" : [ "FIRST", "SECOND", "NONE" ]
          }
        },
        "additionalProperties" : false
      },
      "Contact" : {
        "title" : "Contact",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: Contact",
            "default" : "CONTACT"
          },
          "connections" : {
            "title" : "Contacts",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_ContactConnections"
            }
          }
        },
        "additionalProperties" : false
      },
      "BondedContact" : {
        "title" : "Bonded",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: BondedContact",
            "default" : "BONDED_CONTACT"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "enableHeatTransfer" : {
            "title" : "Enable heat transfer",
            "type" : "string",
            "default" : "YES",
            "enum" : [ "YES", "NO", "HEAT_TRANSFER_ONLY" ],
            "x-showWhen" : [ "type == THERMAL_MECHANICAL" ]
          },
          "positionTolerance" : {
            "$ref" : "#/components/schemas/OneOf_BondedContactPositionTolerance"
          },
          "masterTopologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "slaveTopologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "SetValuePositionTolerance" : {
        "title" : "Set value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SetValuePositionTolerance",
            "default" : "SET_VALUE"
          },
          "tolerance" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "OffPositionTolerance" : {
        "title" : "Off",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: OffPositionTolerance",
            "default" : "OFF"
          }
        },
        "additionalProperties" : false
      },
      "CyclicSymmetryContact" : {
        "title" : "Cyclic symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CyclicSymmetryContact",
            "default" : "CYCLIC_SYMMETRY"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "enableHeatTransfer" : {
            "title" : "Enable heat transfer",
            "type" : "string",
            "default" : "YES",
            "enum" : [ "YES", "NO", "HEAT_TRANSFER_ONLY" ],
            "x-showWhen" : [ "type == THERMAL_MECHANICAL" ]
          },
          "axisOrigin" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "axisDirection" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "sectorAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "masterTopologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "slaveTopologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "SlidingContact" : {
        "title" : "Sliding",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SlidingContact",
            "default" : "SLIDING_CONTACT"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "enableHeatTransfer" : {
            "title" : "Enable heat transfer",
            "type" : "string",
            "default" : "YES",
            "enum" : [ "YES", "NO", "HEAT_TRANSFER_ONLY" ],
            "x-showWhen" : [ "type == THERMAL_MECHANICAL" ]
          },
          "positionTolerance" : {
            "$ref" : "#/components/schemas/OneOf_SlidingContactPositionTolerance"
          },
          "masterTopologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "slaveTopologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "PhysicalContact" : {
        "title" : "Physical contacts",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PhysicalContact",
            "default" : "PHYSICAL_CONTACT_V36"
          },
          "settings" : {
            "$ref" : "#/components/schemas/ConnectionSettingsV36"
          },
          "connections" : {
            "title" : "Physical contacts",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_PhysicalContactConnections"
            }
          }
        },
        "additionalProperties" : false
      },
      "ConnectionSettingsV36" : {
        "type" : "object",
        "properties" : {
          "nonlinearityResolution" : {
            "$ref" : "#/components/schemas/OneOf_ConnectionSettingsV36NonlinearityResolution"
          },
          "friction" : {
            "$ref" : "#/components/schemas/OneOf_ConnectionSettingsV36Friction"
          },
          "contactNonLinearityResolution" : {
            "$ref" : "#/components/schemas/OneOf_ConnectionSettingsV36ContactNonLinearityResolution"
          },
          "convergenceStabilization" : {
            "title" : "Convergence stabilization",
            "type" : "boolean",
            "default" : true
          },
          "contactSmoothing" : {
            "title" : "Contact smoothing",
            "type" : "boolean",
            "default" : false
          },
          "stopIfInterpenetration" : {
            "title" : "Stop if interpenetration",
            "type" : "boolean",
            "default" : false
          },
          "verifyNorms" : {
            "title" : "Verify norms",
            "type" : "boolean",
            "default" : true
          }
        },
        "additionalProperties" : false
      },
      "NewtonNonLinearityResolution" : {
        "title" : "Newton",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NewtonNonLinearityResolution",
            "default" : "NEWTON"
          },
          "iterationCriterion" : {
            "title" : "Iteration criterion",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 1.0E-5
          }
        },
        "additionalProperties" : false
      },
      "FixedPointNonLinearityResolution" : {
        "title" : "Fixed point",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedPointNonLinearityResolution",
            "default" : "FIXED_POINT"
          },
          "geometryReactualization" : {
            "$ref" : "#/components/schemas/OneOf_FixedPointNonLinearityResolutionGeometryReactualization"
          }
        },
        "additionalProperties" : false
      },
      "AutomaticReactualization" : {
        "title" : "Automatic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AutomaticReactualization",
            "default" : "AUTOMATIC"
          },
          "maxNumIterations" : {
            "title" : "Max num iterations",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 10
          },
          "iterationCriterion" : {
            "title" : "Iteration criterion",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.05
          }
        },
        "additionalProperties" : false
      },
      "ManualReactualization" : {
        "title" : "Manual",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ManualReactualization",
            "default" : "MANUAL"
          },
          "numIterations" : {
            "title" : "Number of iterations",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 2
          }
        },
        "additionalProperties" : false
      },
      "NoneReactualization" : {
        "title" : "No update",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NoneReactualization",
            "default" : "NONE"
          }
        },
        "additionalProperties" : false
      },
      "NoFriction" : {
        "title" : "No friction",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NoFriction",
            "default" : "NO_FRICTION"
          }
        },
        "additionalProperties" : false
      },
      "CoulombFriction" : {
        "title" : "Coulomb",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CoulombFriction",
            "default" : "COULOMB_FRICTION"
          },
          "nonlinearityResolution" : {
            "$ref" : "#/components/schemas/OneOf_CoulombFrictionNonlinearityResolution"
          }
        },
        "additionalProperties" : false
      },
      "NewtonFrictionNonLinearityResolution" : {
        "title" : "Newton",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NewtonFrictionNonLinearityResolution",
            "default" : "NEWTON_V29"
          },
          "iterationCriterion" : {
            "title" : "Iteration criterion",
            "type" : "number",
            "default" : 1.0E-4
          }
        },
        "additionalProperties" : false
      },
      "FixedPointFrictionNonLinearityResolution" : {
        "title" : "Fixed point",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedPointFrictionNonLinearityResolution",
            "default" : "FIXED_POINT"
          },
          "maxNumIteration" : {
            "title" : "Max num iteration",
            "type" : "integer",
            "default" : 10
          },
          "iterationCriterion" : {
            "title" : "Iteration criterion",
            "type" : "number",
            "default" : 1.0E-4
          }
        },
        "additionalProperties" : false
      },
      "NewtonContactNonLinearityResolution" : {
        "title" : "Newton",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NewtonContactNonLinearityResolution",
            "default" : "NEWTON"
          }
        },
        "additionalProperties" : false
      },
      "FixedPointContactNonLinearityResolution" : {
        "title" : "Fixed point",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedPointContactNonLinearityResolution",
            "default" : "FIXED_POINT"
          },
          "iterationControl" : {
            "$ref" : "#/components/schemas/OneOf_FixedPointContactNonLinearityResolutionIterationControl"
          }
        },
        "additionalProperties" : false
      },
      "MaximumNumberIterationControl" : {
        "title" : "Maximum number",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: MaximumNumberIterationControl",
            "default" : "MAXIMUM_NUMBER"
          },
          "maxNumIteration" : {
            "title" : "Max num iteration",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 30
          }
        },
        "additionalProperties" : false
      },
      "MultipliedSlaveNodesIterationControl" : {
        "title" : "Multiple of slave nodes",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: MultipliedSlaveNodesIterationControl",
            "default" : "MULTIPLIED_SLAVE_NODE"
          },
          "multipleValue" : {
            "title" : "Multiple value",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 4
          }
        },
        "additionalProperties" : false
      },
      "FrictionlessContact" : {
        "title" : "Physical contact",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FrictionlessContact",
            "default" : "FRICTIONLESS_CONTACT"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "contactSolutionMethod" : {
            "$ref" : "#/components/schemas/OneOf_FrictionlessContactContactSolutionMethod"
          },
          "fictitiousClearance" : {
            "$ref" : "#/components/schemas/OneOf_FrictionlessContactFictitiousClearance"
          },
          "masterTopologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "slaveTopologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "AugmentedLagrangeMethod" : {
        "title" : "Augmented Lagrange method",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AugmentedLagrangeMethod",
            "default" : "AUGMENTED_LAGRANGE"
          },
          "augmentedLagrangeCoefficient" : {
            "title" : "Augmented lagrange coefficient",
            "maximum" : 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 100
          }
        },
        "additionalProperties" : false
      },
      "PenaltyMethod" : {
        "title" : "Penalty method",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PenaltyMethod",
            "default" : "PENALTY_METHOD"
          },
          "penaltyCoefficient" : {
            "title" : "Penalty coefficient",
            "maximum" : 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 100000000000
          }
        },
        "additionalProperties" : false
      },
      "NoFictitiousClearance" : {
        "title" : "No",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NoFictitiousClearance",
            "default" : "NO_FICTITIOUS_CLEARANCE"
          }
        },
        "additionalProperties" : false
      },
      "WithFictitiousClearance" : {
        "title" : "Yes",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WithFictitiousClearance",
            "default" : "WITH_FICTITIOUS_CLEARANCE"
          },
          "masterClearance" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Length"
          },
          "slaveClearance" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Length"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalFunction_Length" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_LengthValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m", "in" ]
          }
        },
        "additionalProperties" : false
      },
      "ConstantFunction" : {
        "title" : "Constant function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ConstantFunction",
            "default" : "CONSTANT"
          },
          "value" : {
            "title" : "Value",
            "type" : "number"
          }
        },
        "additionalProperties" : false
      },
      "ExpressionFunction" : {
        "title" : "Expression function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ExpressionFunction",
            "default" : "EXPRESSION"
          },
          "expression" : {
            "title" : "Expression",
            "type" : "string"
          },
          "availableVariables" : {
            "title" : "Available variables",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/FunctionParameter"
            }
          }
        },
        "additionalProperties" : false
      },
      "FunctionParameter" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "parameter" : {
            "title" : "Parameter",
            "type" : "string"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string"
          }
        },
        "additionalProperties" : false
      },
      "PolynomialFunction" : {
        "title" : "Polynomial function",
        "required" : [ "parameterBaseUnit", "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PolynomialFunction",
            "default" : "POLYNOMIAL"
          },
          "coefficients" : {
            "title" : "Coefficients",
            "type" : "array",
            "items" : {
              "type" : "number"
            }
          },
          "parameterBaseUnit" : {
            "title" : "Parameter base unit",
            "type" : "string"
          }
        },
        "additionalProperties" : false
      },
      "TableDefinedFunction" : {
        "title" : "Table defined function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TableDefinedFunction",
            "default" : "TABLE_DEFINED"
          },
          "label" : {
            "title" : "Label",
            "type" : "string",
            "default" : "Table"
          },
          "tableId" : {
            "type" : "string",
            "description" : "The ID of the imported table.",
            "format" : "uuid"
          },
          "resultIndex" : {
            "title" : "Result index",
            "type" : "array",
            "description" : "Indicates which column(s) of the table contains the result values. One-based indexing must be used. For example, set this field to '[2]' if the second column of the table contains the dependent variable values.",
            "items" : {
              "type" : "integer"
            }
          },
          "independentVariables" : {
            "title" : "Independent variables",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/TableFunctionParameter"
            }
          },
          "separator" : {
            "title" : "Separator",
            "type" : "string",
            "description" : "Values in each row are separated by this character. Also known as a delimiter.",
            "default" : ","
          },
          "outOfBounds" : {
            "title" : "Out of bounds",
            "type" : "string",
            "default" : "CLAMP",
            "enum" : [ "CLAMP" ],
            "x-showWhen" : [ "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY,MULTIPHASE,INCOMPRESSIBLE_PACEFISH]" ]
          },
          "interpolation" : {
            "title" : "Interpolation",
            "type" : "string",
            "default" : "LINEAR",
            "enum" : [ "LINEAR", "LOGARITHMIC" ],
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL,HARMONIC_ANALYSIS,FREQUENCY_ANALYSIS]" ]
          },
          "leftExtrapolation" : {
            "title" : "Left extrapolation",
            "type" : "string",
            "default" : "LINEAR",
            "enum" : [ "CONSTANT", "LINEAR", "NONE" ],
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL,HARMONIC_ANALYSIS,FREQUENCY_ANALYSIS]" ]
          },
          "rightExtrapolation" : {
            "title" : "Right extrapolation",
            "type" : "string",
            "default" : "LINEAR",
            "enum" : [ "CONSTANT", "LINEAR", "NONE" ],
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL,HARMONIC_ANALYSIS,FREQUENCY_ANALYSIS]" ]
          }
        },
        "additionalProperties" : false
      },
      "TableFunctionParameter" : {
        "required" : [ "reference", "unit" ],
        "type" : "object",
        "properties" : {
          "reference" : {
            "title" : "Reference",
            "type" : "integer",
            "description" : "Indicates which column of the table contains the values of this independent variable. One-based indexing must be used. For example, set this property to '1' if the first column of the table contains the values of this independent variable."
          },
          "parameter" : {
            "title" : "Parameter",
            "type" : "string",
            "description" : "The name of the independent variable. Possible values: 'X', 'Y', 'Z', 'HEIGHT', 'Temperature', 'T' (time), 'Q' (mass flow rate), 'V_DOT' (volumetric flow rate), 'F' (frequency), 'E' (strain)"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string"
          }
        },
        "additionalProperties" : false
      },
      "VariableGroup_X_Y_Z_TIME" : {
        "type" : "object",
        "properties" : {
          "X" : {
            "$ref" : "#/components/schemas/Unit_Length"
          },
          "Y" : {
            "$ref" : "#/components/schemas/Unit_Length"
          },
          "Z" : {
            "$ref" : "#/components/schemas/Unit_Length"
          },
          "T" : {
            "$ref" : "#/components/schemas/Unit_Time"
          }
        }
      },
      "Unit_Length" : {
        "type" : "object",
        "properties" : {
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m", "in" ]
          }
        }
      },
      "Unit_Time" : {
        "type" : "object",
        "properties" : {
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "s" ]
          }
        }
      },
      "FrictionContact" : {
        "title" : "Physical contact",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FrictionContact",
            "default" : "FRICTION_CONTACT"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "contactSolutionMethod" : {
            "$ref" : "#/components/schemas/OneOf_FrictionContactContactSolutionMethod"
          },
          "frictionCoefficient" : {
            "$ref" : "#/components/schemas/OneOf_FrictionContactFrictionCoefficient"
          },
          "fictitiousClearance" : {
            "$ref" : "#/components/schemas/OneOf_FrictionContactFictitiousClearance"
          },
          "masterTopologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "slaveTopologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "FrictionAugmentedLagrangeCoef" : {
        "title" : "Friction augmentation lagrange coefficient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FrictionAugmentedLagrangeCoef",
            "default" : "FRICTION_AUGMENTATION_COEF"
          },
          "frictionAugmentationCoefficient" : {
            "$ref" : "#/components/schemas/Dimensional_FrictionAugmentation"
          },
          "coulombCoefficient" : {
            "title" : "Coulomb coefficient",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.1
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_FrictionAugmentation" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/m", "1/in" ]
          }
        },
        "additionalProperties" : false
      },
      "FrictionPenaltyCoef" : {
        "title" : "Friction penalty coefficient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FrictionPenaltyCoef",
            "default" : "FRICTION_PENALTY_COEF"
          },
          "frictionPenaltyCoefficient" : {
            "title" : "Friction penalty coefficient",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 100000
          },
          "coulombCoefficient" : {
            "title" : "Coulomb coefficient",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.1
          }
        },
        "additionalProperties" : false
      },
      "SolidElementTechnology" : {
        "type" : "object",
        "properties" : {
          "elementTechnology3D" : {
            "$ref" : "#/components/schemas/ElementTechnology"
          }
        },
        "additionalProperties" : false
      },
      "ElementTechnology" : {
        "type" : "object",
        "properties" : {
          "mechanicalElementType" : {
            "title" : "Type",
            "type" : "string",
            "default" : "STANDARD",
            "enum" : [ "STANDARD", "REDUCED_INTEGRATION" ],
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HARMONIC_ANALYSIS,FREQUENCY_ANALYSIS,THERMAL_MECHANICAL]" ]
          },
          "thermalElementType" : {
            "title" : "Thermal element type",
            "type" : "string",
            "default" : "STANDARD",
            "enum" : [ "STANDARD", "LUMPED_THERMAL_MASS" ],
            "x-showWhen" : [ "type in [HEAT_TRANSFER,THERMAL_MECHANICAL]" ]
          },
          "thermalMassOrderReduction" : {
            "title" : "Thermal mass order reduction",
            "type" : "boolean",
            "default" : false,
            "x-showWhen" : [ "type == THERMAL_MECHANICAL" ]
          },
          "definitions" : {
            "title" : "Element definitions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ElementTechnologyDefinition"
            }
          }
        },
        "additionalProperties" : false
      },
      "ElementTechnologyDefinition" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "mechanicalElementType" : {
            "title" : "Type",
            "type" : "string",
            "default" : "STANDARD",
            "enum" : [ "STANDARD", "REDUCED_INTEGRATION" ],
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HARMONIC_ANALYSIS,FREQUENCY_ANALYSIS,THERMAL_MECHANICAL]" ]
          },
          "thermalElementType" : {
            "title" : "Thermal element type",
            "type" : "string",
            "default" : "STANDARD",
            "enum" : [ "STANDARD", "LUMPED_THERMAL_MASS" ],
            "x-showWhen" : [ "type in [HEAT_TRANSFER,THERMAL_MECHANICAL]" ]
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "SolidModel" : {
        "type" : "object",
        "properties" : {
          "geometricBehavior" : {
            "title" : "Geometric behavior",
            "type" : "string",
            "default" : "NONLINEAR",
            "enum" : [ "LINEAR", "NONLINEAR" ],
            "x-showWhen" : [ "type == DYNAMIC_ANALYSIS", "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true" ]
          },
          "magnitude" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Acceleration"
          },
          "e" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalFunction_Acceleration" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_AccelerationValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "in/s" ]
          }
        },
        "additionalProperties" : false
      },
      "VariableGroup_TIME" : {
        "type" : "object",
        "properties" : {
          "T" : {
            "$ref" : "#/components/schemas/Unit_Time"
          }
        }
      },
      "SolidMaterial" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "materialBehavior" : {
            "$ref" : "#/components/schemas/OneOf_SolidMaterialMaterialBehavior"
          },
          "density" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Density"
          },
          "expansion" : {
            "$ref" : "#/components/schemas/IsotropicExpansion"
          },
          "conductivity" : {
            "$ref" : "#/components/schemas/OneOf_SolidMaterialConductivity"
          },
          "specificHeat" : {
            "$ref" : "#/components/schemas/DimensionalFunction_SpecificHeat"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "builtInMaterial" : {
            "type" : "string"
          },
          "materialLibraryReference" : {
            "$ref" : "#/components/schemas/MaterialLibraryReference"
          }
        },
        "additionalProperties" : false
      },
      "LinearElasticMaterialBehavior" : {
        "title" : "Linear elastic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose the material behavior for your problem. </p> <br /><br />Important remarks:<br /> <ul><li>Choose <b>Linear elastic</b> if the stress-strain relationship of your material is linear.</li><li>Choose <b>Elasto-plastic</b> if the stress-strain relationship of your material is non-linear after some point e.g. yielding point.</li><li>Choose <b>Hyperelastic</b> if your material responds elastically even at higher deformations.</li></ul> \n\nSchema name: LinearElasticMaterialBehavior",
            "default" : "LINEAR_ELASTIC"
          },
          "directionalDependency" : {
            "$ref" : "#/components/schemas/IsotropicDirectionalDependency"
          },
          "damping" : {
            "$ref" : "#/components/schemas/OneOf_LinearElasticMaterialBehaviorDamping"
          },
          "creepFormulation" : {
            "$ref" : "#/components/schemas/OneOf_LinearElasticMaterialBehaviorCreepFormulation"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose the material behavior for your problem. </p> <br /><br />Important remarks:<br /> <ul><li>Choose <b>Linear elastic</b> if the stress-strain relationship of your material is linear.</li><li>Choose <b>Elasto-plastic</b> if the stress-strain relationship of your material is non-linear after some point e.g. yielding point.</li><li>Choose <b>Hyperelastic</b> if your material responds elastically even at higher deformations.</li></ul> "
      },
      "IsotropicDirectionalDependency" : {
        "title" : "Isotropic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose the directional dependency for this property. <b>Anisotropic and orthotropic materials will be available soon.</b></p>\n\nSchema name: IsotropicDirectionalDependency",
            "default" : "ISOTROPIC"
          },
          "youngsModulus" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Pressure"
          },
          "poissonsRatio" : {
            "$ref" : "#/components/schemas/OneOf_IsotropicDirectionalDependencyPoissonsRatio"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose the directional dependency for this property. <b>Anisotropic and orthotropic materials will be available soon.</b></p>"
      },
      "DimensionalFunction_Pressure" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_PressureValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "Pa", "lbf/in", "kPa", "MPa", "bar", "mbar", "mH2O" ]
          }
        },
        "additionalProperties" : false
      },
      "VariableGroup_TEMP" : {
        "type" : "object",
        "properties" : {
          "Temperature" : {
            "$ref" : "#/components/schemas/Unit_Temperature"
          }
        }
      },
      "Unit_Temperature" : {
        "type" : "object",
        "properties" : {
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "C", "F", "K" ]
          }
        }
      },
      "NoneDamping" : {
        "title" : "None",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose if damping effects should be considered. The supported damping types are:<ul><li><p><b>Rayleigh Damping</b> which is also known as <i>proportional viscous damping</i>. This model assumes that the damping is proportional to the vibrating velocity.</p></ul><ul><li><p><b>Hysteretic Damping</b>, also known as <i>structural damping</i>. Here the damping is assumed to be proportional to the displacement.</p></ul><br><a href= https://www.simscale.com/docs/simulation-setup/materials/damping/' target='_blank'>Learn more</a>. \n\nSchema name: NoneDamping",
            "default" : "NONE"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose if damping effects should be considered. The supported damping types are:<ul><li><p><b>Rayleigh Damping</b> which is also known as <i>proportional viscous damping</i>. This model assumes that the damping is proportional to the vibrating velocity.</p></ul><ul><li><p><b>Hysteretic Damping</b>, also known as <i>structural damping</i>. Here the damping is assumed to be proportional to the displacement.</p></ul><br><a href= https://www.simscale.com/docs/simulation-setup/materials/damping/' target='_blank'>Learn more</a>. "
      },
      "RayleighDamping" : {
        "title" : "Rayleigh damping",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose if damping effects should be considered. The supported damping types are:<ul><li><p><b>Rayleigh Damping</b> which is also known as <i>proportional viscous damping</i>. This model assumes that the damping is proportional to the vibrating velocity.</p></ul><ul><li><p><b>Hysteretic Damping</b>, also known as <i>structural damping</i>. Here the damping is assumed to be proportional to the displacement.</p></ul><br><a href= https://www.simscale.com/docs/simulation-setup/materials/damping/' target='_blank'>Learn more</a>. \n\nSchema name: RayleighDamping",
            "default" : "RAYLEIGH"
          },
          "stiffnessProportionalCoefficient" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "massProportionalCoefficient" : {
            "$ref" : "#/components/schemas/Dimensional_Frequency"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose if damping effects should be considered. The supported damping types are:<ul><li><p><b>Rayleigh Damping</b> which is also known as <i>proportional viscous damping</i>. This model assumes that the damping is proportional to the vibrating velocity.</p></ul><ul><li><p><b>Hysteretic Damping</b>, also known as <i>structural damping</i>. Here the damping is assumed to be proportional to the displacement.</p></ul><br><a href= https://www.simscale.com/docs/simulation-setup/materials/damping/' target='_blank'>Learn more</a>. "
      },
      "Dimensional_Time" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "s" ]
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_Frequency" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/s" ]
          }
        },
        "additionalProperties" : false
      },
      "HystereticDamping" : {
        "title" : "Hysteretic damping",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose if damping effects should be considered. The supported damping types are:<ul><li><p><b>Rayleigh Damping</b> which is also known as <i>proportional viscous damping</i>. This model assumes that the damping is proportional to the vibrating velocity.</p></ul><ul><li><p><b>Hysteretic Damping</b>, also known as <i>structural damping</i>. Here the damping is assumed to be proportional to the displacement.</p></ul><br><a href= https://www.simscale.com/docs/simulation-setup/materials/damping/' target='_blank'>Learn more</a>. \n\nSchema name: HystereticDamping",
            "default" : "HYSTERETIC"
          },
          "hystereticCoefficient" : {
            "title" : "Hysteretic coefficient",
            "type" : "number",
            "description" : "<p>Set the hysteretic damping coefficient <b>&kappa;</b> of the material. The system equation is then: <b>M*+K*(1+i*&kappa;)*u = f</b>.</p>",
            "default" : 0,
            "x-showWhen" : [ "type in [HARMONIC_ANALYSIS,FREQUENCY_ANALYSIS]" ]
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose if damping effects should be considered. The supported damping types are:<ul><li><p><b>Rayleigh Damping</b> which is also known as <i>proportional viscous damping</i>. This model assumes that the damping is proportional to the vibrating velocity.</p></ul><ul><li><p><b>Hysteretic Damping</b>, also known as <i>structural damping</i>. Here the damping is assumed to be proportional to the displacement.</p></ul><br><a href= https://www.simscale.com/docs/simulation-setup/materials/damping/' target='_blank'>Learn more</a>. "
      },
      "NortonCreepFormulation" : {
        "title" : "Norton",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Define the Creep formulation. Two fundamental Creep law types are available: <ul><li><b>Power Law</b></li><b>&epsilon;&#775 = m*A*&sigma;<sup>n</sup>*t<sup>m-1</sup></b><li><b>Hyperbolic Sine Law</b> </li><b>&epsilon;&#775;= &epsilon;<sub>0</sub>* sinh(&sigma;/(&sigma;<sub>0</sub>))<sup>n</sup></b>.</ul> For the Power Law different formulations, like the <b>Norton</b>, <b>Strain Hardening</b> or <b>Time Hardening</b> are available. For the Hyperbolic Sine Law, the <b>Garofalo<b> formulation is available.</p>\n\nSchema name: NortonCreepFormulation",
            "default" : "NORTON"
          },
          "a" : {
            "$ref" : "#/components/schemas/Dimensional_StrainRate"
          },
          "n" : {
            "title" : "N",
            "type" : "number",
            "description" : "<p>Define the parameter <b>n</b> of the Norton creep formulation: <ul><b>&epsilon;&#775; = A*&sigma;<sup>n</sup></b></ul></p>",
            "x-showWhen" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true", "type == DYNAMIC_ANALYSIS" ]
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Define the Creep formulation. Two fundamental Creep law types are available: <ul><li><b>Power Law</b></li><b>&epsilon;&#775 = m*A*&sigma;<sup>n</sup>*t<sup>m-1</sup></b><li><b>Hyperbolic Sine Law</b> </li><b>&epsilon;&#775;= &epsilon;<sub>0</sub>* sinh(&sigma;/(&sigma;<sub>0</sub>))<sup>n</sup></b>.</ul> For the Power Law different formulations, like the <b>Norton</b>, <b>Strain Hardening</b> or <b>Time Hardening</b> are available. For the Hyperbolic Sine Law, the <b>Garofalo<b> formulation is available.</p>"
      },
      "Dimensional_StrainRate" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/s" ]
          }
        },
        "additionalProperties" : false
      },
      "NoCreepFormulation" : {
        "title" : "No creep",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Define the Creep formulation. Two fundamental Creep law types are available: <ul><li><b>Power Law</b></li><b>&epsilon;&#775 = m*A*&sigma;<sup>n</sup>*t<sup>m-1</sup></b><li><b>Hyperbolic Sine Law</b> </li><b>&epsilon;&#775;= &epsilon;<sub>0</sub>* sinh(&sigma;/(&sigma;<sub>0</sub>))<sup>n</sup></b>.</ul> For the Power Law different formulations, like the <b>Norton</b>, <b>Strain Hardening</b> or <b>Time Hardening</b> are available. For the Hyperbolic Sine Law, the <b>Garofalo<b> formulation is available.</p>\n\nSchema name: NoCreepFormulation",
            "default" : "NO_CREEP"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Define the Creep formulation. Two fundamental Creep law types are available: <ul><li><b>Power Law</b></li><b>&epsilon;&#775 = m*A*&sigma;<sup>n</sup>*t<sup>m-1</sup></b><li><b>Hyperbolic Sine Law</b> </li><b>&epsilon;&#775;= &epsilon;<sub>0</sub>* sinh(&sigma;/(&sigma;<sub>0</sub>))<sup>n</sup></b>.</ul> For the Power Law different formulations, like the <b>Norton</b>, <b>Strain Hardening</b> or <b>Time Hardening</b> are available. For the Hyperbolic Sine Law, the <b>Garofalo<b> formulation is available.</p>"
      },
      "StrainHardeningCreepFormulation" : {
        "title" : "Strain hardening",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Define the Creep formulation. Two fundamental Creep law types are available: <ul><li><b>Power Law</b></li><b>&epsilon;&#775 = m*A*&sigma;<sup>n</sup>*t<sup>m-1</sup></b><li><b>Hyperbolic Sine Law</b> </li><b>&epsilon;&#775;= &epsilon;<sub>0</sub>* sinh(&sigma;/(&sigma;<sub>0</sub>))<sup>n</sup></b>.</ul> For the Power Law different formulations, like the <b>Norton</b>, <b>Strain Hardening</b> or <b>Time Hardening</b> are available. For the Hyperbolic Sine Law, the <b>Garofalo<b> formulation is available.</p>\n\nSchema name: StrainHardeningCreepFormulation",
            "default" : "STRAIN_HARDENING"
          },
          "a" : {
            "$ref" : "#/components/schemas/Dimensional_StrainRate"
          },
          "n" : {
            "title" : "N",
            "type" : "number",
            "description" : "<p>Define the parameter <b>n</b> of the Strain Hardening creep formulation: <ul><b>&epsilon;&#775; = A*&sigma;<sup>n</sup>*&epsilon;<sup>m</sup></b></ul></p>",
            "x-showWhen" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true", "type == DYNAMIC_ANALYSIS" ]
          },
          "m" : {
            "title" : "M",
            "type" : "number",
            "description" : "<p>Define the parameter <b>m</b> of the Strain Hardening creep formulation: <ul><b>&epsilon;&#775; = A*&sigma;<sup>n</sup>*&epsilon;<sup>m</sup></b></ul></p>",
            "x-showWhen" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true", "type == DYNAMIC_ANALYSIS" ]
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Define the Creep formulation. Two fundamental Creep law types are available: <ul><li><b>Power Law</b></li><b>&epsilon;&#775 = m*A*&sigma;<sup>n</sup>*t<sup>m-1</sup></b><li><b>Hyperbolic Sine Law</b> </li><b>&epsilon;&#775;= &epsilon;<sub>0</sub>* sinh(&sigma;/(&sigma;<sub>0</sub>))<sup>n</sup></b>.</ul> For the Power Law different formulations, like the <b>Norton</b>, <b>Strain Hardening</b> or <b>Time Hardening</b> are available. For the Hyperbolic Sine Law, the <b>Garofalo<b> formulation is available.</p>"
      },
      "TimeHardeningCreepFormulation" : {
        "title" : "Time hardening",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Define the Creep formulation. Two fundamental Creep law types are available: <ul><li><b>Power Law</b></li><b>&epsilon;&#775 = m*A*&sigma;<sup>n</sup>*t<sup>m-1</sup></b><li><b>Hyperbolic Sine Law</b> </li><b>&epsilon;&#775;= &epsilon;<sub>0</sub>* sinh(&sigma;/(&sigma;<sub>0</sub>))<sup>n</sup></b>.</ul> For the Power Law different formulations, like the <b>Norton</b>, <b>Strain Hardening</b> or <b>Time Hardening</b> are available. For the Hyperbolic Sine Law, the <b>Garofalo<b> formulation is available.</p>\n\nSchema name: TimeHardeningCreepFormulation",
            "default" : "TIME_HARDENING"
          },
          "a" : {
            "$ref" : "#/components/schemas/Dimensional_StrainRate"
          },
          "n" : {
            "title" : "N",
            "type" : "number",
            "description" : "<p>Define the parameter <b>n</b> of the Time Hardening creep formulation: <ul><b>&epsilon;&#775; = A*&sigma;<sup>n</sup>*t<sup>m</sup></b></ul></p>",
            "x-showWhen" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true", "type == DYNAMIC_ANALYSIS" ]
          },
          "m" : {
            "title" : "M",
            "type" : "number",
            "description" : "<p>Define the parameter <b>m</b> of the Time Hardening creep formulation: <ul><b>&epsilon;&#775; = A*&sigma;<sup>n</sup>*t<sup>m</sup></b></ul></p>",
            "x-showWhen" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true", "type == DYNAMIC_ANALYSIS" ]
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Define the Creep formulation. Two fundamental Creep law types are available: <ul><li><b>Power Law</b></li><b>&epsilon;&#775 = m*A*&sigma;<sup>n</sup>*t<sup>m-1</sup></b><li><b>Hyperbolic Sine Law</b> </li><b>&epsilon;&#775;= &epsilon;<sub>0</sub>* sinh(&sigma;/(&sigma;<sub>0</sub>))<sup>n</sup></b>.</ul> For the Power Law different formulations, like the <b>Norton</b>, <b>Strain Hardening</b> or <b>Time Hardening</b> are available. For the Hyperbolic Sine Law, the <b>Garofalo<b> formulation is available.</p>"
      },
      "GarofaloCreepFormulation" : {
        "title" : "Garofalo",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Define the Creep formulation. Two fundamental Creep law types are available: <ul><li><b>Power Law</b></li><b>&epsilon;&#775 = m*A*&sigma;<sup>n</sup>*t<sup>m-1</sup></b><li><b>Hyperbolic Sine Law</b> </li><b>&epsilon;&#775;= &epsilon;<sub>0</sub>* sinh(&sigma;/(&sigma;<sub>0</sub>))<sup>n</sup></b>.</ul> For the Power Law different formulations, like the <b>Norton</b>, <b>Strain Hardening</b> or <b>Time Hardening</b> are available. For the Hyperbolic Sine Law, the <b>Garofalo<b> formulation is available.</p>\n\nSchema name: GarofaloCreepFormulation",
            "default" : "GAROFALO"
          },
          "a" : {
            "$ref" : "#/components/schemas/Dimensional_StrainRate"
          },
          "n" : {
            "title" : "N",
            "type" : "number",
            "description" : "<p>Define the parameter <b>&sigma;<sub>0</sub></b> of the Garofalo creep formulation: <ul><b>&epsilon;&#775; = &epsilon;<sub>0</sub>* &sinh(&sigma;/(&sigma<sub>0</sub>))<sup>n</sup></b></ul></p>",
            "x-showWhen" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true", "type == DYNAMIC_ANALYSIS" ]
          },
          "s" : {
            "title" : "S",
            "type" : "number",
            "description" : "<p>Define the parameter <b>&epsilon;<sub>0</sub></b> of the Garofalo creep formulation: <ul><b>&epsilon;&#775; = &epsilon;<sub>0</sub>* &sinh(&sigma;/(&sigma<sub>0</sub>))<sup>n</sup></b></ul></p>",
            "x-showWhen" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true", "type == DYNAMIC_ANALYSIS" ]
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Define the Creep formulation. Two fundamental Creep law types are available: <ul><li><b>Power Law</b></li><b>&epsilon;&#775 = m*A*&sigma;<sup>n</sup>*t<sup>m-1</sup></b><li><b>Hyperbolic Sine Law</b> </li><b>&epsilon;&#775;= &epsilon;<sub>0</sub>* sinh(&sigma;/(&sigma;<sub>0</sub>))<sup>n</sup></b>.</ul> For the Power Law different formulations, like the <b>Norton</b>, <b>Strain Hardening</b> or <b>Time Hardening</b> are available. For the Hyperbolic Sine Law, the <b>Garofalo<b> formulation is available.</p>"
      },
      "HyperElasticMaterialBehavior" : {
        "title" : "Hyper elastic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose the material behavior for your problem. </p> <br /><br />Important remarks:<br /> <ul><li>Choose <b>Linear elastic</b> if the stress-strain relationship of your material is linear.</li><li>Choose <b>Elasto-plastic</b> if the stress-strain relationship of your material is non-linear after some point e.g. yielding point.</li><li>Choose <b>Hyperelastic</b> if your material responds elastically even at higher deformations.</li></ul> \n\nSchema name: HyperElasticMaterialBehavior",
            "default" : "HYPER_ELASTIC"
          },
          "hyperElasticModel" : {
            "$ref" : "#/components/schemas/OneOf_HyperElasticMaterialBehaviorHyperElasticModel"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose the material behavior for your problem. </p> <br /><br />Important remarks:<br /> <ul><li>Choose <b>Linear elastic</b> if the stress-strain relationship of your material is linear.</li><li>Choose <b>Elasto-plastic</b> if the stress-strain relationship of your material is non-linear after some point e.g. yielding point.</li><li>Choose <b>Hyperelastic</b> if your material responds elastically even at higher deformations.</li></ul> "
      },
      "MooneyRivlinHyperElasticModel" : {
        "title" : "Mooney Rivlin",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose the hyperelastic material model that should be used. All models derive the stress-strain relation from a strain energy function defined by the material model parameters.</p>\n\nSchema name: MooneyRivlinHyperElasticModel",
            "default" : "MOONEY_RIVLIN"
          },
          "c10" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "c01" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "d1" : {
            "$ref" : "#/components/schemas/Dimensional_InvPressure"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose the hyperelastic material model that should be used. All models derive the stress-strain relation from a strain energy function defined by the material model parameters.</p>"
      },
      "Dimensional_Pressure" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "Pa", "lbf/in", "kPa", "MPa", "bar", "mbar", "mH2O" ]
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_InvPressure" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/Pa", "in/lbf" ]
          }
        },
        "additionalProperties" : false
      },
      "NeoHookeHyperElasticModel" : {
        "title" : "Neo Hooke",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose the hyperelastic material model that should be used. All models derive the stress-strain relation from a strain energy function defined by the material model parameters.</p>\n\nSchema name: NeoHookeHyperElasticModel",
            "default" : "NEO_HOOKE"
          },
          "c10" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "d1" : {
            "$ref" : "#/components/schemas/Dimensional_InvPressure"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose the hyperelastic material model that should be used. All models derive the stress-strain relation from a strain energy function defined by the material model parameters.</p>"
      },
      "SignoriniHyperElasticModel" : {
        "title" : "Signorini hyper elastic model",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose the hyperelastic material model that should be used. All models derive the stress-strain relation from a strain energy function defined by the material model parameters.</p>\n\nSchema name: SignoriniHyperElasticModel",
            "default" : "SIGNORINI"
          },
          "c10" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "c01" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "c20" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "d1" : {
            "$ref" : "#/components/schemas/Dimensional_InvPressure"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose the hyperelastic material model that should be used. All models derive the stress-strain relation from a strain energy function defined by the material model parameters.</p>"
      },
      "PlasticMaterialBehavior" : {
        "title" : "Elasto-plastic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose the material behavior for your problem. </p> <br /><br />Important remarks:<br /> <ul><li>Choose <b>Linear elastic</b> if the stress-strain relationship of your material is linear.</li><li>Choose <b>Elasto-plastic</b> if the stress-strain relationship of your material is non-linear after some point e.g. yielding point.</li><li>Choose <b>Hyperelastic</b> if your material responds elastically even at higher deformations.</li></ul> \n\nSchema name: PlasticMaterialBehavior",
            "default" : "PLASTIC"
          },
          "plasticHardening" : {
            "$ref" : "#/components/schemas/IsotropicPlasticHardening"
          },
          "creepFormulation" : {
            "$ref" : "#/components/schemas/OneOf_PlasticMaterialBehaviorCreepFormulation"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose the material behavior for your problem. </p> <br /><br />Important remarks:<br /> <ul><li>Choose <b>Linear elastic</b> if the stress-strain relationship of your material is linear.</li><li>Choose <b>Elasto-plastic</b> if the stress-strain relationship of your material is non-linear after some point e.g. yielding point.</li><li>Choose <b>Hyperelastic</b> if your material responds elastically even at higher deformations.</li></ul> "
      },
      "IsotropicPlasticHardening" : {
        "title" : "Isotropic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Define the plastic hardening type of the material.</p>\n\nSchema name: IsotropicPlasticHardening",
            "default" : "ISOTROPIC"
          },
          "youngsModulus" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Pressure"
          },
          "poissonsRatio" : {
            "$ref" : "#/components/schemas/OneOf_IsotropicPlasticHardeningPoissonsRatio"
          },
          "vonMisesStress" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Pressure"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Define the plastic hardening type of the material.</p>"
      },
      "VariableGroup_STRAIN" : {
        "type" : "object",
        "properties" : {
          "E" : {
            "$ref" : "#/components/schemas/Unit_Dimensionless"
          }
        }
      },
      "Unit_Dimensionless" : {
        "type" : "object",
        "properties" : {
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "" ]
          }
        }
      },
      "VariableGroup_TEMP_STRAIN" : {
        "type" : "object",
        "properties" : {
          "E" : {
            "$ref" : "#/components/schemas/Unit_Dimensionless"
          },
          "Temperature" : {
            "$ref" : "#/components/schemas/Unit_Temperature"
          }
        }
      },
      "DimensionalFunction_Density" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_DensityValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "kg/m", "lb/in" ]
          }
        },
        "additionalProperties" : false
      },
      "IsotropicExpansion" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Define the directional dependency of this property. Isotropic means directionally independent.</p>\n\nSchema name: IsotropicExpansion",
            "default" : "ISOTROPIC"
          },
          "expansionCoefficient" : {
            "$ref" : "#/components/schemas/DimensionalFunction_ThermalExpansionRate"
          },
          "referenceTemperature" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Define the directional dependency of this property. Isotropic means directionally independent.</p>"
      },
      "DimensionalFunction_ThermalExpansionRate" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_ThermalExpansionRateValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/K", "1/F" ]
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_Temperature" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "C", "F", "K" ]
          }
        },
        "additionalProperties" : false
      },
      "IsotropicConductivity" : {
        "title" : "Isotropic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Define the directional dependency of this property. Isotropic means directionally independent. Orthotropic means directionally dependent.</p>\n\nSchema name: IsotropicConductivity",
            "default" : "ISOTROPIC"
          },
          "thermalConductivity" : {
            "$ref" : "#/components/schemas/DimensionalFunction_ThermalConductivity"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Define the directional dependency of this property. Isotropic means directionally independent. Orthotropic means directionally dependent.</p>"
      },
      "DimensionalFunction_ThermalConductivity" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_ThermalConductivityValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "W/(mK)", "Btu/(sinF)" ]
          }
        },
        "additionalProperties" : false
      },
      "VariableGroup_EMPTY" : {
        "type" : "object",
        "properties" : { }
      },
      "OrthotropicConductivity" : {
        "title" : "Orthotropic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Define the directional dependency of this property. Isotropic means directionally independent. Orthotropic means directionally dependent.</p>\n\nSchema name: OrthotropicConductivity",
            "default" : "ORTHOTROPIC"
          },
          "thermalConductivityX" : {
            "$ref" : "#/components/schemas/DimensionalFunction_ThermalConductivity"
          },
          "thermalConductivityY" : {
            "$ref" : "#/components/schemas/DimensionalFunction_ThermalConductivity"
          },
          "thermalConductivityZ" : {
            "$ref" : "#/components/schemas/DimensionalFunction_ThermalConductivity"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Define the directional dependency of this property. Isotropic means directionally independent. Orthotropic means directionally dependent.</p>"
      },
      "DimensionalFunction_SpecificHeat" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_SpecificHeatValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "J/(kgK)", "Btu/(lbF)" ]
          }
        },
        "additionalProperties" : false
      },
      "MaterialLibraryReference" : {
        "type" : "object",
        "properties" : {
          "materialGroupId" : {
            "type" : "string"
          },
          "materialId" : {
            "type" : "string"
          },
          "interpolationParameters" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/InterpolationParameter"
            }
          }
        },
        "additionalProperties" : false
      },
      "InterpolationParameter" : {
        "required" : [ "unit", "value" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string"
          }
        },
        "additionalProperties" : false
      },
      "SolidInitialConditions" : {
        "type" : "object",
        "properties" : {
          "displacement" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunctionInitialConditionWithDomains_Length"
          },
          "velocity" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunctionInitialConditionWithDomains_Speed"
          },
          "acceleration" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunctionInitialConditionWithDomains_Acceleration"
          },
          "stress" : {
            "$ref" : "#/components/schemas/StressInitialConditionDomains"
          },
          "temperature" : {
            "$ref" : "#/components/schemas/DimensionalFunctionInitialConditionDomains_Temperature"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVectorFunctionInitialConditionWithDomains_Length" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Length"
          },
          "subdomains" : {
            "title" : "Subdomains",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SubdomainBasedDimensionalVectorFunctionInitialCondition_Length"
            }
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVectorFunction_Length" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalVectorFunction_LengthValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m", "in" ]
          }
        },
        "additionalProperties" : false
      },
      "ComponentVectorFunction" : {
        "title" : "Component vector function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ComponentVectorFunction",
            "default" : "COMPONENT"
          },
          "x" : {
            "$ref" : "#/components/schemas/OneOf_ComponentVectorFunctionX"
          },
          "y" : {
            "$ref" : "#/components/schemas/OneOf_ComponentVectorFunctionY"
          },
          "z" : {
            "$ref" : "#/components/schemas/OneOf_ComponentVectorFunctionZ"
          }
        },
        "additionalProperties" : false
      },
      "TableDefinedVectorFunction" : {
        "title" : "Table defined vector function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TableDefinedVectorFunction",
            "default" : "TABLE_DEFINED"
          },
          "label" : {
            "title" : "Label",
            "type" : "string",
            "default" : "Table"
          },
          "tableId" : {
            "type" : "string",
            "description" : "The ID of the imported table.",
            "format" : "uuid"
          },
          "resultIndex" : {
            "title" : "Result index",
            "type" : "array",
            "description" : "Indicates which column(s) of the table contains the result values. One-based indexing must be used. For example, set this field to '[2]' if the second column of the table contains the dependent variable values.",
            "items" : {
              "type" : "integer"
            }
          },
          "independentVariables" : {
            "title" : "Independent variables",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/TableFunctionParameter"
            }
          },
          "separator" : {
            "title" : "Separator",
            "type" : "string",
            "description" : "Values in each row are separated by this character. Also known as a delimiter.",
            "default" : ","
          },
          "outOfBounds" : {
            "title" : "Out of bounds",
            "type" : "string",
            "default" : "CLAMP",
            "enum" : [ "CLAMP" ]
          }
        },
        "additionalProperties" : false
      },
      "VariableGroup_X_Y_Z" : {
        "type" : "object",
        "properties" : {
          "X" : {
            "$ref" : "#/components/schemas/Unit_Length"
          },
          "Y" : {
            "$ref" : "#/components/schemas/Unit_Length"
          },
          "Z" : {
            "$ref" : "#/components/schemas/Unit_Length"
          }
        }
      },
      "SubdomainBasedDimensionalVectorFunctionInitialCondition_Length" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "subdomainValue" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Length"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVectorFunctionInitialConditionWithDomains_Speed" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Speed"
          },
          "subdomains" : {
            "title" : "Subdomains",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SubdomainBasedDimensionalVectorFunctionInitialCondition_Speed"
            }
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVectorFunction_Speed" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalVectorFunction_SpeedValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "in/s", "cm/s", "km/h", "mph", "ft/s", "ft/min" ]
          }
        },
        "additionalProperties" : false
      },
      "SubdomainBasedDimensionalVectorFunctionInitialCondition_Speed" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "subdomainValue" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Speed"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVectorFunctionInitialConditionWithDomains_Acceleration" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Acceleration"
          },
          "subdomains" : {
            "title" : "Subdomains",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SubdomainBasedDimensionalVectorFunctionInitialCondition_Acceleration"
            }
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVectorFunction_Acceleration" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalVectorFunction_AccelerationValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "in/s" ]
          }
        },
        "additionalProperties" : false
      },
      "SubdomainBasedDimensionalVectorFunctionInitialCondition_Acceleration" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "subdomainValue" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Acceleration"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "StressInitialConditionDomains" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/StressTensor_Pressure"
          },
          "subdomains" : {
            "title" : "Subdomains",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SubdomainStressInitialCondition"
            }
          }
        },
        "additionalProperties" : false
      },
      "StressTensor_Pressure" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "sigmaXX" : {
            "$ref" : "#/components/schemas/OneOf_StressTensor_PressureSigmaXX"
          },
          "sigmaYY" : {
            "$ref" : "#/components/schemas/OneOf_StressTensor_PressureSigmaYY"
          },
          "sigmaZZ" : {
            "$ref" : "#/components/schemas/OneOf_StressTensor_PressureSigmaZZ"
          },
          "sigmaYZ" : {
            "$ref" : "#/components/schemas/OneOf_StressTensor_PressureSigmaYZ"
          },
          "sigmaXZ" : {
            "$ref" : "#/components/schemas/OneOf_StressTensor_PressureSigmaXZ"
          },
          "sigmaXY" : {
            "$ref" : "#/components/schemas/OneOf_StressTensor_PressureSigmaXY"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "Pa", "lbf/in", "kPa", "MPa", "bar", "mbar", "mH2O" ]
          }
        },
        "additionalProperties" : false
      },
      "SubdomainStressInitialCondition" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "subdomainValue" : {
            "$ref" : "#/components/schemas/StressTensor_Pressure"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalFunctionInitialConditionDomains_Temperature" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Temperature"
          },
          "subdomains" : {
            "title" : "Subdomains",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SubdomainDimensionalFunctionInitialCondition_Temperature"
            }
          }
        },
        "additionalProperties" : false
      },
      "DimensionalFunction_Temperature" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_TemperatureValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "C", "F", "K" ]
          }
        },
        "additionalProperties" : false
      },
      "SubdomainDimensionalFunctionInitialCondition_Temperature" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "subdomainValue" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Temperature"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "BoltPreloadBC" : {
        "title" : "Bolt preload",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<b>Bolt preload</b> boundary condition helps to model pre-stressed bolts in a CAD geometry for structural analysis. Enter a preload <i>force</i> to be assigned to cylindrical faces representing the shank of the bolt. <br><b>Note:</b><ul><li>These faces should be continuous and not be assigned to contact definitions.</li><li>Each bolt gets only one load, if multiple faces for the same bolt are assigned, they get ignored.</li><li>The applied load <b>does not get</b> distributed if multiple bolts are assigned.</li></ul> <img src=\"/spec/resources/help/imgs/bolt_preload_help_text.png\" class=\"helpPopupImage\"/> <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/bolt-preload/' target='_blank'>Learn more</a>.\n\nSchema name: BoltPreloadBC",
            "default" : "BOLT_PRELOAD"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "preload" : {
            "$ref" : "#/components/schemas/ForcePreload"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<b>Bolt preload</b> boundary condition helps to model pre-stressed bolts in a CAD geometry for structural analysis. Enter a preload <i>force</i> to be assigned to cylindrical faces representing the shank of the bolt. <br><b>Note:</b><ul><li>These faces should be continuous and not be assigned to contact definitions.</li><li>Each bolt gets only one load, if multiple faces for the same bolt are assigned, they get ignored.</li><li>The applied load <b>does not get</b> distributed if multiple bolts are assigned.</li></ul> <img src=\"/spec/resources/help/imgs/bolt_preload_help_text.png\" class=\"helpPopupImage\"/> <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/bolt-preload/' target='_blank'>Learn more</a>."
      },
      "ForcePreload" : {
        "title" : "Force",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ForcePreload",
            "default" : "FORCE"
          },
          "force" : {
            "$ref" : "#/components/schemas/Dimensional_Force"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_Force" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "N", "lbf" ]
          }
        },
        "additionalProperties" : false
      },
      "ElasticSupportBC" : {
        "title" : "Elastic support",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>The <b>elastic support</b> constraint can be used to model an <b>elastic foundation</b> between the assigned surfaces and the rigid ground. Additionally it can be used to <b>prevent rigid body motions</b> in a nonlinear analysis. The constraint acts on tension and compression forces and all stiffness values are expressed in the global coordinate system.<br><a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/elastic-support/' target'blank'>Learn more</a>.</p>\n\nSchema name: ElasticSupportBC",
            "default" : "ELASTIC_SUPPORT"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "springStiffness" : {
            "$ref" : "#/components/schemas/OneOf_ElasticSupportBCSpringStiffness"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>The <b>elastic support</b> constraint can be used to model an <b>elastic foundation</b> between the assigned surfaces and the rigid ground. Additionally it can be used to <b>prevent rigid body motions</b> in a nonlinear analysis. The constraint acts on tension and compression forces and all stiffness values are expressed in the global coordinate system.<br><a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/elastic-support/' target'blank'>Learn more</a>.</p>"
      },
      "IsotropicSpringStiffness" : {
        "title" : "Isotropic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: IsotropicSpringStiffness",
            "default" : "ISOTROPIC"
          },
          "stiffnessDefinition" : {
            "$ref" : "#/components/schemas/OneOf_IsotropicSpringStiffnessStiffnessDefinition"
          }
        },
        "additionalProperties" : false
      },
      "TotalIsotropicStiffnessDefinition" : {
        "title" : "Total",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TotalIsotropicStiffnessDefinition",
            "default" : "TOTAL_ISOTROPIC"
          },
          "total" : {
            "$ref" : "#/components/schemas/Dimensional_SurfaceTension"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_SurfaceTension" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "N/m", "lbf/in" ]
          }
        },
        "additionalProperties" : false
      },
      "DistributedIsotropicStiffnessDefinition" : {
        "title" : "Distributed",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: DistributedIsotropicStiffnessDefinition",
            "default" : "DISTRIBUTED_ISOTROPIC"
          },
          "distributed" : {
            "$ref" : "#/components/schemas/Dimensional_VolumeForce"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_VolumeForce" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "N/m", "lbf/in" ]
          }
        },
        "additionalProperties" : false
      },
      "OrthotropicSpringStiffness" : {
        "title" : "Orthotropic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: OrthotropicSpringStiffness",
            "default" : "ORTHOTROPIC"
          },
          "stiffnessDefinition" : {
            "$ref" : "#/components/schemas/OneOf_OrthotropicSpringStiffnessStiffnessDefinition"
          }
        },
        "additionalProperties" : false
      },
      "TotalOrthotropicStiffnessDefinition" : {
        "title" : "Total",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TotalOrthotropicStiffnessDefinition",
            "default" : "TOTAL_ORTHOTROPIC"
          },
          "total" : {
            "$ref" : "#/components/schemas/DimensionalVector_SurfaceTension"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVector_SurfaceTension" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/DecimalVector"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "N/m", "lbf/in" ]
          }
        },
        "additionalProperties" : false
      },
      "DistributedOrthotropicStiffnessDefinition" : {
        "title" : "Distributed",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: DistributedOrthotropicStiffnessDefinition",
            "default" : "DISTRIBUTED_ORTHOTROPIC"
          },
          "distributed" : {
            "$ref" : "#/components/schemas/DimensionalVector_VolumeForce"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVector_VolumeForce" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/DecimalVector"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "N/m", "lbf/in" ]
          }
        },
        "additionalProperties" : false
      },
      "FixedSupportBC" : {
        "title" : "Fixed support",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>If a <b>fixed support</b> boundary condition is used, all degrees of freedom of the selected entities are fixed at zero. This constraint is often used to model a fixation to the ground or an undeformable part.<br><a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/fixed-support-constraint-type/' target'blank'>Learn more</a>.</p>\n\nSchema name: FixedSupportBC",
            "default" : "FIXED_SUPPORT"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>If a <b>fixed support</b> boundary condition is used, all degrees of freedom of the selected entities are fixed at zero. This constraint is often used to model a fixation to the ground or an undeformable part.<br><a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/fixed-support-constraint-type/' target'blank'>Learn more</a>.</p>"
      },
      "FixedValueBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This is a boundary condition for the <b>displacement vector</b> variable. You can define prescribed values for the displacement of the assigned groups in every coordinate direction (x,y,z) or leave it unconstrained in order to let the entity move freely. <br /><br />Important remarks: <br /><ul><li>Choose 0 as value in order to fix your selection.</li><li>Do not constrain entities in directions where a load boundary condition is applied.</li><li>Do not constrain entities with multiple Dirichlet boundary conditions in one direction (overconstrained).</li><li>Do not constrain slave entities of <b>Contact Constraints</b> as they are constrained by the master in that direction (overconstrained).</li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/fixed-value-boundary-condition-type/' target='_blank'>Learn more</a>.\n\nSchema name: FixedValueBC",
            "default" : "FIXED_VALUE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "displacement" : {
            "$ref" : "#/components/schemas/DimensionalPartialVectorFunction_Length"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This is a boundary condition for the <b>displacement vector</b> variable. You can define prescribed values for the displacement of the assigned groups in every coordinate direction (x,y,z) or leave it unconstrained in order to let the entity move freely. <br /><br />Important remarks: <br /><ul><li>Choose 0 as value in order to fix your selection.</li><li>Do not constrain entities in directions where a load boundary condition is applied.</li><li>Do not constrain entities with multiple Dirichlet boundary conditions in one direction (overconstrained).</li><li>Do not constrain slave entities of <b>Contact Constraints</b> as they are constrained by the master in that direction (overconstrained).</li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/fixed-value-boundary-condition-type/' target='_blank'>Learn more</a>."
      },
      "DimensionalPartialVectorFunction_Length" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/PartialVectorFunction"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m", "in" ]
          }
        },
        "additionalProperties" : false
      },
      "PartialVectorFunction" : {
        "type" : "object",
        "properties" : {
          "x" : {
            "$ref" : "#/components/schemas/OneOf_PartialVectorFunctionX"
          },
          "y" : {
            "$ref" : "#/components/schemas/OneOf_PartialVectorFunctionY"
          },
          "z" : {
            "$ref" : "#/components/schemas/OneOf_PartialVectorFunctionZ"
          }
        },
        "additionalProperties" : false
      },
      "PrescribedOptionalFunction" : {
        "title" : "Prescribed optional function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PrescribedOptionalFunction",
            "default" : "PRESCRIBED"
          },
          "value" : {
            "$ref" : "#/components/schemas/OneOf_PrescribedOptionalFunctionValue"
          }
        },
        "additionalProperties" : false
      },
      "UnconstrainedOptionalFunction" : {
        "title" : "Unconstrained optional function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: UnconstrainedOptionalFunction",
            "default" : "UNCONSTRAINED"
          }
        },
        "additionalProperties" : false
      },
      "PointMassBC" : {
        "title" : "Point mass",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Define a <b>Point mass</b> boundary condition in order to insert an additional mass on a specific location of the active model.</p>\n\nSchema name: PointMassBC",
            "default" : "POINT_MASS"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "mass" : {
            "$ref" : "#/components/schemas/Dimensional_Mass"
          },
          "massMomentOfInertia" : {
            "$ref" : "#/components/schemas/DimensionalVector_MomentOfInertia"
          },
          "externalPoint" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "deformationBehavior" : {
            "title" : "Deformation behavior",
            "type" : "string",
            "description" : "<p>Choose the deformation behavior of the entity which the point mass is connected to. If <b>deformable</b> is selected, the entity is allowed to deform, selecting <b>undeformable</b> leads to a rigid entity.</p>",
            "default" : "DEFORMABLE",
            "enum" : [ "DEFORMABLE", "UNDEFORMABLE" ]
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Define a <b>Point mass</b> boundary condition in order to insert an additional mass on a specific location of the active model.</p>"
      },
      "Dimensional_Mass" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "kg", "lb" ]
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVector_MomentOfInertia" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/DecimalVector"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "kgm", "lbin" ]
          }
        },
        "additionalProperties" : false
      },
      "RemoteDisplacementLoadBC" : {
        "title" : "Remote displacement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This boundary condition restrains the displacement of a face or edge relative to a specified remote point. Therefore the assignment is connected to the remote point with RBE3 (deformable) or MPC (undeformable) conditions and the defined constraints are applied to the remote point.<br /><br />Important remarks: <br /><ul><li>As the assignments are connected to the remote point, additional constraints on these nodes may lead to overconstrained systems.</li><li>If the number of nodes of the assigment is large (>1000), it is recommended to use the <b>MUMPS</b> or <b>PETSC</b> solver.</li><li>This boundary condition is only valid for small rotations. For large rotations, please use <b>Rotating motion</b> boundary conditions.</li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/remote-displacement/' target='_blank'>Learn more</a>. \n\nSchema name: RemoteDisplacementLoadBC",
            "default" : "REMOTE_DISPLACEMENT_LOAD"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "displacement" : {
            "$ref" : "#/components/schemas/DimensionalPartialVectorFunction_Length"
          },
          "rotation" : {
            "$ref" : "#/components/schemas/DimensionalPartialVectorFunction_Angle"
          },
          "externalPoint" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "deformationBehavior" : {
            "title" : "Deformation behavior",
            "type" : "string",
            "description" : "<p>Choose the deformation behavior of the assigned entity. If <b>deformable</b> is selected, the entity is allowed to deform, selecting <b>undeformable</b> leads to a rigid entity.</p>",
            "default" : "DEFORMABLE",
            "enum" : [ "DEFORMABLE", "UNDEFORMABLE" ]
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This boundary condition restrains the displacement of a face or edge relative to a specified remote point. Therefore the assignment is connected to the remote point with RBE3 (deformable) or MPC (undeformable) conditions and the defined constraints are applied to the remote point.<br /><br />Important remarks: <br /><ul><li>As the assignments are connected to the remote point, additional constraints on these nodes may lead to overconstrained systems.</li><li>If the number of nodes of the assigment is large (>1000), it is recommended to use the <b>MUMPS</b> or <b>PETSC</b> solver.</li><li>This boundary condition is only valid for small rotations. For large rotations, please use <b>Rotating motion</b> boundary conditions.</li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/remote-displacement/' target='_blank'>Learn more</a>. "
      },
      "DimensionalPartialVectorFunction_Angle" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/PartialVectorFunction"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "rad", "" ]
          }
        },
        "additionalProperties" : false
      },
      "RotatingMotionBC" : {
        "title" : "Rotating motion",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>The <b>rotating motion</b> constraint applies a predefined rigid body rotation to the assigned entities. The rotation axis, the base point, and the rotation angle needs to be specified. Each component can be defined with a formula or table input.<br /><br />Important remarks: <br /><ul><li>If a component of the rotation axis is input via formula or table, then ensure that the length of the axis vector is always positive.</li><li>If a continuous, transient rotation is required, then the rotation angle has to be given either as a formula or table value.</li></ul></p><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/rotating-motion/' target='_blank'>Learn more</a>.\n\nSchema name: RotatingMotionBC",
            "default" : "ROTATING_MOTION"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "rotationOrigin" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Length"
          },
          "rotationAxis" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Length"
          },
          "omega" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Angle"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>The <b>rotating motion</b> constraint applies a predefined rigid body rotation to the assigned entities. The rotation axis, the base point, and the rotation angle needs to be specified. Each component can be defined with a formula or table input.<br /><br />Important remarks: <br /><ul><li>If a component of the rotation axis is input via formula or table, then ensure that the length of the axis vector is always positive.</li><li>If a continuous, transient rotation is required, then the rotation angle has to be given either as a formula or table value.</li></ul></p><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/rotating-motion/' target='_blank'>Learn more</a>."
      },
      "DimensionalFunction_Angle" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_AngleValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "rad", "" ]
          }
        },
        "additionalProperties" : false
      },
      "SymmetryPlaneBC" : {
        "title" : "Symmetry plane",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This boundary condition restrains the displacement of a face in its normal direction in order to represent a symmetry plane of the structure. Use this boundary condition to reduce the model size significantly if the geometry and the loading conditions are symmetric.<br /><br />Important remarks: <br /><ul><li>The solver uses linear relations between all three DOFs to constrian the normal movement, thus overcontraint conditions may appear if the edges of the selected faces are constrained by other displacement boundary conditions.</li><li>If the assigned faces are orthogonal to a global coordinate axes, it is recommended to directly specifiy the symmetry conditions with a <b>Fixed value</b> boundary condition.</li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/symmetry/#symmetry-plane-boundary-condition-fea' target='_blank'>Learn more</a>.\n\nSchema name: SymmetryPlaneBC",
            "default" : "SYMMETRY_PLANE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This boundary condition restrains the displacement of a face in its normal direction in order to represent a symmetry plane of the structure. Use this boundary condition to reduce the model size significantly if the geometry and the loading conditions are symmetric.<br /><br />Important remarks: <br /><ul><li>The solver uses linear relations between all three DOFs to constrian the normal movement, thus overcontraint conditions may appear if the edges of the selected faces are constrained by other displacement boundary conditions.</li><li>If the assigned faces are orthogonal to a global coordinate axes, it is recommended to directly specifiy the symmetry conditions with a <b>Fixed value</b> boundary condition.</li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/symmetry/#symmetry-plane-boundary-condition-fea' target='_blank'>Learn more</a>."
      },
      "CentrifugalForceBC" : {
        "title" : "Centrifugal force",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>This is a <b>centrifugal force</b> boundary condition. Each volume element of the selection is loaded with a centrifugal force which is calculated depending on its volume, the density of the assigned material, its distance from the axis of rotation and the defined rotational velocity.<br /><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/centrifugal-force/' target='_blank'>Learn more</a>.</p>\n\nSchema name: CentrifugalForceBC",
            "default" : "CENTRIFUGAL_FORCE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "rotation" : {
            "$ref" : "#/components/schemas/AngularRotation"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>This is a <b>centrifugal force</b> boundary condition. Each volume element of the selection is loaded with a centrifugal force which is calculated depending on its volume, the density of the assigned material, its distance from the axis of rotation and the defined rotational velocity.<br /><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/centrifugal-force/' target='_blank'>Learn more</a>.</p>"
      },
      "AngularRotation" : {
        "title" : "Angular rotation",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AngularRotation",
            "default" : "ANGULAR_ROTATION"
          },
          "rotationCenter" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "rotationAxis" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "angularVelocity" : {
            "$ref" : "#/components/schemas/DimensionalFunction_RotationSpeed"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalFunction_RotationSpeed" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_RotationSpeedValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "rad/s", "/s" ]
          }
        },
        "additionalProperties" : false
      },
      "VariableGroup_F" : {
        "type" : "object",
        "properties" : {
          "F" : {
            "$ref" : "#/components/schemas/Unit_Frequency"
          }
        }
      },
      "Unit_Frequency" : {
        "type" : "object",
        "properties" : {
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/s" ]
          }
        }
      },
      "FollowerPressureBC" : {
        "title" : "Follower pressure",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "In contrast to ordinary pressure, the <b>follower pressure</b> boundary condition is applied normal to the surface of all face elements in the <b>deformed state</b>. This is a nonlinear boundary condition as the update of the geometry is required. In a linear analysis it becomes a simple <b>pressure</b> boundary condition.<br /><br />The following conditions are taken into account: <br /><ul><li>The current deformed state of the surface.</li><li>Any changes in the direction of the normals of assigned entities.</li><li>Changes in the surface area of the assigned faces.</li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/follower-pressure/' target='_blank'>Learn more</a>.\n\nSchema name: FollowerPressureBC",
            "default" : "FOLLOWER_PRESSURE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "pressure" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Pressure"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "In contrast to ordinary pressure, the <b>follower pressure</b> boundary condition is applied normal to the surface of all face elements in the <b>deformed state</b>. This is a nonlinear boundary condition as the update of the geometry is required. In a linear analysis it becomes a simple <b>pressure</b> boundary condition.<br /><br />The following conditions are taken into account: <br /><ul><li>The current deformed state of the surface.</li><li>Any changes in the direction of the normals of assigned entities.</li><li>Changes in the surface area of the assigned faces.</li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/follower-pressure/' target='_blank'>Learn more</a>."
      },
      "ForceLoadBC" : {
        "title" : "Force",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>This is a <b>force</b> boundary condition representing a <b>distributed force on the selection</b>. The total force is defined in the global coordinate system and each element of the assignment is loaded with a surface traction depending on the area of the element.<br /><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/force/' target='_blank'>Learn more</a>.</p>\n\nSchema name: ForceLoadBC",
            "default" : "FORCE_LOAD"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "force" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Force"
          },
          "scaling" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Dimensionless"
          },
          "phaseAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>This is a <b>force</b> boundary condition representing a <b>distributed force on the selection</b>. The total force is defined in the global coordinate system and each element of the assignment is loaded with a surface traction depending on the area of the element.<br /><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/force/' target='_blank'>Learn more</a>.</p>"
      },
      "DimensionalVectorFunction_Force" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalVectorFunction_ForceValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "N", "lbf" ]
          }
        },
        "additionalProperties" : false
      },
      "DimensionalFunction_Dimensionless" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_DimensionlessValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "" ]
          }
        },
        "additionalProperties" : false
      },
      "NodalLoadBC" : {
        "title" : "Nodal load",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This is a <b>force</b> boundary condition representing an equal point force on <b>each node of the assignment</b>. The total force applied on the assignment is calculated as the user defined forces times the number of nodes in the assignment.<br /><br />Important remarks: <br /><ul><li>Currently, it only works on <a href= https://www.simscale.com/docs/simulation-setup/meshing/mesh-upload/' target='_blank'>uploaded meshes</a></li><li>As the total load is depending on the number of nodes, and thus the mesh fineness, it is recommended only for loads on single nodes.</li><li>In most cases point loads are unphysical and distributed loads should be used instead.</li></ul>\n\nSchema name: NodalLoadBC",
            "default" : "NODAL_LOAD"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "force" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Force"
          },
          "scaling" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Dimensionless"
          },
          "phaseAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This is a <b>force</b> boundary condition representing an equal point force on <b>each node of the assignment</b>. The total force applied on the assignment is calculated as the user defined forces times the number of nodes in the assignment.<br /><br />Important remarks: <br /><ul><li>Currently, it only works on <a href= https://www.simscale.com/docs/simulation-setup/meshing/mesh-upload/' target='_blank'>uploaded meshes</a></li><li>As the total load is depending on the number of nodes, and thus the mesh fineness, it is recommended only for loads on single nodes.</li><li>In most cases point loads are unphysical and distributed loads should be used instead.</li></ul>"
      },
      "PressureBC" : {
        "title" : "Pressure",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This is a <b>pressure</b> boundary condition representing a distributed load on the selection. It is applied normal to the surface of all face elements.<br /><br />Important remarks: <br /><ul><li>The applied total force depends on the surface area of the selection.</li><li>The normal direction of the faces is computed only in the undeformed state and not updated for large deformations.</li><li>For transient analyses you may define a <b>time dependent</b> value by uploading a table (csv-file).</li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/pressure/' target='_blank'>Learn more</a>.\n\nSchema name: PressureBC",
            "default" : "PRESSURE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "pressure" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Pressure"
          },
          "phaseAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This is a <b>pressure</b> boundary condition representing a distributed load on the selection. It is applied normal to the surface of all face elements.<br /><br />Important remarks: <br /><ul><li>The applied total force depends on the surface area of the selection.</li><li>The normal direction of the faces is computed only in the undeformed state and not updated for large deformations.</li><li>For transient analyses you may define a <b>time dependent</b> value by uploading a table (csv-file).</li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/pressure/' target='_blank'>Learn more</a>."
      },
      "RemoteForceLoadBC" : {
        "title" : "Remote force",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This is a <b>remote force</b> boundary condition where the load is applied on the assignment via a remote point. Therefore the assignment is connected to the remote point with RBE3 (deformable) or MPC (undeformable) conditions and the defined force is applied to the remote point.<br /><br />Important remarks: <br /><ul><li>The total force will be <b>distributed on the selection</b>.</li><li>As the assignments are connected to the remote point, additional constraints on these nodes may lead to overconstrained systems.</li><li>If the number of nodes of the assignment is large (>1000), it is recommended to use the <b>MUMPS</b> or <b>PETSC</b> solver.</li><li>This boundary condition is only valid for small rotations. </li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/remote-force/' target='_blank'>Learn more</a>.\n\nSchema name: RemoteForceLoadBC",
            "default" : "REMOTE_FORCE_LOAD"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "force" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Force"
          },
          "moment" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Torque"
          },
          "scaling" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Dimensionless"
          },
          "phaseAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "remotePoint" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "deformationBehavior" : {
            "title" : "Deformation behavior",
            "type" : "string",
            "description" : "<p>Choose the deformation behavior of the assigned entity. If <b>deformable</b> is selected, the entitiy is allowed to deform without applying additional stiffness, selecting <b>undeformable</b> leads to a rigid entity.</p>",
            "default" : "DEFORMABLE",
            "enum" : [ "DEFORMABLE", "UNDEFORMABLE" ]
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This is a <b>remote force</b> boundary condition where the load is applied on the assignment via a remote point. Therefore the assignment is connected to the remote point with RBE3 (deformable) or MPC (undeformable) conditions and the defined force is applied to the remote point.<br /><br />Important remarks: <br /><ul><li>The total force will be <b>distributed on the selection</b>.</li><li>As the assignments are connected to the remote point, additional constraints on these nodes may lead to overconstrained systems.</li><li>If the number of nodes of the assignment is large (>1000), it is recommended to use the <b>MUMPS</b> or <b>PETSC</b> solver.</li><li>This boundary condition is only valid for small rotations. </li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/remote-force/' target='_blank'>Learn more</a>."
      },
      "DimensionalVectorFunction_Torque" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalVectorFunction_TorqueValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "Nm", "lbfin" ]
          }
        },
        "additionalProperties" : false
      },
      "SurfaceLoadBC" : {
        "title" : "Surface load",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This is a <b>surface load</b> boundary condition representing a distributed load on the selection. It is applied as surface traction in the global coordinate system.<br /><br />Important remarks: <br /><ul><li>The applied total force depends on the surface area of the selection</li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/surface-load/' target='_blank'>Learn more</a>.\n\nSchema name: SurfaceLoadBC",
            "default" : "SURFACE_LOAD"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "load" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Pressure"
          },
          "scaling" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Dimensionless"
          },
          "phaseAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This is a <b>surface load</b> boundary condition representing a distributed load on the selection. It is applied as surface traction in the global coordinate system.<br /><br />Important remarks: <br /><ul><li>The applied total force depends on the surface area of the selection</li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/surface-load/' target='_blank'>Learn more</a>."
      },
      "DimensionalVectorFunction_Pressure" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalVectorFunction_PressureValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "Pa", "lbf/in", "kPa", "MPa", "bar", "mbar", "mH2O" ]
          }
        },
        "additionalProperties" : false
      },
      "VolumeLoadBC" : {
        "title" : "Volume load",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This is a <b>volume load</b> boundary condition representing a distributed load on the selected volumes applied in the global coordinate system and each element of the assignment is loaded with a volume force depending on the volume of the element.<br /><br />Important remarks: <br /><ul><li>The applied total force depends on the volume of the selection.</li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/volume-load/' target='_blank'>Learn more</a>.\n\nSchema name: VolumeLoadBC",
            "default" : "VOLUME_LOAD"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "load" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_VolumeForce"
          },
          "scaling" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Dimensionless"
          },
          "phaseAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This is a <b>volume load</b> boundary condition representing a distributed load on the selected volumes applied in the global coordinate system and each element of the assignment is loaded with a volume force depending on the volume of the element.<br /><br />Important remarks: <br /><ul><li>The applied total force depends on the volume of the selection.</li></ul><a href= https://www.simscale.com/docs/simulation-setup/boundary-conditions/volume-load/' target='_blank'>Learn more</a>."
      },
      "DimensionalVectorFunction_VolumeForce" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalVectorFunction_VolumeForceValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "N/m", "lbf/in" ]
          }
        },
        "additionalProperties" : false
      },
      "SolidNumerics" : {
        "type" : "object",
        "properties" : {
          "solver" : {
            "$ref" : "#/components/schemas/OneOf_SolidNumericsSolver"
          },
          "solveModel" : {
            "$ref" : "#/components/schemas/SolverModel"
          },
          "eigenSolver" : {
            "$ref" : "#/components/schemas/OneOf_SolidNumericsEigenSolver"
          },
          "calculateFrequency" : {
            "$ref" : "#/components/schemas/CalculateFrequency"
          },
          "eigenMode" : {
            "$ref" : "#/components/schemas/EigenModeVerification"
          },
          "mechanicalTimeIntegrationType" : {
            "$ref" : "#/components/schemas/OneOf_SolidNumericsMechanicalTimeIntegrationType"
          },
          "mechanicalResolutionType" : {
            "$ref" : "#/components/schemas/OneOf_SolidNumericsMechanicalResolutionType"
          },
          "mechanicalLineSearch" : {
            "$ref" : "#/components/schemas/OneOf_SolidNumericsMechanicalLineSearch"
          },
          "thermalTimeIntegrationType" : {
            "$ref" : "#/components/schemas/ThetaMethodTimeIntegrationType"
          },
          "thermalResolutionType" : {
            "$ref" : "#/components/schemas/OneOf_SolidNumericsThermalResolutionType"
          },
          "thermalLineSearch" : {
            "$ref" : "#/components/schemas/OneOf_SolidNumericsThermalLineSearch"
          }
        },
        "additionalProperties" : false
      },
      "LDLTSolverV33" : {
        "title" : "LDLT",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose a linear equation system solver for your calculation:</p><ul><li><p><b>Multfront</b> is a direct solver of the multifrontal type. It is easy to set up and behaves well for most problems.</p></ul><ul><li><p><b>MUMPS</b> is a general purpose direct solver of the multifrontal type. It provides a lot of parameter settings to allow the best fitting to your problems needs.</p></ul><ul><li><p><b>LDLT</b> is a direct solver which uses a Gaussian Algortihm. It is comparatively slow for big problems.</p></ul><ul><li><p><b>PETSC</b> is an iterative solver specially designed to deal with large systems. It scales very effectively in parallel and is the best choice for large problems.</p></ul><ul><li><p><b>GCPC</b> is an iterative solver of the pre-conditioned conjugate gradient type. It scales well in parallel and is also usable for large problems.</p></ul>\n\nSchema name: LDLTSolverV33",
            "default" : "LDLT_V33"
          },
          "forceSymmetric" : {
            "title" : "Force symmetric",
            "type" : "boolean",
            "description" : "Choose if you want to enforce a symmetric matrix.",
            "default" : true,
            "x-showWhen" : [ "type == DYNAMIC_ANALYSIS", "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == HEAT_TRANSFER && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true" ]
          },
          "precisionSingularityDetection" : {
            "title" : "Precision singularity detection",
            "type" : "integer",
            "description" : "Define the precision value for the detection of a singular matrix.",
            "default" : 8
          },
          "stopIfSingular" : {
            "title" : "Stop if singular",
            "type" : "boolean",
            "description" : "Choose if the calculation should be stopped if the problem turns out to be singular.",
            "default" : true
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose a linear equation system solver for your calculation:</p><ul><li><p><b>Multfront</b> is a direct solver of the multifrontal type. It is easy to set up and behaves well for most problems.</p></ul><ul><li><p><b>MUMPS</b> is a general purpose direct solver of the multifrontal type. It provides a lot of parameter settings to allow the best fitting to your problems needs.</p></ul><ul><li><p><b>LDLT</b> is a direct solver which uses a Gaussian Algortihm. It is comparatively slow for big problems.</p></ul><ul><li><p><b>PETSC</b> is an iterative solver specially designed to deal with large systems. It scales very effectively in parallel and is the best choice for large problems.</p></ul><ul><li><p><b>GCPC</b> is an iterative solver of the pre-conditioned conjugate gradient type. It scales well in parallel and is also usable for large problems.</p></ul>"
      },
      "MUMPSSolver" : {
        "title" : "MUMPS",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose a linear equation system solver for your calculation:</p><ul><li><p><b>Multfront</b> is a direct solver of the multifrontal type. It is easy to set up and behaves well for most problems.</p></ul><ul><li><p><b>MUMPS</b> is a general purpose direct solver of the multifrontal type. It provides a lot of parameter settings to allow the best fitting to your problems needs.</p></ul><ul><li><p><b>LDLT</b> is a direct solver which uses a Gaussian Algortihm. It is comparatively slow for big problems.</p></ul><ul><li><p><b>PETSC</b> is an iterative solver specially designed to deal with large systems. It scales very effectively in parallel and is the best choice for large problems.</p></ul><ul><li><p><b>GCPC</b> is an iterative solver of the pre-conditioned conjugate gradient type. It scales well in parallel and is also usable for large problems.</p></ul>\n\nSchema name: MUMPSSolver",
            "default" : "MUMPS"
          },
          "forceSymmetric" : {
            "title" : "Force symmetric",
            "type" : "boolean",
            "description" : "Choose if you want to enforce a symmetric matrix.",
            "default" : false,
            "x-showWhen" : [ "type == DYNAMIC_ANALYSIS", "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == HEAT_TRANSFER && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true" ]
          },
          "precisionSingularityDetection" : {
            "title" : "Precision singularity detection",
            "type" : "integer",
            "description" : "Define the precision value for the detection of a singular matrix.",
            "default" : 8
          },
          "stopIfSingular" : {
            "title" : "Stop if singular",
            "type" : "boolean",
            "description" : "Choose if the calculation should be stopped if the problem turns out to be singular.",
            "default" : true
          },
          "matrixType" : {
            "title" : "Matrix type",
            "type" : "string",
            "description" : "<p>Choose the type of your system matrix by directly selecting the appropriate type or using the <b>automatic detection</b>. With the selection <b>automatic detection</b> the matrix type <b>symmetric positive indefinite</b> is selected if a symmetric system matrix is detected, and <b>asymmetric</b> otherwise.",
            "default" : "AUTOMATIC_DETECTION",
            "enum" : [ "ASYMMETRIC", "AUTOMATIC_DETECTION", "SYMMETRIC_POSITIVE_INDEFINITE" ]
          },
          "memoryPercentageForPivoting" : {
            "title" : "Memory percentage for pivoting",
            "type" : "number",
            "description" : "Define how much additional memory should be reserved for the pivoting operations. If MUMPS estimates that the necessary space for factorising the matrix would be 100, choosing a value of 20 would mean that MUMPS allocates a memory space of 120.",
            "default" : 20
          },
          "linearSystemRelativeResidual" : {
            "title" : "Linear system relative residual",
            "type" : "number",
            "description" : "Set the maximum allowable numerical error in solving the linear equation system. Use -1 if you do not wish to carry out a check on the solution error (not recommended).",
            "default" : 1.0E-5,
            "x-showWhen" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == false", "type == HEAT_TRANSFER && nonLinearAnalysis == false", "type == THERMAL_MECHANICAL && nonLinearAnalysis == false" ]
          },
          "matrixFilteringThreshold" : {
            "title" : "Matrix filtering threshold",
            "type" : "number",
            "description" : "This parameter allows a filtration of the matrix entries that are saved and possibly passed to the nonlinear algorithm (Newton) and is similar to a relaxation mechanism. If the given threshold value is strictly positive, MUMPS only saves the matrix entries that satisfy the following condition: |K<sub>ij</sub>| value*(|K<sub>ii</sub>|+|K<sub>jj</sub>|). Thus using this functionality might save computation time as well as memory consumption, but the effects strongly depend on the given value and is only advised for the experienced user.",
            "default" : -1,
            "x-showWhen" : [ "type == DYNAMIC_ANALYSIS", "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == HEAT_TRANSFER && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true" ]
          },
          "singlePrecision" : {
            "title" : "Single precision",
            "type" : "boolean",
            "description" : "If this option is activated the matrix factorisation is done with single precision and thus a reduction in memory consumption (often about 50%) and computation time is gained if the problem is well conditioned. If the problem is ill-conditioned one risks that in a nonlinear computation the newton algorithm fails to converge.",
            "default" : false,
            "x-showWhen" : [ "type == DYNAMIC_ANALYSIS", "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == HEAT_TRANSFER && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true" ]
          },
          "preprocessing" : {
            "title" : "Preprocessing",
            "type" : "boolean",
            "description" : "If this option is activated MUMPS performs a pre-processing on order to identify the best parameter setting for some internal parameters adapted to the current problem.",
            "default" : true
          },
          "renumberingMethod" : {
            "title" : "Renumbering method",
            "type" : "string",
            "description" : "Choose the renumbering method for the system matrix entries. The choice of the renumbering method has a big impact on the memory consumption and the solution time. Currently supported are:<ul><li><p><b>SCOTCH</b> is a powerful renumbering tool, suited for most scenarios and the standard choice for MUMPS.</p></ul><ul><li><p><b>PORD</b> is a renumbering tool that comes with MUMPS.</p></ul><ul><li><p><b>AMD</b> uses the <i>Approximate Minimum Degree</i> method.</p></ul><ul><li><p><b>AMF</b> uses the <i>Approximate Minimum Fill</i> method.</p></ul><ul><li><p><b>QAMD</b> is a variant of AMD with automatic detection of quasi-dense matrix lines.</p></ul>If <b>automatic</b> is selected the user let MUMPS choose the renumbering tool. The methods AMD, AMF and QAMD are generally inferior to the more sophisticated methods SCOTCH and PORD but may be a better choice in some cases.",
            "enum" : [ "AMD", "SCOTCH", "AMF", "PORD", "QAMD", "AUTOMATIC" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "type in [HARMONIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL,STATIC_ANALYSIS,DYNAMIC_ANALYSIS,THERMAL_MECHANICAL]" ],
              "default" : "SCOTCH"
            }, {
              "when" : [ "type == FREQUENCY_ANALYSIS" ],
              "default" : "QAMD"
            } ]
          },
          "postprocessing" : {
            "title" : "Postprocessing",
            "type" : "string",
            "description" : "With this option the user can control the iterative refinement of the linear system solution. This option only has an effect if the value of the <b> linear system relative residual</b> given by the user is greater than zero, otherwise it is ignored. If it is <b>activate</b> MUMPS carries out at least one additional iteration of the linear system resolution and at most 10 iterations. The process is stopped if the residual isn't reduced by at least a factor of 5. If this option is set to be <b>inactive</b> no additional iteration is done and if <b>automatic</b> is chosen MUMPS automatically decides if additional iterations should be done and the maximum number of iterations is set to 4.",
            "default" : "ACTIVE",
            "enum" : [ "INACTIVE", "ACTIVE", "AUTOMATIC" ]
          },
          "distributedMatrixStorage" : {
            "title" : "Distributed matrix storage",
            "type" : "boolean",
            "description" : "Choose this parameter as <b>true</b> to ensure that the system matrix saving is distributed among the processors of the computation. If multiple cores are used only the relevant part for each core is saved. If it is set to false the whole matrix is saved for each processor. This parameter has currently no effect for <i>Harmonic</i> simulations.",
            "default" : true,
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,THERMAL_MECHANICAL]" ]
          },
          "memoryManagement" : {
            "title" : "Memory management",
            "type" : "string",
            "description" : "Choose the memory managment priority of the MUMPS solver. If <b>in-core</b> is used the memory managment is optimized with respect to the calculation time by saving all objects in the RAM. If <b>out-of-core</b> is chosen, the memory managment is optimized for a minimal RAM usage. If <b>automatic</b> is selected, MUMPS choses automatically a reasonable memory managment mode. The option <b>memory demand evaluation</b> is helpful to estimate the RAM consumption. This estimate is written to the solver log file. In this case the solution process aborts after the memory usage is estimated, allowing the user to start a new run with the best settings.",
            "default" : "AUTOMATIC",
            "enum" : [ "AUTOMATIC", "IN_CORE", "MEMORY_DEMAND_EVALUATION", "OUT_OF_CORE" ]
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose a linear equation system solver for your calculation:</p><ul><li><p><b>Multfront</b> is a direct solver of the multifrontal type. It is easy to set up and behaves well for most problems.</p></ul><ul><li><p><b>MUMPS</b> is a general purpose direct solver of the multifrontal type. It provides a lot of parameter settings to allow the best fitting to your problems needs.</p></ul><ul><li><p><b>LDLT</b> is a direct solver which uses a Gaussian Algortihm. It is comparatively slow for big problems.</p></ul><ul><li><p><b>PETSC</b> is an iterative solver specially designed to deal with large systems. It scales very effectively in parallel and is the best choice for large problems.</p></ul><ul><li><p><b>GCPC</b> is an iterative solver of the pre-conditioned conjugate gradient type. It scales well in parallel and is also usable for large problems.</p></ul>"
      },
      "MultifrontalSolver" : {
        "title" : "Multifrontal",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose a linear equation system solver for your calculation:</p><ul><li><p><b>Multfront</b> is a direct solver of the multifrontal type. It is easy to set up and behaves well for most problems.</p></ul><ul><li><p><b>MUMPS</b> is a general purpose direct solver of the multifrontal type. It provides a lot of parameter settings to allow the best fitting to your problems needs.</p></ul><ul><li><p><b>LDLT</b> is a direct solver which uses a Gaussian Algortihm. It is comparatively slow for big problems.</p></ul><ul><li><p><b>PETSC</b> is an iterative solver specially designed to deal with large systems. It scales very effectively in parallel and is the best choice for large problems.</p></ul><ul><li><p><b>GCPC</b> is an iterative solver of the pre-conditioned conjugate gradient type. It scales well in parallel and is also usable for large problems.</p></ul>\n\nSchema name: MultifrontalSolver",
            "default" : "MULTIFRONT"
          },
          "renumberingMethod" : {
            "title" : "Renumbering method",
            "type" : "string",
            "description" : "Choose a renumbering method for the solution process.<br/>For large models around and above 50000 degrees of freedom you should consider using MDA.",
            "default" : "MDA",
            "enum" : [ "MDA", "MD" ]
          },
          "forceSymmetric" : {
            "title" : "Force symmetric",
            "type" : "boolean",
            "description" : "Choose if you want to enforce a symmetric matrix.",
            "default" : false,
            "x-showWhen" : [ "type == DYNAMIC_ANALYSIS", "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == HEAT_TRANSFER && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true" ]
          },
          "precisionSingularityDetection" : {
            "title" : "Precision singularity detection",
            "type" : "integer",
            "description" : "Define the precision value for the detection of a singular matrix.",
            "default" : 8
          },
          "stopIfSingular" : {
            "title" : "Stop if singular",
            "type" : "boolean",
            "description" : "Choose if the calculation should be stopped if the problem turns out to be singular.",
            "default" : true
          },
          "eliminateLagrangeMultipliers" : {
            "title" : "Eliminate lagrange multipliers",
            "type" : "boolean",
            "description" : "This option makes it possible to eliminate the Lagrange Multipliers which are introduced by generalized boundary conditions like bonded contact, remote boundary conditions and symmetry conditions. If activated, this option removes the Lagrange Multipliers which leads to a reduction of the total number of unknowns and can increase the robustness of iterative solvers.",
            "default" : false
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose a linear equation system solver for your calculation:</p><ul><li><p><b>Multfront</b> is a direct solver of the multifrontal type. It is easy to set up and behaves well for most problems.</p></ul><ul><li><p><b>MUMPS</b> is a general purpose direct solver of the multifrontal type. It provides a lot of parameter settings to allow the best fitting to your problems needs.</p></ul><ul><li><p><b>LDLT</b> is a direct solver which uses a Gaussian Algortihm. It is comparatively slow for big problems.</p></ul><ul><li><p><b>PETSC</b> is an iterative solver specially designed to deal with large systems. It scales very effectively in parallel and is the best choice for large problems.</p></ul><ul><li><p><b>GCPC</b> is an iterative solver of the pre-conditioned conjugate gradient type. It scales well in parallel and is also usable for large problems.</p></ul>"
      },
      "PETSCSolver" : {
        "title" : "PETSC",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose a linear equation system solver for your calculation:</p><ul><li><p><b>Multfront</b> is a direct solver of the multifrontal type. It is easy to set up and behaves well for most problems.</p></ul><ul><li><p><b>MUMPS</b> is a general purpose direct solver of the multifrontal type. It provides a lot of parameter settings to allow the best fitting to your problems needs.</p></ul><ul><li><p><b>LDLT</b> is a direct solver which uses a Gaussian Algortihm. It is comparatively slow for big problems.</p></ul><ul><li><p><b>PETSC</b> is an iterative solver specially designed to deal with large systems. It scales very effectively in parallel and is the best choice for large problems.</p></ul><ul><li><p><b>GCPC</b> is an iterative solver of the pre-conditioned conjugate gradient type. It scales well in parallel and is also usable for large problems.</p></ul>\n\nSchema name: PETSCSolver",
            "default" : "PETSC"
          },
          "forceSymmetric" : {
            "title" : "Force symmetric",
            "type" : "boolean",
            "description" : "Choose if you want to enforce a symmetric matrix.",
            "default" : false,
            "x-showWhen" : [ "type == DYNAMIC_ANALYSIS", "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == HEAT_TRANSFER && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true" ]
          },
          "algorithm" : {
            "title" : "Algorithm",
            "type" : "string",
            "description" : "Choose the iterative solver method: <ul><li><p><b>GMRES</b>: <i>Minimal Generalised RESidual</i>, best compromise between robustness and computational speed.</p></ul><ul><li><p><b>CG</b>: <i>Conjugate Gradient</i>, only useful for symmetric matrices</p></ul><ul><li><p><b>CR</b>: <i>Conjugate Residual</i>, only useful for symmetric matrices</p></ul><ul><li><p><b>GCR</b>: <i>Generalised Conjugate Residual</i>, treats general matrices</p></ul>All available methods are of <i>Krylov</i> type.",
            "enum" : [ "CG", "CR", "GCR", "GMRES" ],
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL]" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "type == STATIC_ANALYSIS" ],
              "default" : "CG"
            }, {
              "when" : [ "type in [DYNAMIC_ANALYSIS,HEAT_TRANSFER]" ],
              "default" : "GMRES"
            }, {
              "when" : [ "type == THERMAL_MECHANICAL && inertiaEffect == DYNAMIC" ],
              "default" : "GMRES"
            }, {
              "when" : [ "type == THERMAL_MECHANICAL && inertiaEffect == STATIC" ],
              "default" : "CG"
            } ]
          },
          "preconditioner" : {
            "$ref" : "#/components/schemas/OneOf_PETSCSolverPreconditioner"
          },
          "maxIterations" : {
            "title" : "Max iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "Set the maximum number of iterations for the iterative solver. If set to 0 PETSC sets an estimate of the maximum number of iterations.",
            "default" : 0,
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL]" ]
          },
          "convergenceThreshold" : {
            "title" : "Convergence threshold",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "Set the threshold value for convergence detection for the relative convergence criteria.",
            "default" : 1.0E-5,
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL]" ]
          },
          "distributedMatrixStorage" : {
            "title" : "Distributed matrix storage",
            "type" : "boolean",
            "description" : "Choose this parameter as <b>true</b> to ensure that the system matrix saving is distributed among the processors of the computation. If multiple cores are used only the relevant part for each core is saved. If it is set to false the whole matrix is saved for each processor.",
            "default" : true,
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,THERMAL_MECHANICAL]" ]
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose a linear equation system solver for your calculation:</p><ul><li><p><b>Multfront</b> is a direct solver of the multifrontal type. It is easy to set up and behaves well for most problems.</p></ul><ul><li><p><b>MUMPS</b> is a general purpose direct solver of the multifrontal type. It provides a lot of parameter settings to allow the best fitting to your problems needs.</p></ul><ul><li><p><b>LDLT</b> is a direct solver which uses a Gaussian Algortihm. It is comparatively slow for big problems.</p></ul><ul><li><p><b>PETSC</b> is an iterative solver specially designed to deal with large systems. It scales very effectively in parallel and is the best choice for large problems.</p></ul><ul><li><p><b>GCPC</b> is an iterative solver of the pre-conditioned conjugate gradient type. It scales well in parallel and is also usable for large problems.</p></ul>"
      },
      "MUMPSPreconditoner" : {
        "title" : "MUMPS LDLT",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: MUMPSPreconditoner",
            "default" : "MUMPS_LDLT"
          },
          "actualisationRate" : {
            "title" : "Update rate",
            "type" : "integer",
            "description" : "Set the reactualisation intervall for the preconditioner matrix P. If this value is set to 30 the preconditioner is recomputed just every 30th iteration. This preconditioner is computionally more expensive than the incomplete LDLT factorization but nearer to the exact solution. This setting makes it possible to save computation time by taking advantage of this fact.",
            "default" : 30
          },
          "memoryPercentageForPivoting" : {
            "title" : "Memory percentage for pivoting",
            "type" : "number",
            "description" : "Define how much additional memory should be reserved for the pivoting operations. If MUMPS estimates that the necessary space for factorising the matrix would be 100, choosing a value of 20 would mean that MUMPS allocates a memory space of 120.",
            "default" : 20
          }
        },
        "additionalProperties" : false
      },
      "IncompletePreconditionerV33" : {
        "title" : "Incomplete LDLT",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: IncompletePreconditionerV33",
            "default" : "INCOMPLETE_LDLT_V33"
          },
          "matrixCompleteness" : {
            "title" : "Matrix completeness",
            "type" : "integer",
            "description" : "Set the level of completeness for the incomplete Cholesky decomposition. The larger this value is, the better the preconditioning Matrix P approximates K<sup>-1</sup>, but also the memory usage and computation time increase. If the solution does not converge or uses a lot of iterations it could help to increase this parameter.",
            "default" : 0
          },
          "preconditionerMatrixGrowth" : {
            "title" : "Preconditioner matrix growth",
            "type" : "number",
            "description" : "Set the growth rate of the filling for the incomplete decomposition matrix. If this parameter is set to 1.0 PETSc estimates the matrix storage size from the first level of completeness. If this estimate is too low, PETSC increases the allocated memory on the fly, but this is more expensive.",
            "default" : 1,
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL] && 2/type == PETSC" ]
          }
        },
        "additionalProperties" : false
      },
      "JacobiPreconditioner" : {
        "title" : "Jacobi",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: JacobiPreconditioner",
            "default" : "JACOBI"
          },
          "renumberingMethod" : {
            "title" : "Renumbering method",
            "type" : "string",
            "description" : "Choose the renumbering method for the system matrix entries:<ul><li><p><b>RCMK</b> uses the algorithm of <i>Reverse Cuthill-MacKee</i> for the renumbering. It often effectively reduces the matrig storage space and the matrix factorization time.</p></ul><ul><li><p>When <b>inactive</b> is selected no renumbering is done. This option should only be chosen for testing purposes.</p></ul>",
            "default" : "INACTIVE",
            "enum" : [ "RCMK", "INACTIVE" ]
          }
        },
        "additionalProperties" : false
      },
      "SorPreconditioner" : {
        "title" : "SOR",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SorPreconditioner",
            "default" : "SOR"
          },
          "renumberingMethod" : {
            "title" : "Renumbering method",
            "type" : "string",
            "description" : "Choose the renumbering method for the system matrix entries:<ul><li><p><b>RCMK</b> uses the algorithm of <i>Reverse Cuthill-MacKee</i> for the renumbering. It often effectively reduces the matrig storage space and the matrix factorization time.</p></ul><ul><li><p>When <b>inactive</b> is selected no renumbering is done. This option should only be chosen for testing purposes.</p></ul>",
            "default" : "INACTIVE",
            "enum" : [ "RCMK", "INACTIVE" ]
          }
        },
        "additionalProperties" : false
      },
      "InactivePreconditioner" : {
        "title" : "Inactive",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: InactivePreconditioner",
            "default" : "INACTIVE"
          },
          "renumberingMethod" : {
            "title" : "Renumbering method",
            "type" : "string",
            "description" : "Choose the renumbering method for the system matrix entries:<ul><li><p><b>RCMK</b> uses the algorithm of <i>Reverse Cuthill-MacKee</i> for the renumbering. It often effectively reduces the matrig storage space and the matrix factorization time.</p></ul><ul><li><p>When <b>inactive</b> is selected no renumbering is done. This option should only be chosen for testing purposes.</p></ul>",
            "default" : "INACTIVE",
            "enum" : [ "RCMK", "INACTIVE" ]
          }
        },
        "additionalProperties" : false
      },
      "SolverModel" : {
        "type" : "object",
        "properties" : { },
        "additionalProperties" : false
      },
      "IRAMSorensen" : {
        "title" : "IRAM - Sorensen",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: IRAMSorensen",
            "default" : "SORENSEN"
          },
          "precSoren" : {
            "title" : "Sorensen precision",
            "type" : "number",
            "default" : 0
          },
          "nmaxIterSoren" : {
            "title" : "Max number of iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 20
          }
        },
        "additionalProperties" : false
      },
      "Lanczos" : {
        "title" : "Lanczos",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: Lanczos",
            "default" : "TRI_DIAG"
          },
          "precOrtho" : {
            "title" : "Orthogonality precision",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 1.0E-12
          },
          "nmaxIterOrtho" : {
            "title" : "Max Orthogonality iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 5
          },
          "precLanczos" : {
            "title" : "Lanczos precision",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 1.0E-8
          },
          "maxIterQR" : {
            "title" : "Max QR iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 30
          },
          "modeRigid" : {
            "title" : "Rigid Body Modes Detection",
            "type" : "boolean",
            "default" : true
          }
        },
        "additionalProperties" : false
      },
      "BatheWilson" : {
        "title" : "Bathe - Wilson",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: BatheWilson",
            "default" : "JACOBI"
          },
          "precBathe" : {
            "title" : "Bathe precision",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 1.0E-10
          },
          "nmaxIterBathe" : {
            "title" : "Max Bathe iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 40
          },
          "precJacobi" : {
            "title" : "Jacobi precision",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.01
          },
          "maxIterJacobi" : {
            "title" : "Max Jacobi iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 12
          }
        },
        "additionalProperties" : false
      },
      "QZ" : {
        "title" : "QZ",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: QZ",
            "default" : "QZ"
          },
          "typeQZ" : {
            "title" : "Type",
            "type" : "string",
            "default" : "QZ_SIMPLE",
            "enum" : [ "QZ_SIMPLE", "QZ_EQUI", "QZ_QR" ]
          }
        },
        "additionalProperties" : false
      },
      "CalculateFrequency" : {
        "type" : "object",
        "properties" : {
          "precShift" : {
            "title" : "Shift precision",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.05
          },
          "maxIterShift" : {
            "title" : "Max shift iterations",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 3
          },
          "thresholdFrequency" : {
            "title" : "Uniqueness threshold",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.01
          }
        },
        "additionalProperties" : false
      },
      "EigenModeVerification" : {
        "type" : "object",
        "properties" : {
          "stopError" : {
            "title" : "Stop on verification error",
            "type" : "boolean",
            "default" : false
          },
          "threshold" : {
            "title" : "Verification threshold",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 1.0E-6
          },
          "precisionShift" : {
            "title" : "Shift precision",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.05
          }
        },
        "additionalProperties" : false
      },
      "ImplicitTimeIntegrationType" : {
        "title" : "Implicit",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose the time integration scheme type</p><br /><br />Important remarks:<br /><ul><li>Choose <b>implicit</b> if the problem is static or dynamic but not so complex. Implicit analysis takes more solution time but can solve the problem easily with larger timesteps. Therefore, it is always recommended to use implicit time integration scheme. </li><i>Choose <b>explicit</b> if the problem is only dynamic and highly complex. Explicit analysis takes less solution time but also needs more refined (small) timesteps to solve the problem. Therefore, in most of the cases it's not recommended due to convergence problems. </i></ul> \n\nSchema name: ImplicitTimeIntegrationType",
            "default" : "IMPLICIT"
          },
          "scheme" : {
            "$ref" : "#/components/schemas/OneOf_ImplicitTimeIntegrationTypeScheme"
          },
          "schemeFormulation" : {
            "title" : "Scheme formulation",
            "type" : "string",
            "description" : "<p>Choose the primary variable for the time integration scheme.</p>",
            "default" : "DISPLACEMENT",
            "enum" : [ "DISPLACEMENT" ]
          },
          "massMatrixShift" : {
            "title" : "Mass matrix shift",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>This parameter c<sub>K</sub> allows the shifting of the mass matrix with the stiffness matrix multiplied by c<sub>K</sub>: <b>M</b><sup>'</sup>=<b>M</b> + c<sub>K</sub>*<b>K</b>. This makes it possible to strongly improve convergence in dynamics with implicit time scheme by imposing a cut-off frequency inversely proportional to the value of c<sub>K</sub> (at the cost of a light distortion of all the eigen frequencies of the system).</p>",
            "default" : 0
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose the time integration scheme type</p><br /><br />Important remarks:<br /><ul><li>Choose <b>implicit</b> if the problem is static or dynamic but not so complex. Implicit analysis takes more solution time but can solve the problem easily with larger timesteps. Therefore, it is always recommended to use implicit time integration scheme. </li><i>Choose <b>explicit</b> if the problem is only dynamic and highly complex. Explicit analysis takes less solution time but also needs more refined (small) timesteps to solve the problem. Therefore, in most of the cases it's not recommended due to convergence problems. </i></ul> "
      },
      "HhtTimeIntegrationScheme" : {
        "title" : "Hilber-Hughes-Taylor (HHT)",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: HhtTimeIntegrationScheme",
            "default" : "HHT"
          },
          "alpha" : {
            "title" : "() Alpha",
            "type" : "number",
            "description" : "The parameter <b>&alpha;</b> is given by a negative value. The larger |<b>&alpha;</b>| is, the more numerical damping is induced.",
            "default" : -0.1
          },
          "method" : {
            "title" : "Method",
            "type" : "string",
            "description" : "Choose the mode of the HHT method. Compared to the <b>average acceleration</b> scheme the induced numerical damping of the <b>alpha method</b> is more selective: it is weaker for low frequencies and it will increase with the frequencies.",
            "default" : "ALPHA_METHOD",
            "enum" : [ "AVERAGE_ACCELERATION", "ALPHA_METHOD" ]
          }
        },
        "additionalProperties" : false
      },
      "NewmarkTimeIntegrationScheme" : {
        "title" : "Newmark",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NewmarkTimeIntegrationScheme",
            "default" : "NEWMARK"
          },
          "beta" : {
            "title" : "() Beta",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>The choice of the values for the parameters <b>&alpha;</b> and <b>&beta;</b> influences the stability, accuracy and numerical damping of the <i>Newmark Sheme</i>.</v>",
            "default" : 0.25
          },
          "gamma" : {
            "title" : "() Gamma",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>The choice of the values for the parameters <b>&alpha;</b> and <b>&beta;</b> influences the stability, accuracy and numerical damping of the <i>Newmark Sheme</i>.</v>",
            "default" : 0.5
          }
        },
        "additionalProperties" : false
      },
      "ExplicitTimeIntegrationType" : {
        "title" : "Explicit",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose the time integration scheme type</p><br /><br />Important remarks:<br /><ul><li>Choose <b>implicit</b> if the problem is static or dynamic but not so complex. Implicit analysis takes more solution time but can solve the problem easily with larger timesteps. Therefore, it is always recommended to use implicit time integration scheme. </li><i>Choose <b>explicit</b> if the problem is only dynamic and highly complex. Explicit analysis takes less solution time but also needs more refined (small) timesteps to solve the problem. Therefore, in most of the cases it's not recommended due to convergence problems. </i></ul> \n\nSchema name: ExplicitTimeIntegrationType",
            "default" : "EXPLICIT"
          },
          "scheme" : {
            "$ref" : "#/components/schemas/OneOf_ExplicitTimeIntegrationTypeScheme"
          },
          "schemeFormulation" : {
            "title" : "Scheme formulation",
            "type" : "string",
            "description" : "<p>Choose the primary variable for the time integration scheme.</p>",
            "default" : "ACCELERATION",
            "enum" : [ "ACCELERATION" ]
          },
          "stopOnCFLCriterion" : {
            "title" : "Stop on CFL criterion",
            "type" : "boolean",
            "description" : "<p>If activated the simulation run is stopped when at some point the Courant-Friedrichs-Lewy (CFL) condition is violated.</p>",
            "default" : true
          },
          "massMatrixShift" : {
            "title" : "Mass matrix shift",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>This parameter c<sub>K</sub> allows the shifting of the mass matrix with the stiffness matrix multiplied by c<sub>K</sub>: <b>M</b><sup>'</sup>=<b>M</b> + c<sub>K</sub>*<b>K</b>. This makes it possible to strongly improve convergence in dynamics with implicit time scheme by imposing a cut-off frequency inversely proportional to the value of c<sub>K</sub> (at the cost of a light distortion of all the eigen frequencies of the system).</p>",
            "default" : 0
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose the time integration scheme type</p><br /><br />Important remarks:<br /><ul><li>Choose <b>implicit</b> if the problem is static or dynamic but not so complex. Implicit analysis takes more solution time but can solve the problem easily with larger timesteps. Therefore, it is always recommended to use implicit time integration scheme. </li><i>Choose <b>explicit</b> if the problem is only dynamic and highly complex. Explicit analysis takes less solution time but also needs more refined (small) timesteps to solve the problem. Therefore, in most of the cases it's not recommended due to convergence problems. </i></ul> "
      },
      "CentralDiffTimeIntegrationScheme" : {
        "title" : "Central differences",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CentralDiffTimeIntegrationScheme",
            "default" : "CENTRAL_DIFF"
          }
        },
        "additionalProperties" : false
      },
      "TchamwaTimeIntegrationScheme" : {
        "title" : "Tchamwa time integration scheme",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TchamwaTimeIntegrationScheme",
            "default" : "TCHAMWA"
          },
          "phi" : {
            "title" : "() Phi",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>The parameter <b>&phi;</b> allows inducing numerical damping. For <b>&phi;</b> = 1.0 there is no numerical damping whereas for <b>&phi;</b> > 1.0</p> the damping grows with the parameter value. It is thus not recommended to use a value for <b>&phi;</b> greater than 1.1.</p>",
            "default" : 1.05
          }
        },
        "additionalProperties" : false
      },
      "NewtonResolutionType" : {
        "title" : "Newton",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose how the nonlinearities are solved. Currently for direct solvers only the Newton-Raphson method is available via the selection <b>Newton</b>. For iterative solvers also an inexact version of the Newton-Raphson method is available via the selection <b>Newton-Krylov</b>.</p>\n\nSchema name: NewtonResolutionType",
            "default" : "NEWTON"
          },
          "convergenceCriteria" : {
            "$ref" : "#/components/schemas/OneOf_NewtonResolutionTypeConvergenceCriteria"
          },
          "predictionMatrix" : {
            "title" : "Prediction matrix",
            "type" : "string",
            "description" : "<p>Select which stiffnes matrix should be used in the prediction phase of the Newton method. A good choice leads to a good starting point for the first Newton iteration and thus a faster convergence.</p>",
            "default" : "TANGENT",
            "enum" : [ "TANGENT", "ELASTIC" ],
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS]", "type == THERMAL_MECHANICAL && 1# == mechanicalResolutionType" ]
          },
          "jacobianMatrix" : {
            "$ref" : "#/components/schemas/OneOf_NewtonResolutionTypeJacobianMatrix"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose how the nonlinearities are solved. Currently for direct solvers only the Newton-Raphson method is available via the selection <b>Newton</b>. For iterative solvers also an inexact version of the Newton-Raphson method is available via the selection <b>Newton-Krylov</b>.</p>"
      },
      "RelativeConvergenceCriteria" : {
        "title" : "Relative",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select the type of convergence criterion for the nonlinear solution method.</p> <br /><br />Important remarks: <br /><ul><li>Choose <b>absolute</b> if you want convergence to be reached when the maximum residual of all degrees of freedom of a given Newton iteration is lower than the given tolerance.</li><li>Choose <b>relative</b> if the same criteria as <b>absolute</b> will be checked but for the maximum relative residual i.e. maximum absolute residual divided by external force. Please note, if no external force is involved e.g. two far objects coming in contact, then using relative criteria will lead to singularity and convergence will not be attained.</li></ul>\n\nSchema name: RelativeConvergenceCriteria",
            "default" : "RELATIVE"
          },
          "tolerance" : {
            "title" : "Tolerance",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Set the threshold value for convergence detection for the absolute convergence criteria. If the maximum abolute error of all DOFs fall below this value the current time step is considered convergent.</p> <br /><br />Important remarks: <br /><ul><li>In most of the cases using a lower value for tolerance may lead to hard or no convergence. Therefore, it is always recommended to start with a higher value e.g. 10<sup>-3</sup> or 10<sup>-4</sup>. Please also note that increasing the threshold value may effect the solution results. </li></ul>",
            "default" : 1.0E-5
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select the type of convergence criterion for the nonlinear solution method.</p> <br /><br />Important remarks: <br /><ul><li>Choose <b>absolute</b> if you want convergence to be reached when the maximum residual of all degrees of freedom of a given Newton iteration is lower than the given tolerance.</li><li>Choose <b>relative</b> if the same criteria as <b>absolute</b> will be checked but for the maximum relative residual i.e. maximum absolute residual divided by external force. Please note, if no external force is involved e.g. two far objects coming in contact, then using relative criteria will lead to singularity and convergence will not be attained.</li></ul>"
      },
      "AbsoluteConvergenceCriteria" : {
        "title" : "Absolute",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select the type of convergence criterion for the nonlinear solution method.</p> <br /><br />Important remarks: <br /><ul><li>Choose <b>absolute</b> if you want convergence to be reached when the maximum residual of all degrees of freedom of a given Newton iteration is lower than the given tolerance.</li><li>Choose <b>relative</b> if the same criteria as <b>absolute</b> will be checked but for the maximum relative residual i.e. maximum absolute residual divided by external force. Please note, if no external force is involved e.g. two far objects coming in contact, then using relative criteria will lead to singularity and convergence will not be attained.</li></ul>\n\nSchema name: AbsoluteConvergenceCriteria",
            "default" : "ABSOLUTE"
          },
          "tolerance" : {
            "title" : "Tolerance",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Set the threshold value for convergence detection for the relative convergence criteria. If the maximum relative error of all DOFs fall below this value the current time step is considered convergent.</p></p> <br /><br />Important remarks: <br /><ul><li>In most of the cases using a lower value for tolerance may lead to hard or no convergence. Therefore, it is always recommended to start with a higher value e.g. 10<sup>-3</sup> or 10<sup>-4</sup>. Please also note that increasing the threshold value may effect the solution results. </li></ul>",
            "x-conditionalDefaults" : [ {
              "when" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS]" ],
              "default" : 1.0E-4
            }, {
              "when" : [ "type in [HEAT_TRANSFER,THERMAL_MECHANICAL]" ],
              "default" : 0.001
            } ]
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select the type of convergence criterion for the nonlinear solution method.</p> <br /><br />Important remarks: <br /><ul><li>Choose <b>absolute</b> if you want convergence to be reached when the maximum residual of all degrees of freedom of a given Newton iteration is lower than the given tolerance.</li><li>Choose <b>relative</b> if the same criteria as <b>absolute</b> will be checked but for the maximum relative residual i.e. maximum absolute residual divided by external force. Please note, if no external force is involved e.g. two far objects coming in contact, then using relative criteria will lead to singularity and convergence will not be attained.</li></ul>"
      },
      "TangentJacobianMatrix" : {
        "title" : "Tangent",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select which stiffnes matrix should be used for computing the Jacobian of the Newton method. Choosing the tangent stiffnes matrix via <b>tangent matrix</b> allows a full Newton approach whereas the selection of the <b>elastic matrix</b> results in a quasi-Newton approach.</p>\n\nSchema name: TangentJacobianMatrix",
            "default" : "TANGENT"
          },
          "maxNewtonIteration" : {
            "title" : "Max Newton iterations",
            "type" : "integer",
            "description" : "<p>Maximum number of allowed Newton iterations per time increment. If this value is reached the simulation is considered non-converging. If an automatic time stepping is activated the time increment is reduced in order to reach convergence.</p>",
            "x-conditionalDefaults" : [ {
              "when" : [ "type in [THERMAL_MECHANICAL,HEAT_TRANSFER] && 2# == mechanicalResolutionType", "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS]" ],
              "default" : 15
            }, {
              "when" : [ "type in [THERMAL_MECHANICAL,HEAT_TRANSFER] && 2# == thermalResolutionType" ],
              "default" : 10
            } ]
          },
          "reactualizationIteration" : {
            "title" : "Update every nth iteration",
            "type" : "integer",
            "description" : "<p>Select how often the Jacobian matrix should be recomputed. If this parameter is set to 10, the Jacobian matrix is recomputed every 10th iteration within a given time step. If it is set to 0, the Jacobian matrix is not updated within any time step.</p>",
            "x-conditionalDefaults" : [ {
              "when" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,THERMAL_MECHANICAL,HEAT_TRANSFER]" ],
              "default" : 1
            } ]
          },
          "reactualizationIncrement" : {
            "title" : "Update every nth increment",
            "type" : "integer",
            "description" : "<p>Select how often the Jacobian matrix should be recomputed. If this parameter is set to 10, the Jacobian matrix is recomputed every 10th time step. If it is set to 0, the Jacobian matrix is never updated.</p>",
            "default" : 1,
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS]", "type == THERMAL_MECHANICAL && 2# == mechanicalResolutionType" ]
          },
          "changeJacobianMatrix" : {
            "$ref" : "#/components/schemas/OneOf_TangentJacobianMatrixChangeJacobianMatrix"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select which stiffnes matrix should be used for computing the Jacobian of the Newton method. Choosing the tangent stiffnes matrix via <b>tangent matrix</b> allows a full Newton approach whereas the selection of the <b>elastic matrix</b> results in a quasi-Newton approach.</p>"
      },
      "TrueChangeJacobianMatrix" : {
        "title" : "True",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose if the Jacobian matrix should automatically change from tangent stiffnes matrix to elastic matrix if the time increment is falling below a given threshold. On the assumption that below a given time increment value the nonlinearities are not evolving within the time step one can strongly save computation time by switching to the elastic matrix.</p>\n\nSchema name: TrueChangeJacobianMatrix",
            "default" : "TRUE"
          },
          "thresholdTimeStepValue" : {
            "title" : "Threshold time increment",
            "type" : "number",
            "description" : "<p>Set the threshold value of the Jacobian matrix changing. If the time increment is lower than this value the elastic matrix is used.</p>",
            "default" : 1.0E-6
          },
          "matrixReactualizationIteration" : {
            "title" : "Elastic matrix update every nth iteration",
            "type" : "integer",
            "description" : "<p>Set how often the elastic stiffness matrix should be recomputed. If this parameter is set to 10, the elastic matrix is recomputed every 10th iteration within a given time step. If it is set to 0, the elastic stiffness matrix is not updated within any time step.</p>",
            "default" : 0
          },
          "maxNewtonIterations" : {
            "title" : "Max Newton iterations (Elastic Jacobian)",
            "type" : "integer",
            "description" : "<p>Maximum number of allowed Newton iterations per time increment. If this value is reached the simulation is considered non-converging. If an automatic time stepping is activated the time increment is reduced in order to reach convergence.</p>",
            "default" : 35
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose if the Jacobian matrix should automatically change from tangent stiffnes matrix to elastic matrix if the time increment is falling below a given threshold. On the assumption that below a given time increment value the nonlinearities are not evolving within the time step one can strongly save computation time by switching to the elastic matrix.</p>"
      },
      "FalseChangeJacobianMatrix" : {
        "title" : "False",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose if the Jacobian matrix should automatically change from tangent stiffnes matrix to elastic matrix if the time increment is falling below a given threshold. On the assumption that below a given time increment value the nonlinearities are not evolving within the time step one can strongly save computation time by switching to the elastic matrix.</p>\n\nSchema name: FalseChangeJacobianMatrix",
            "default" : "FALSE"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose if the Jacobian matrix should automatically change from tangent stiffnes matrix to elastic matrix if the time increment is falling below a given threshold. On the assumption that below a given time increment value the nonlinearities are not evolving within the time step one can strongly save computation time by switching to the elastic matrix.</p>"
      },
      "ElasticJacobianMatrix" : {
        "title" : "Elastic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select which stiffnes matrix should be used for computing the Jacobian of the Newton method. Choosing the tangent stiffnes matrix via <b>tangent matrix</b> allows a full Newton approach whereas the selection of the <b>elastic matrix</b> results in a quasi-Newton approach.</p>\n\nSchema name: ElasticJacobianMatrix",
            "default" : "ELASTIC"
          },
          "maxNewtonIteration" : {
            "title" : "Max Newton iterations",
            "type" : "integer",
            "description" : "<p>Maximum number of allowed Newton iterations per time increment. If this value is reached the simulation is considered non-converging. If an automatic time stepping is activated the time increment is reduced in order to reach convergence.</p>",
            "default" : 35
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select which stiffnes matrix should be used for computing the Jacobian of the Newton method. Choosing the tangent stiffnes matrix via <b>tangent matrix</b> allows a full Newton approach whereas the selection of the <b>elastic matrix</b> results in a quasi-Newton approach.</p>"
      },
      "NewtonKrylovResolutionType" : {
        "title" : "Newton-Krylov",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose how the nonlinearities are solved. Currently for direct solvers only the Newton-Raphson method is available via the selection <b>Newton</b>. For iterative solvers also an inexact version of the Newton-Raphson method is available via the selection <b>Newton-Krylov</b>.</p>\n\nSchema name: NewtonKrylovResolutionType",
            "default" : "NEWTON_KRYLOV"
          },
          "convergenceCriteria" : {
            "$ref" : "#/components/schemas/OneOf_NewtonKrylovResolutionTypeConvergenceCriteria"
          },
          "predictionMatrix" : {
            "title" : "Prediction matrix",
            "type" : "string",
            "description" : "<p>Select which stiffnes matrix should be used in the prediction phase of the Newton method. A good choice leads to a good starting point for the first Newton iteration and thus a faster convergence.</p>",
            "default" : "TANGENT",
            "enum" : [ "TANGENT", "ELASTIC" ]
          },
          "jacobianMatrix" : {
            "$ref" : "#/components/schemas/OneOf_NewtonKrylovResolutionTypeJacobianMatrix"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose how the nonlinearities are solved. Currently for direct solvers only the Newton-Raphson method is available via the selection <b>Newton</b>. For iterative solvers also an inexact version of the Newton-Raphson method is available via the selection <b>Newton-Krylov</b>.</p>"
      },
      "FalseLineSearch" : {
        "title" : "False",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Line search can be used to improve convergence for nonlinear calculations with the Newton method.</p>\n\nSchema name: FalseLineSearch",
            "default" : "FALSE"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Line search can be used to improve convergence for nonlinear calculations with the Newton method.</p>"
      },
      "TrueLineSearch" : {
        "title" : "True",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Line search can be used to improve convergence for nonlinear calculations with the Newton method.</p>\n\nSchema name: TrueLineSearch",
            "default" : "TRUE"
          },
          "method" : {
            "title" : "Method",
            "type" : "string",
            "description" : "<p>Choose the method of the line search algorithm. The <b>Secant method</b> is a simple one dimensional search algorithm. The <b>mixed method</b> is a more elaborate algorithm that uses variable bounds.</p>",
            "default" : "SECANT",
            "enum" : [ "SECANT", "MIXED" ],
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,THERMAL_MECHANICAL] && 1# == mechanicalLineSearch" ]
          },
          "residual" : {
            "title" : "Residual",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Set the residual for the line search convergence</p>",
            "default" : 0.001
          },
          "maxIterations" : {
            "title" : "Max iterations",
            "maximum" : 999,
            "exclusiveMaximum" : false,
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Set the maximum number for line search iterations. Typically a sinlge-digit number should be sufficient.</p>",
            "default" : 3
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Line search can be used to improve convergence for nonlinear calculations with the Newton method.</p>"
      },
      "ThetaMethodTimeIntegrationType" : {
        "title" : "Theta method",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose the time integration scheme type</p>\n\nSchema name: ThetaMethodTimeIntegrationType",
            "default" : "THETA_METHOD"
          },
          "theta" : {
            "title" : "() Theta",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "The parameter <b>&theta;</b> must be ranging between 0.0 (explicit method) and 1.0 (completely implicit method). The standard value of <b>&theta;</b> = 0.57 is chosen a little higher than <b>&theta;</b> = 0.5 which would lead to the <i>Crank-Nicolson</i> scheme of order 2.",
            "default" : 0.57
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose the time integration scheme type</p>"
      },
      "SolidSimulationControl" : {
        "type" : "object",
        "properties" : {
          "timestepDefinition" : {
            "$ref" : "#/components/schemas/OneOf_SolidSimulationControlTimestepDefinition"
          },
          "pseudoTimeStepping" : {
            "$ref" : "#/components/schemas/OneOf_SolidSimulationControlPseudoTimeStepping"
          },
          "writeControlDefinition" : {
            "$ref" : "#/components/schemas/OneOf_SolidSimulationControlWriteControlDefinition"
          },
          "excitationFrequencies" : {
            "$ref" : "#/components/schemas/OneOf_SolidSimulationControlExcitationFrequencies"
          },
          "eigenfrequencyScope" : {
            "$ref" : "#/components/schemas/OneOf_SolidSimulationControlEigenfrequencyScope"
          },
          "processors" : {
            "$ref" : "#/components/schemas/ComputingCore"
          },
          "maxRunTime" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          }
        },
        "additionalProperties" : false
      },
      "AutoTimestepDefinition" : {
        "title" : "Automatic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AutoTimestepDefinition",
            "default" : "AUTOMATIC_V27"
          },
          "simulationInterval" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "maximumTimestepLength" : {
            "$ref" : "#/components/schemas/RestrictedDimensionalFunction_Time"
          },
          "minimumTimestepLength" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "maximumResidual" : {
            "title" : "Maximum residual",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 100000
          },
          "retimingEvent" : {
            "$ref" : "#/components/schemas/OneOf_AutoTimestepDefinitionRetimingEvent"
          }
        },
        "additionalProperties" : false
      },
      "RestrictedDimensionalFunction_Time" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_RestrictedDimensionalFunction_TimeValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "s" ]
          }
        },
        "additionalProperties" : false
      },
      "RestrictedTableDefinedFunction" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: RestrictedTableDefinedFunction",
            "default" : "RESTRICTED_TABLE_DEFINED"
          },
          "label" : {
            "title" : "Label",
            "type" : "string",
            "default" : "Table"
          },
          "tableId" : {
            "type" : "string",
            "description" : "The ID of the imported table.",
            "format" : "uuid"
          },
          "resultIndex" : {
            "title" : "Result index",
            "type" : "array",
            "description" : "Indicates which column(s) of the table contains the result values. One-based indexing must be used. For example, set this field to '[2]' if the second column of the table contains the dependent variable values.",
            "items" : {
              "type" : "integer"
            }
          },
          "independentVariables" : {
            "title" : "Independent variables",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/TableFunctionParameter"
            }
          },
          "separator" : {
            "title" : "Separator",
            "type" : "string",
            "description" : "Values in each row are separated by this character. Also known as a delimiter.",
            "default" : ","
          }
        },
        "additionalProperties" : false
      },
      "ErrorRetimingEvent" : {
        "title" : "Error",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select the event for the time step adaptation. Currently there are four different events possible that trigger a time step adaptation:</p><ul><li><p><b>Error</b>: This is the case of a general error like for example non-convergence or singular matrix errors.</p></ul><ul><li><p><b>Collision</b>: This event is triggered if in a computation with physical contact a contact state change from open to closed is noticed. This time step adaptation is especially useful in dynamics to reduce the effect of artificial oscillations due to inexact collision detection.</p></ul><ul><li><p><b>Field Change</b>: The user can define the maximum delta that a field is allowed to change within one time step, if the defined threshold is exceeded the time step is adapted. This time stepping criteria is especially useful to capture material nonlinearitier more exact.</p></ul><ul><li><p><b>Non-monotonous residual</b>: This event is triggered if the residual has not been reduced within three iterations . This criteria is mostly used to reduce runtime by detecting diverging time steps before reaching the maximum number of allowed newton iterations.</p></ul>\n\nSchema name: ErrorRetimingEvent",
            "default" : "ERROR"
          },
          "timestepCalculationType" : {
            "$ref" : "#/components/schemas/OneOf_ErrorRetimingEventTimestepCalculationType"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select the event for the time step adaptation. Currently there are four different events possible that trigger a time step adaptation:</p><ul><li><p><b>Error</b>: This is the case of a general error like for example non-convergence or singular matrix errors.</p></ul><ul><li><p><b>Collision</b>: This event is triggered if in a computation with physical contact a contact state change from open to closed is noticed. This time step adaptation is especially useful in dynamics to reduce the effect of artificial oscillations due to inexact collision detection.</p></ul><ul><li><p><b>Field Change</b>: The user can define the maximum delta that a field is allowed to change within one time step, if the defined threshold is exceeded the time step is adapted. This time stepping criteria is especially useful to capture material nonlinearitier more exact.</p></ul><ul><li><p><b>Non-monotonous residual</b>: This event is triggered if the residual has not been reduced within three iterations . This criteria is mostly used to reduce runtime by detecting diverging time steps before reaching the maximum number of allowed newton iterations.</p></ul>"
      },
      "NewtonIterationTimestepCalculationType" : {
        "title" : "Newton iterations target",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select how the time increments should be computed in case of an adaptation event. Currently four types are available (which may not all be available for every event):</p><ul><li><p><b>Manual</b>: Here the user defines fixed time step subdivision and augmentation settings.</p></ul><ul><li><p><b>Newton Iterations Target</b>: With this setting the user defines a target value for the Newton Iterations and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Field Change Target</b>: With this setting the user defines a target value for change of a specific field component within a time increment and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Mixed</b>: The mixed type uses a fixed subdivision and an automatic adaptation of the time step with a target value for the change of the selected field component.</p></ul>\n\nSchema name: NewtonIterationTimestepCalculationType",
            "default" : "NEWTON_ITERATION"
          },
          "value" : {
            "title" : "Value",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the target value for the number of Newton Iterations within a time step.</p>",
            "default" : 8
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select how the time increments should be computed in case of an adaptation event. Currently four types are available (which may not all be available for every event):</p><ul><li><p><b>Manual</b>: Here the user defines fixed time step subdivision and augmentation settings.</p></ul><ul><li><p><b>Newton Iterations Target</b>: With this setting the user defines a target value for the Newton Iterations and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Field Change Target</b>: With this setting the user defines a target value for change of a specific field component within a time increment and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Mixed</b>: The mixed type uses a fixed subdivision and an automatic adaptation of the time step with a target value for the change of the selected field component.</p></ul>"
      },
      "ManualTimestepCalculationType" : {
        "title" : "Manual",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select how the time increments should be computed in case of an adaptation event. Currently four types are available (which may not all be available for every event):</p><ul><li><p><b>Manual</b>: Here the user defines fixed time step subdivision and augmentation settings.</p></ul><ul><li><p><b>Newton Iterations Target</b>: With this setting the user defines a target value for the Newton Iterations and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Field Change Target</b>: With this setting the user defines a target value for change of a specific field component within a time increment and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Mixed</b>: The mixed type uses a fixed subdivision and an automatic adaptation of the time step with a target value for the change of the selected field component.</p></ul>\n\nSchema name: ManualTimestepCalculationType",
            "default" : "MANUAL"
          },
          "additionalNewtonIterations" : {
            "title" : "Additional Newton iterations",
            "minimum" : 20,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Define the percentage of additional Newton Iterations that should be allowed to be used if convergence is not reached after the maximum number of Newton Iterations is reached.</p>",
            "default" : 20,
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,THERMAL_MECHANICAL] && 2/type == ERROR" ]
          },
          "fixedSubdivision" : {
            "$ref" : "#/components/schemas/FixedSubdivision"
          },
          "fixedAugmentation" : {
            "$ref" : "#/components/schemas/FixedAugmentation"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select how the time increments should be computed in case of an adaptation event. Currently four types are available (which may not all be available for every event):</p><ul><li><p><b>Manual</b>: Here the user defines fixed time step subdivision and augmentation settings.</p></ul><ul><li><p><b>Newton Iterations Target</b>: With this setting the user defines a target value for the Newton Iterations and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Field Change Target</b>: With this setting the user defines a target value for change of a specific field component within a time increment and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Mixed</b>: The mixed type uses a fixed subdivision and an automatic adaptation of the time step with a target value for the change of the selected field component.</p></ul>"
      },
      "FixedSubdivision" : {
        "type" : "object",
        "properties" : {
          "numSubdivisions" : {
            "title" : "Number of subdivisions",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the number of equal subdivisions of a time step in case of an adaptation event.</p>",
            "default" : 4
          },
          "maxSubdivisionDepth" : {
            "title" : "Max subdivision depth",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define maximum depth of the timestep subdivisions. If this value is exceeded the computation will stop. Example: If this value is set to 3, the number of subdivisions to 2 and the initial time step length is set to 1 sec, than the maximum depth is reached after 3 consecutive subdivisions (e.g. a time step of 1/8 sec based on <i>1.(1/2)<sup>3</sup></i>).</p>",
            "default" : 3
          }
        },
        "additionalProperties" : false
      },
      "FixedAugmentation" : {
        "type" : "object",
        "properties" : {
          "newtonIterationThreshold" : {
            "title" : "Newton iteration threshold",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p><b>Newton Iteration threshold</b> defines the threshold below which the actual number of Newton Iterations has to fall in order to increase the time step by the percentage given by <b>Timestep Augmentation</b>.</p>",
            "default" : 5
          },
          "timestepAugmentation" : {
            "title" : "Time step augmentation",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p><b>Newton Iteration threshold</b> defines the threshold below which the actual number of Newton Iterations has to fall in order to increase the time step by the percentage given by <b>Timestep Augmentation</b>.</p>",
            "default" : 100
          }
        },
        "additionalProperties" : false
      },
      "CollisionRetimingEvent" : {
        "title" : "Collision",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select the event for the time step adaptation. Currently there are four different events possible that trigger a time step adaptation:</p><ul><li><p><b>Error</b>: This is the case of a general error like for example non-convergence or singular matrix errors.</p></ul><ul><li><p><b>Collision</b>: This event is triggered if in a computation with physical contact a contact state change from open to closed is noticed. This time step adaptation is especially useful in dynamics to reduce the effect of artificial oscillations due to inexact collision detection.</p></ul><ul><li><p><b>Field Change</b>: The user can define the maximum delta that a field is allowed to change within one time step, if the defined threshold is exceeded the time step is adapted. This time stepping criteria is especially useful to capture material nonlinearitier more exact.</p></ul><ul><li><p><b>Non-monotonous residual</b>: This event is triggered if the residual has not been reduced within three iterations . This criteria is mostly used to reduce runtime by detecting diverging time steps before reaching the maximum number of allowed newton iterations.</p></ul>\n\nSchema name: CollisionRetimingEvent",
            "default" : "COLLISION"
          },
          "timestepCalculationType" : {
            "$ref" : "#/components/schemas/ManualTimestepCalculationType"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select the event for the time step adaptation. Currently there are four different events possible that trigger a time step adaptation:</p><ul><li><p><b>Error</b>: This is the case of a general error like for example non-convergence or singular matrix errors.</p></ul><ul><li><p><b>Collision</b>: This event is triggered if in a computation with physical contact a contact state change from open to closed is noticed. This time step adaptation is especially useful in dynamics to reduce the effect of artificial oscillations due to inexact collision detection.</p></ul><ul><li><p><b>Field Change</b>: The user can define the maximum delta that a field is allowed to change within one time step, if the defined threshold is exceeded the time step is adapted. This time stepping criteria is especially useful to capture material nonlinearitier more exact.</p></ul><ul><li><p><b>Non-monotonous residual</b>: This event is triggered if the residual has not been reduced within three iterations . This criteria is mostly used to reduce runtime by detecting diverging time steps before reaching the maximum number of allowed newton iterations.</p></ul>"
      },
      "FieldChangeRetimingEvent" : {
        "title" : "Field change",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select the event for the time step adaptation. Currently there are four different events possible that trigger a time step adaptation:</p><ul><li><p><b>Error</b>: This is the case of a general error like for example non-convergence or singular matrix errors.</p></ul><ul><li><p><b>Collision</b>: This event is triggered if in a computation with physical contact a contact state change from open to closed is noticed. This time step adaptation is especially useful in dynamics to reduce the effect of artificial oscillations due to inexact collision detection.</p></ul><ul><li><p><b>Field Change</b>: The user can define the maximum delta that a field is allowed to change within one time step, if the defined threshold is exceeded the time step is adapted. This time stepping criteria is especially useful to capture material nonlinearitier more exact.</p></ul><ul><li><p><b>Non-monotonous residual</b>: This event is triggered if the residual has not been reduced within three iterations . This criteria is mostly used to reduce runtime by detecting diverging time steps before reaching the maximum number of allowed newton iterations.</p></ul>\n\nSchema name: FieldChangeRetimingEvent",
            "default" : "FIELD_CHANGE"
          },
          "fieldSelection" : {
            "$ref" : "#/components/schemas/OneOf_FieldChangeRetimingEventFieldSelection"
          },
          "thresholdValue" : {
            "title" : "Threshold value",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>This value defines the maximum allowed change of the defined target field component within each time increment. If this threshold is exceeded the time step is adapted according to the selected settings in the *Timestep Calculation Type*.</p>",
            "default" : 0.1
          },
          "timestepCalculationType" : {
            "$ref" : "#/components/schemas/OneOf_FieldChangeRetimingEventTimestepCalculationType"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select the event for the time step adaptation. Currently there are four different events possible that trigger a time step adaptation:</p><ul><li><p><b>Error</b>: This is the case of a general error like for example non-convergence or singular matrix errors.</p></ul><ul><li><p><b>Collision</b>: This event is triggered if in a computation with physical contact a contact state change from open to closed is noticed. This time step adaptation is especially useful in dynamics to reduce the effect of artificial oscillations due to inexact collision detection.</p></ul><ul><li><p><b>Field Change</b>: The user can define the maximum delta that a field is allowed to change within one time step, if the defined threshold is exceeded the time step is adapted. This time stepping criteria is especially useful to capture material nonlinearitier more exact.</p></ul><ul><li><p><b>Non-monotonous residual</b>: This event is triggered if the residual has not been reduced within three iterations . This criteria is mostly used to reduce runtime by detecting diverging time steps before reaching the maximum number of allowed newton iterations.</p></ul>"
      },
      "DisplacementField" : {
        "title" : "Displacement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select the field which should have a limited de-/increase within one increment.</p>\n\nSchema name: DisplacementField",
            "default" : "DISPLACEMENT"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "description" : "Choose a field component for which the data schould be extracted.",
            "default" : "X",
            "enum" : [ "X", "Y", "Z", "ALL" ]
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select the field which should have a limited de-/increase within one increment.</p>"
      },
      "CauchyStressTensorField" : {
        "title" : "Cauchy stress",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select the field which should have a limited de-/increase within one increment.</p>\n\nSchema name: CauchyStressTensorField",
            "default" : "CAUCHY_STRESS_TENSOR"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "description" : "Choose a field component for which the data schould be extracted.",
            "default" : "XX",
            "enum" : [ "XX", "YY", "ZZ", "XY", "XZ", "YZ", "ALL" ]
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select the field which should have a limited de-/increase within one increment.</p>"
      },
      "InternVariablesField" : {
        "title" : "Intern variables",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select the field which should have a limited de-/increase within one increment.</p>\n\nSchema name: InternVariablesField",
            "default" : "INTERN_VARIABLES"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "description" : "<p>Choose a field component for which the data schould be extracted.</p>",
            "default" : "V1",
            "enum" : [ "V1", "V2", "V3" ]
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select the field which should have a limited de-/increase within one increment.</p>"
      },
      "MixedTimestepCalculationType" : {
        "title" : "Mixed",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select how the time increments should be computed in case of an adaptation event. Currently four types are available (which may not all be available for every event):</p><ul><li><p><b>Manual</b>: Here the user defines fixed time step subdivision and augmentation settings.</p></ul><ul><li><p><b>Newton Iterations Target</b>: With this setting the user defines a target value for the Newton Iterations and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Field Change Target</b>: With this setting the user defines a target value for change of a specific field component within a time increment and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Mixed</b>: The mixed type uses a fixed subdivision and an automatic adaptation of the time step with a target value for the change of the selected field component.</p></ul>\n\nSchema name: MixedTimestepCalculationType",
            "default" : "MIXED"
          },
          "fixedSubdivision" : {
            "$ref" : "#/components/schemas/FixedSubdivision"
          },
          "adaptiveAugmentation" : {
            "$ref" : "#/components/schemas/AdaptiveAugmentation"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select how the time increments should be computed in case of an adaptation event. Currently four types are available (which may not all be available for every event):</p><ul><li><p><b>Manual</b>: Here the user defines fixed time step subdivision and augmentation settings.</p></ul><ul><li><p><b>Newton Iterations Target</b>: With this setting the user defines a target value for the Newton Iterations and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Field Change Target</b>: With this setting the user defines a target value for change of a specific field component within a time increment and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Mixed</b>: The mixed type uses a fixed subdivision and an automatic adaptation of the time step with a target value for the change of the selected field component.</p></ul>"
      },
      "AdaptiveAugmentation" : {
        "type" : "object",
        "properties" : {
          "fieldChangeTargetValue" : {
            "title" : "Field change target",
            "type" : "number",
            "description" : "<p>Define the percentage of additional Newton Iterations that should be allowed to be used if convergence is not reached after the maximum number of Newton Iterations is reached.</p>",
            "default" : 0.01
          }
        },
        "additionalProperties" : false
      },
      "FieldChangeTargetCalculationType" : {
        "title" : "Field change target",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select how the time increments should be computed in case of an adaptation event. Currently four types are available (which may not all be available for every event):</p><ul><li><p><b>Manual</b>: Here the user defines fixed time step subdivision and augmentation settings.</p></ul><ul><li><p><b>Newton Iterations Target</b>: With this setting the user defines a target value for the Newton Iterations and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Field Change Target</b>: With this setting the user defines a target value for change of a specific field component within a time increment and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Mixed</b>: The mixed type uses a fixed subdivision and an automatic adaptation of the time step with a target value for the change of the selected field component.</p></ul>\n\nSchema name: FieldChangeTargetCalculationType",
            "default" : "FIELD_CHANGE_TARGET"
          },
          "value" : {
            "title" : "Value",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.01
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select how the time increments should be computed in case of an adaptation event. Currently four types are available (which may not all be available for every event):</p><ul><li><p><b>Manual</b>: Here the user defines fixed time step subdivision and augmentation settings.</p></ul><ul><li><p><b>Newton Iterations Target</b>: With this setting the user defines a target value for the Newton Iterations and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Field Change Target</b>: With this setting the user defines a target value for change of a specific field component within a time increment and the time increments are calculated automatically to having this value as objective.</p></ul><ul><li><p><b>Mixed</b>: The mixed type uses a fixed subdivision and an automatic adaptation of the time step with a target value for the change of the selected field component.</p></ul>"
      },
      "NonMonotomousResidualRetimingEvent" : {
        "title" : "Non-monotonous residual",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Select the event for the time step adaptation. Currently there are four different events possible that trigger a time step adaptation:</p><ul><li><p><b>Error</b>: This is the case of a general error like for example non-convergence or singular matrix errors.</p></ul><ul><li><p><b>Collision</b>: This event is triggered if in a computation with physical contact a contact state change from open to closed is noticed. This time step adaptation is especially useful in dynamics to reduce the effect of artificial oscillations due to inexact collision detection.</p></ul><ul><li><p><b>Field Change</b>: The user can define the maximum delta that a field is allowed to change within one time step, if the defined threshold is exceeded the time step is adapted. This time stepping criteria is especially useful to capture material nonlinearitier more exact.</p></ul><ul><li><p><b>Non-monotonous residual</b>: This event is triggered if the residual has not been reduced within three iterations . This criteria is mostly used to reduce runtime by detecting diverging time steps before reaching the maximum number of allowed newton iterations.</p></ul>\n\nSchema name: NonMonotomousResidualRetimingEvent",
            "default" : "NON_MONOTOMOUS_RESIDUAL"
          },
          "timestepCalculationType" : {
            "$ref" : "#/components/schemas/OneOf_NonMonotomousResidualRetimingEventTimestepCalculationType"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Select the event for the time step adaptation. Currently there are four different events possible that trigger a time step adaptation:</p><ul><li><p><b>Error</b>: This is the case of a general error like for example non-convergence or singular matrix errors.</p></ul><ul><li><p><b>Collision</b>: This event is triggered if in a computation with physical contact a contact state change from open to closed is noticed. This time step adaptation is especially useful in dynamics to reduce the effect of artificial oscillations due to inexact collision detection.</p></ul><ul><li><p><b>Field Change</b>: The user can define the maximum delta that a field is allowed to change within one time step, if the defined threshold is exceeded the time step is adapted. This time stepping criteria is especially useful to capture material nonlinearitier more exact.</p></ul><ul><li><p><b>Non-monotonous residual</b>: This event is triggered if the residual has not been reduced within three iterations . This criteria is mostly used to reduce runtime by detecting diverging time steps before reaching the maximum number of allowed newton iterations.</p></ul>"
      },
      "ManualTimestepDefinition" : {
        "title" : "Manual",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ManualTimestepDefinition",
            "default" : "MANUAL_V19"
          },
          "simulationInterval" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "timestepLength" : {
            "$ref" : "#/components/schemas/RestrictedDimensionalFunction_Time"
          }
        },
        "additionalProperties" : false
      },
      "SingleStepPseudoTimeStepping" : {
        "title" : "Single step",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SingleStepPseudoTimeStepping",
            "default" : "SINGLE_STEP"
          },
          "staticTimesteps" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          }
        },
        "additionalProperties" : false
      },
      "SteppingListPseudoTimeStepping" : {
        "title" : "Stepping list",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SteppingListPseudoTimeStepping",
            "default" : "STEPPING_LIST_V18"
          },
          "simulationIntervals" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "timestepLength" : {
            "$ref" : "#/components/schemas/RestrictedDimensionalFunction_Time"
          }
        },
        "additionalProperties" : false
      },
      "WriteIntervalWriteControl" : {
        "title" : "Write interval",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Define how frequently intermediate results should be saved. With the selection of <b>initial time steps</b> only the user defined time steps are stored in the result and by selecting <b>all computed time steps</b> also intermediate results that were created by the automatic time stepping are saved. With the selection of <b>write interval</b> a specific write frequency can be chosen which reduces the result size. Finally using <b>user defined time steps</b> there can either be a constant time increment for result storage given or a table with varying time intervals analogous to the <b>time step length</b> definition.</p>\n\nSchema name: WriteIntervalWriteControl",
            "default" : "WRITE_INTERVAL"
          },
          "writeInterval" : {
            "title" : "Write interval",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the write frequency of the intermediate results to the result file. Selecting a write interval of 2 means that every second computed time step is saved in the final result database, independently if it is a pre-defined user time step or an intermediate one that was added during automatic time stepping. </p>",
            "default" : 5
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Define how frequently intermediate results should be saved. With the selection of <b>initial time steps</b> only the user defined time steps are stored in the result and by selecting <b>all computed time steps</b> also intermediate results that were created by the automatic time stepping are saved. With the selection of <b>write interval</b> a specific write frequency can be chosen which reduces the result size. Finally using <b>user defined time steps</b> there can either be a constant time increment for result storage given or a table with varying time intervals analogous to the <b>time step length</b> definition.</p>"
      },
      "AllComputedWriteControl" : {
        "title" : "All computed",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Define how frequently intermediate results should be saved. With the selection of <b>initial time steps</b> only the user defined time steps are stored in the result and by selecting <b>all computed time steps</b> also intermediate results that were created by the automatic time stepping are saved. With the selection of <b>write interval</b> a specific write frequency can be chosen which reduces the result size. Finally using <b>user defined time steps</b> there can either be a constant time increment for result storage given or a table with varying time intervals analogous to the <b>time step length</b> definition.</p>\n\nSchema name: AllComputedWriteControl",
            "default" : "ALL_COMPUTED"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Define how frequently intermediate results should be saved. With the selection of <b>initial time steps</b> only the user defined time steps are stored in the result and by selecting <b>all computed time steps</b> also intermediate results that were created by the automatic time stepping are saved. With the selection of <b>write interval</b> a specific write frequency can be chosen which reduces the result size. Finally using <b>user defined time steps</b> there can either be a constant time increment for result storage given or a table with varying time intervals analogous to the <b>time step length</b> definition.</p>"
      },
      "InitialTimestepsWriteControl" : {
        "title" : "Initial time steps",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Define how frequently intermediate results should be saved. With the selection of <b>initial time steps</b> only the user defined time steps are stored in the result and by selecting <b>all computed time steps</b> also intermediate results that were created by the automatic time stepping are saved. With the selection of <b>write interval</b> a specific write frequency can be chosen which reduces the result size. Finally using <b>user defined time steps</b> there can either be a constant time increment for result storage given or a table with varying time intervals analogous to the <b>time step length</b> definition.</p>\n\nSchema name: InitialTimestepsWriteControl",
            "default" : "INITIAL"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Define how frequently intermediate results should be saved. With the selection of <b>initial time steps</b> only the user defined time steps are stored in the result and by selecting <b>all computed time steps</b> also intermediate results that were created by the automatic time stepping are saved. With the selection of <b>write interval</b> a specific write frequency can be chosen which reduces the result size. Finally using <b>user defined time steps</b> there can either be a constant time increment for result storage given or a table with varying time intervals analogous to the <b>time step length</b> definition.</p>"
      },
      "UserDefinedWriteControl" : {
        "title" : "User defined",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Define how frequently intermediate results should be saved. With the selection of <b>initial time steps</b> only the user defined time steps are stored in the result and by selecting <b>all computed time steps</b> also intermediate results that were created by the automatic time stepping are saved. With the selection of <b>write interval</b> a specific write frequency can be chosen which reduces the result size. Finally using <b>user defined time steps</b> there can either be a constant time increment for result storage given or a table with varying time intervals analogous to the <b>time step length</b> definition.</p>\n\nSchema name: UserDefinedWriteControl",
            "default" : "USER_DEFINED_V21"
          },
          "writeIncrement" : {
            "$ref" : "#/components/schemas/RestrictedDimensionalFunction_Time"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Define how frequently intermediate results should be saved. With the selection of <b>initial time steps</b> only the user defined time steps are stored in the result and by selecting <b>all computed time steps</b> also intermediate results that were created by the automatic time stepping are saved. With the selection of <b>write interval</b> a specific write frequency can be chosen which reduces the result size. Finally using <b>user defined time steps</b> there can either be a constant time increment for result storage given or a table with varying time intervals analogous to the <b>time step length</b> definition.</p>"
      },
      "SingleFrequency" : {
        "title" : "Single frequency",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Set the frequencies for the harmonic excitation. Setting it to <b>single frequency</b> will only compute harmonic excitation on that frequency. To have harmonic excitations on multiple frequencies, please choose <b>frequency list</b>. </p>\n\nSchema name: SingleFrequency",
            "default" : "SINGLE"
          },
          "frequency" : {
            "$ref" : "#/components/schemas/Dimensional_Frequency"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Set the frequencies for the harmonic excitation. Setting it to <b>single frequency</b> will only compute harmonic excitation on that frequency. To have harmonic excitations on multiple frequencies, please choose <b>frequency list</b>. </p>"
      },
      "FrequencyList" : {
        "title" : "Frequency list",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Set the frequencies for the harmonic excitation. Setting it to <b>single frequency</b> will only compute harmonic excitation on that frequency. To have harmonic excitations on multiple frequencies, please choose <b>frequency list</b>. </p>\n\nSchema name: FrequencyList",
            "default" : "LIST_V20"
          },
          "startFrequency" : {
            "$ref" : "#/components/schemas/Dimensional_Frequency"
          },
          "endFrequency" : {
            "$ref" : "#/components/schemas/Dimensional_Frequency"
          },
          "frequencyStepping" : {
            "$ref" : "#/components/schemas/RestrictedDimensionalFunction_Frequency"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Set the frequencies for the harmonic excitation. Setting it to <b>single frequency</b> will only compute harmonic excitation on that frequency. To have harmonic excitations on multiple frequencies, please choose <b>frequency list</b>. </p>"
      },
      "RestrictedDimensionalFunction_Frequency" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_RestrictedDimensionalFunction_FrequencyValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/s" ]
          }
        },
        "additionalProperties" : false
      },
      "FirstMode" : {
        "title" : "First modes",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FirstMode",
            "default" : "FIRSTMODE"
          },
          "numberOfModes" : {
            "title" : "Number of modes",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the maximum number of eigenfrequencies/eigenmodes, that should be calculated.</p>",
            "default" : 10
          }
        },
        "additionalProperties" : false
      },
      "FrequencyRange" : {
        "title" : "Frequency range",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FrequencyRange",
            "default" : "RANGE"
          },
          "startFrequency" : {
            "$ref" : "#/components/schemas/Dimensional_Frequency"
          },
          "endFrequency" : {
            "$ref" : "#/components/schemas/Dimensional_Frequency"
          }
        },
        "additionalProperties" : false
      },
      "CenterFrequency" : {
        "title" : "Center frequency",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CenterFrequency",
            "default" : "CENTER"
          },
          "centerFrequency" : {
            "$ref" : "#/components/schemas/Dimensional_Frequency"
          },
          "numberOfModes" : {
            "title" : "Number of modes",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the maximum number of eigenfrequencies/eigenmodes, that should be calculated.</p>",
            "default" : 10
          }
        },
        "additionalProperties" : false
      },
      "ComputingCore" : {
        "type" : "object",
        "properties" : {
          "numOfProcessors" : {
            "title" : "Number of processors",
            "maximum" : 64,
            "exclusiveMaximum" : false,
            "minimum" : -1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Selecting more processor cores will speed up the simulation process. Choosing a smaller computation instance will save core hours. <a href='https://www.simscale.com/docs/simulation-setup/simulation-control-fluid/#number-of-processors' target='_blank'>Learn more</a>.</p>",
            "format" : "int64",
            "default" : -1,
            "enum" : [ -1, 1, 2, 4, 8, 16, 32, 64 ]
          },
          "numOfComputingProcessors" : {
            "title" : "Number of parallel processes",
            "minimum" : -1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Set the number of processors which shall be used for the parallel computation.</p>",
            "default" : -1
          }
        },
        "additionalProperties" : false
      },
      "SolidResultControl" : {
        "type" : "object",
        "properties" : {
          "solutionFields" : {
            "title" : "Solution fields",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_SolidResultControlSolutionFields"
            },
            "x-conditionalDefaults" : [ {
              "when" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true" ],
              "default" : [ {
                "type" : "DISPLACEMENT",
                "name" : "displacement",
                "displacementType" : {
                  "type" : "GLOBAL"
                }
              }, {
                "type" : "STRESS",
                "name" : "cauchy stress",
                "stressType" : {
                  "type" : "CAUCHY"
                }
              }, {
                "type" : "STRESS",
                "name" : "von Mises stress",
                "stressType" : {
                  "type" : "VON_MISES"
                }
              }, {
                "type" : "STRAIN",
                "name" : "total nonlinear strain",
                "strainType" : {
                  "type" : "TOTAL_NONLINEAR"
                }
              } ]
            }, {
              "when" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == false" ],
              "default" : [ {
                "type" : "DISPLACEMENT",
                "name" : "displacement",
                "displacementType" : {
                  "type" : "GLOBAL"
                }
              }, {
                "type" : "STRESS",
                "name" : "cauchy stress",
                "stressType" : {
                  "type" : "CAUCHY"
                }
              }, {
                "type" : "STRESS",
                "name" : "von Mises stress",
                "stressType" : {
                  "type" : "VON_MISES"
                }
              }, {
                "type" : "STRAIN",
                "name" : "total strain",
                "strainType" : {
                  "type" : "TOTAL"
                }
              } ]
            }, {
              "when" : [ "type == DYNAMIC_ANALYSIS" ],
              "default" : [ {
                "type" : "DISPLACEMENT",
                "name" : "displacement",
                "displacementType" : {
                  "type" : "GLOBAL"
                }
              }, {
                "type" : "STRESS",
                "name" : "cauchy stress",
                "stressType" : {
                  "type" : "CAUCHY"
                }
              }, {
                "type" : "STRESS",
                "name" : "von Mises stress",
                "stressType" : {
                  "type" : "VON_MISES"
                }
              }, {
                "type" : "STRAIN",
                "name" : "total nonlinear strain",
                "strainType" : {
                  "type" : "TOTAL_NONLINEAR"
                }
              }, {
                "type" : "VELOCITY",
                "name" : "velocity",
                "velocityType" : {
                  "type" : "GLOBAL"
                }
              }, {
                "type" : "ACCELERATION",
                "name" : "acceleration",
                "accelerationType" : {
                  "type" : "GLOBAL"
                }
              } ]
            }, {
              "when" : [ "type == HEAT_TRANSFER" ],
              "default" : [ {
                "type" : "TEMPERATURE",
                "name" : "temperature",
                "temperatureType" : "FIELD"
              } ]
            }, {
              "when" : [ "type == THERMAL_MECHANICAL && nonLinearAnalysis == false" ],
              "default" : [ {
                "type" : "DISPLACEMENT",
                "name" : "displacement",
                "displacementType" : {
                  "type" : "GLOBAL"
                }
              }, {
                "type" : "STRESS",
                "name" : "cauchy stress",
                "stressType" : {
                  "type" : "CAUCHY"
                }
              }, {
                "type" : "STRESS",
                "name" : "von Mises stress",
                "stressType" : {
                  "type" : "VON_MISES"
                }
              }, {
                "type" : "STRAIN",
                "name" : "total strain",
                "strainType" : {
                  "type" : "TOTAL"
                }
              }, {
                "type" : "TEMPERATURE",
                "name" : "temperature",
                "temperatureType" : "FIELD"
              } ]
            }, {
              "when" : [ "type == THERMAL_MECHANICAL && nonLinearAnalysis == true && inertiaEffect == STATIC" ],
              "default" : [ {
                "type" : "DISPLACEMENT",
                "name" : "displacement",
                "displacementType" : {
                  "type" : "GLOBAL"
                }
              }, {
                "type" : "STRESS",
                "name" : "cauchy stress",
                "stressType" : {
                  "type" : "CAUCHY"
                }
              }, {
                "type" : "STRESS",
                "name" : "von Mises stress",
                "stressType" : {
                  "type" : "VON_MISES"
                }
              }, {
                "type" : "STRAIN",
                "name" : "total nonlinear strain",
                "strainType" : {
                  "type" : "TOTAL_NONLINEAR"
                }
              }, {
                "type" : "TEMPERATURE",
                "name" : "temperature",
                "temperatureType" : "FIELD"
              } ]
            }, {
              "when" : [ "type == THERMAL_MECHANICAL && nonLinearAnalysis == true && inertiaEffect == DYNAMIC" ],
              "default" : [ {
                "type" : "DISPLACEMENT",
                "name" : "displacement",
                "displacementType" : {
                  "type" : "GLOBAL"
                }
              }, {
                "type" : "STRESS",
                "name" : "cauchy stress",
                "stressType" : {
                  "type" : "CAUCHY"
                }
              }, {
                "type" : "STRESS",
                "name" : "von Mises stress",
                "stressType" : {
                  "type" : "VON_MISES"
                }
              }, {
                "type" : "STRAIN",
                "name" : "total nonlinear strain",
                "strainType" : {
                  "type" : "TOTAL_NONLINEAR"
                }
              }, {
                "type" : "TEMPERATURE",
                "name" : "temperature",
                "temperatureType" : "FIELD"
              }, {
                "type" : "VELOCITY",
                "name" : "velocity",
                "velocityType" : {
                  "type" : "GLOBAL"
                }
              }, {
                "type" : "ACCELERATION",
                "name" : "acceleration",
                "accelerationType" : {
                  "type" : "GLOBAL"
                }
              } ]
            }, {
              "when" : [ "type == HARMONIC_ANALYSIS" ],
              "default" : [ {
                "type" : "DISPLACEMENT",
                "name" : "displacement",
                "displacementType" : {
                  "type" : "GLOBAL"
                }
              }, {
                "type" : "STRESS",
                "name" : "cauchy stress",
                "stressType" : {
                  "type" : "CAUCHY"
                }
              }, {
                "type" : "STRESS",
                "name" : "von Mises stress",
                "stressType" : {
                  "type" : "VON_MISES"
                }
              }, {
                "type" : "STRAIN",
                "name" : "total strain",
                "strainType" : {
                  "type" : "TOTAL"
                }
              }, {
                "type" : "VELOCITY",
                "name" : "velocity",
                "velocityType" : {
                  "type" : "GLOBAL"
                }
              }, {
                "type" : "ACCELERATION",
                "name" : "acceleration",
                "accelerationType" : {
                  "type" : "GLOBAL"
                }
              } ]
            }, {
              "when" : [ "type == FREQUENCY_ANALYSIS" ],
              "default" : [ {
                "type" : "DISPLACEMENT",
                "name" : "displacement",
                "displacementType" : {
                  "type" : "GLOBAL"
                }
              } ]
            } ]
          },
          "edgeCalculation" : {
            "title" : "Edge calculation",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_SolidResultControlEdgeCalculation"
            },
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL]" ]
          },
          "areaCalculation" : {
            "title" : "Area calculation",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_SolidResultControlAreaCalculation"
            },
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL]" ]
          },
          "volumeCalculation" : {
            "title" : "Volume calculation",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_SolidResultControlVolumeCalculation"
            },
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL]" ]
          },
          "pointData" : {
            "title" : "Point data",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_SolidResultControlPointData"
            },
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HARMONIC_ANALYSIS,THERMAL_MECHANICAL,HEAT_TRANSFER]" ]
          }
        },
        "additionalProperties" : false
      },
      "ContactResultControlItem" : {
        "title" : "Contact",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ContactResultControlItem",
            "default" : "CONTACT"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "contactType" : {
            "title" : "Contact type",
            "type" : "string",
            "default" : "PRESSURE",
            "enum" : [ "PRESSURE", "STATE" ],
            "x-showWhen" : [ "type == DYNAMIC_ANALYSIS", "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && inertiaEffect == DYNAMIC" ]
          }
        },
        "additionalProperties" : false
      },
      "DisplacementResultControlItem" : {
        "title" : "Displacement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: DisplacementResultControlItem",
            "default" : "DISPLACEMENT"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "displacementType" : {
            "$ref" : "#/components/schemas/GlobalDisplacementType"
          }
        },
        "additionalProperties" : false
      },
      "GlobalDisplacementType" : {
        "title" : "Displacement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalDisplacementType",
            "default" : "GLOBAL"
          },
          "complexNumber" : {
            "title" : "Complex number",
            "type" : "string",
            "default" : "REAL_AND_IMAGINARY",
            "enum" : [ "REAL_AND_IMAGINARY", "MAGNITUDE_AND_PHASE" ],
            "x-showWhen" : [ "type == HARMONIC_ANALYSIS" ]
          }
        },
        "additionalProperties" : false
      },
      "ForceResultControlItem" : {
        "title" : "Force",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ForceResultControlItem",
            "default" : "FORCE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "forceType" : {
            "$ref" : "#/components/schemas/OneOf_ForceResultControlItemForceType"
          }
        },
        "additionalProperties" : false
      },
      "GlobalReactionForceType" : {
        "title" : "Reaction force",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalReactionForceType",
            "default" : "REACTION"
          },
          "complexNumber" : {
            "title" : "Complex number",
            "type" : "string",
            "default" : "REAL_AND_IMAGINARY",
            "enum" : [ "REAL_AND_IMAGINARY" ],
            "x-showWhen" : [ "type == HARMONIC_ANALYSIS" ]
          }
        },
        "additionalProperties" : false
      },
      "GlobalNodalForceType" : {
        "title" : "Nodal force",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalNodalForceType",
            "default" : "NODAL"
          },
          "complexNumber" : {
            "title" : "Complex number",
            "type" : "string",
            "default" : "REAL_AND_IMAGINARY",
            "enum" : [ "REAL_AND_IMAGINARY" ],
            "x-showWhen" : [ "type == HARMONIC_ANALYSIS" ]
          }
        },
        "additionalProperties" : false
      },
      "StrainResultControlItem" : {
        "title" : "Strain",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: StrainResultControlItem",
            "default" : "STRAIN"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "x-conditionalDefaults" : [ {
              "when" : [ "type in [DYNAMIC_ANALYSIS,HARMONIC_ANALYSIS]" ],
              "default" : "total nonlinear strain"
            }, {
              "when" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true" ],
              "default" : "total nonlinear strain"
            }, {
              "when" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == false", "type == THERMAL_MECHANICAL && nonLinearAnalysis == false" ],
              "default" : "total strain"
            } ]
          },
          "strainType" : {
            "$ref" : "#/components/schemas/OneOf_StrainResultControlItemStrainType"
          }
        },
        "additionalProperties" : false
      },
      "GlobalTotalNonlinearStrainType" : {
        "title" : "Total nonlinear strain",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalTotalNonlinearStrainType",
            "default" : "TOTAL_NONLINEAR"
          }
        },
        "additionalProperties" : false
      },
      "GlobalTotalEquivalentPlasticStrainType" : {
        "title" : "Total equivalent plastic strain",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalTotalEquivalentPlasticStrainType",
            "default" : "TOTAL_EQUI_PLASTIC"
          }
        },
        "additionalProperties" : false
      },
      "GlobalUnelasticStrainType" : {
        "title" : "Unelastic strain",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalUnelasticStrainType",
            "default" : "UNELASTIC"
          }
        },
        "additionalProperties" : false
      },
      "GlobalTotalStrainType" : {
        "title" : "Total strain",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalTotalStrainType",
            "default" : "TOTAL"
          },
          "complexNumber" : {
            "title" : "Complex number",
            "type" : "string",
            "default" : "REAL_AND_IMAGINARY",
            "enum" : [ "REAL_AND_IMAGINARY" ],
            "x-showWhen" : [ "type == HARMONIC_ANALYSIS" ]
          }
        },
        "additionalProperties" : false
      },
      "GlobalPrincipalStrainType" : {
        "title" : "Principal strain (Engineering)",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalPrincipalStrainType",
            "default" : "PRINCIPAL"
          }
        },
        "additionalProperties" : false
      },
      "GlobalPrincipalGreenLagrangeStrainType" : {
        "title" : "Principal strain (Green-Lagrange)",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalPrincipalGreenLagrangeStrainType",
            "default" : "PRINCIPAL_GREEN_LAGRANGE"
          }
        },
        "additionalProperties" : false
      },
      "StressResultControlItem" : {
        "title" : "Stress",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: StressResultControlItem",
            "default" : "STRESS"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "stressType" : {
            "$ref" : "#/components/schemas/OneOf_StressResultControlItemStressType"
          }
        },
        "additionalProperties" : false
      },
      "GlobalTrescaStressType" : {
        "title" : "Tresca stress",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalTrescaStressType",
            "default" : "TRESCA"
          }
        },
        "additionalProperties" : false
      },
      "GlobalCauchyStressType" : {
        "title" : "Cauchy stress",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalCauchyStressType",
            "default" : "CAUCHY"
          },
          "complexNumber" : {
            "title" : "Complex number",
            "type" : "string",
            "default" : "REAL_AND_IMAGINARY",
            "enum" : [ "REAL_AND_IMAGINARY" ],
            "x-showWhen" : [ "type == HARMONIC_ANALYSIS" ]
          }
        },
        "additionalProperties" : false
      },
      "GlobalPrincipalStressType" : {
        "title" : "Principal stress",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalPrincipalStressType",
            "default" : "PRINCIPAL"
          }
        },
        "additionalProperties" : false
      },
      "GlobalVonMisesStressType" : {
        "title" : "Von Mises stress",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalVonMisesStressType",
            "default" : "VON_MISES"
          },
          "complexNumber" : {
            "title" : "Complex number",
            "type" : "string",
            "default" : "REAL_AND_IMAGINARY",
            "enum" : [ "REAL_AND_IMAGINARY" ],
            "x-showWhen" : [ "type == HARMONIC_ANALYSIS" ]
          }
        },
        "additionalProperties" : false
      },
      "GlobalSignedVonMisesStressType" : {
        "title" : "Signed von Mises stress",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalSignedVonMisesStressType",
            "default" : "SIGNED_VON_MISES"
          }
        },
        "additionalProperties" : false
      },
      "VelocityResultControlItem" : {
        "title" : "Velocity",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: VelocityResultControlItem",
            "default" : "VELOCITY"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "velocityType" : {
            "$ref" : "#/components/schemas/GlobalVelocityType"
          }
        },
        "additionalProperties" : false
      },
      "GlobalVelocityType" : {
        "title" : "Velocity",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalVelocityType",
            "default" : "GLOBAL"
          },
          "complexNumber" : {
            "title" : "Complex number",
            "type" : "string",
            "default" : "REAL_AND_IMAGINARY",
            "enum" : [ "REAL_AND_IMAGINARY", "MAGNITUDE_AND_PHASE" ],
            "x-showWhen" : [ "type == HARMONIC_ANALYSIS" ]
          }
        },
        "additionalProperties" : false
      },
      "AccelerationResultControlItem" : {
        "title" : "Acceleration",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AccelerationResultControlItem",
            "default" : "ACCELERATION"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "accelerationType" : {
            "$ref" : "#/components/schemas/GlobalAccelerationType"
          }
        },
        "additionalProperties" : false
      },
      "GlobalAccelerationType" : {
        "title" : "Acceleration",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GlobalAccelerationType",
            "default" : "GLOBAL"
          },
          "complexNumber" : {
            "title" : "Complex number",
            "type" : "string",
            "default" : "REAL_AND_IMAGINARY",
            "enum" : [ "REAL_AND_IMAGINARY", "MAGNITUDE_AND_PHASE" ],
            "x-showWhen" : [ "type == HARMONIC_ANALYSIS" ]
          }
        },
        "additionalProperties" : false
      },
      "TemperatureResultControlItem" : {
        "title" : "Temperature",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TemperatureResultControlItem",
            "default" : "TEMPERATURE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "temperatureType" : {
            "title" : "Temperature type",
            "type" : "string",
            "default" : "FIELD",
            "enum" : [ "FIELD" ]
          }
        },
        "additionalProperties" : false
      },
      "HeatFluxResultControlItem" : {
        "title" : "Heat flux",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: HeatFluxResultControlItem",
            "default" : "HEAT_FLUX"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "heatFluxType" : {
            "title" : "Heat flux type",
            "type" : "string",
            "default" : "FIELD",
            "enum" : [ "FIELD" ],
            "x-showWhen" : [ "type in [HEAT_TRANSFER,THERMAL_MECHANICAL]" ]
          }
        },
        "additionalProperties" : false
      },
      "MinMaxFieldsCalculationResultControlItem" : {
        "title" : "Min-max",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: MinMaxFieldsCalculationResultControlItem",
            "default" : "MIN_MAX_FIELDS_CALCULATION"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "fieldSelection" : {
            "$ref" : "#/components/schemas/OneOf_MinMaxFieldsCalculationResultControlItemFieldSelection"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "DisplacementFieldSelection" : {
        "title" : "Displacement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: DisplacementFieldSelection",
            "default" : "DISPLACEMENT"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "X", "Y", "Z", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "ForceFieldSelection" : {
        "title" : "Force",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ForceFieldSelection",
            "default" : "FORCE"
          },
          "forceType" : {
            "$ref" : "#/components/schemas/OneOf_ForceFieldSelectionForceType"
          }
        },
        "additionalProperties" : false
      },
      "ReactionForceType" : {
        "title" : "Reaction",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ReactionForceType",
            "default" : "REACTION"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "X", "Y", "Z", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "NodalForceType" : {
        "title" : "Nodal",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NodalForceType",
            "default" : "NODAL"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "X", "Y", "Z", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "StrainFieldSelection" : {
        "title" : "Strain",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: StrainFieldSelection",
            "default" : "STRAIN"
          },
          "strainType" : {
            "$ref" : "#/components/schemas/OneOf_StrainFieldSelectionStrainType"
          }
        },
        "additionalProperties" : false
      },
      "TotalLinearStrainType" : {
        "title" : "Total linear",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TotalLinearStrainType",
            "default" : "TOTAL_LINEAR"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "XX", "YY", "ZZ", "XY", "XZ", "YZ", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "TotalNonLinearStrainType" : {
        "title" : "Total nonlinear",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TotalNonLinearStrainType",
            "default" : "TOTAL_NONLINEAR"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "XX", "YY", "ZZ", "XY", "XZ", "YZ", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "TotalEquivalentPlasticStrainType" : {
        "title" : "Total equivalent plastic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TotalEquivalentPlasticStrainType",
            "default" : "TOTAL_EQUI_PLASTIC"
          }
        },
        "additionalProperties" : false
      },
      "UnelasticStrainType" : {
        "title" : "Unelastic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: UnelasticStrainType",
            "default" : "UNELASTIC"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "XX", "YY", "ZZ", "XY", "XZ", "YZ", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "PrincipalStrainType" : {
        "title" : "Principal (Engineering)",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PrincipalStrainType",
            "default" : "PRINCIPAL"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "FIRST_COMPONENT", "SECOND_COMPONENT", "THIRD_COMPONENT", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "PrincipalGreenLagrangeStrainType" : {
        "title" : "Principal (Green-Lagrange)",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PrincipalGreenLagrangeStrainType",
            "default" : "PRINCIPAL_GREEN_LAGRANGE"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "FIRST_COMPONENT", "SECOND_COMPONENT", "THIRD_COMPONENT", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "StressFieldSelection" : {
        "title" : "Stress",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: StressFieldSelection",
            "default" : "STRESS"
          },
          "stressType" : {
            "$ref" : "#/components/schemas/OneOf_StressFieldSelectionStressType"
          }
        },
        "additionalProperties" : false
      },
      "TrescaStressType" : {
        "title" : "Tresca",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TrescaStressType",
            "default" : "TRESCA"
          }
        },
        "additionalProperties" : false
      },
      "CauchyStressType" : {
        "title" : "Cauchy",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CauchyStressType",
            "default" : "CAUCHY"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "XX", "YY", "ZZ", "XY", "XZ", "YZ", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "PrincipalStressType" : {
        "title" : "Principal",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PrincipalStressType",
            "default" : "PRINCIPAL"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "FIRST_COMPONENT", "SECOND_COMPONENT", "THIRD_COMPONENT", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "VonMisesStressType" : {
        "title" : "Von Mises",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: VonMisesStressType",
            "default" : "VON_MISES"
          }
        },
        "additionalProperties" : false
      },
      "SignedVonMisesStressType" : {
        "title" : "Signed von Mises",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SignedVonMisesStressType",
            "default" : "SIGNED_VON_MISES"
          }
        },
        "additionalProperties" : false
      },
      "VelocityFieldSelection" : {
        "title" : "Velocity",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: VelocityFieldSelection",
            "default" : "VELOCITY"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "X", "Y", "Z", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "AccelerationFieldSelection" : {
        "title" : "Acceleration",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AccelerationFieldSelection",
            "default" : "ACCELERATION"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "X", "Y", "Z", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "TemperatureFieldSelection" : {
        "title" : "Temperature",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TemperatureFieldSelection",
            "default" : "TEMPERATURE"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "TEMPERATURE",
            "enum" : [ "TEMPERATURE" ]
          }
        },
        "additionalProperties" : false
      },
      "HeatFluxFieldSelection" : {
        "title" : "Heat flux",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: HeatFluxFieldSelection",
            "default" : "HEAT_FLUX"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "X", "Y", "Z", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "AverageFieldsCalculationResultControlItem" : {
        "title" : "Average",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AverageFieldsCalculationResultControlItem",
            "default" : "AVERAGE_FIELDS_CALCULATION"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "fieldSelection" : {
            "$ref" : "#/components/schemas/OneOf_AverageFieldsCalculationResultControlItemFieldSelection"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "SumFieldsCalculationResultControlItem" : {
        "title" : "Sum",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SumFieldsCalculationResultControlItem",
            "default" : "SUM_FIELDS_CALCULATION"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "fieldSelection" : {
            "$ref" : "#/components/schemas/OneOf_SumFieldsCalculationResultControlItemFieldSelection"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "MomentFieldSelection" : {
        "title" : "Moment",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: MomentFieldSelection",
            "default" : "MOMENT"
          },
          "momentType" : {
            "$ref" : "#/components/schemas/OneOf_MomentFieldSelectionMomentType"
          },
          "referencePoint" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          }
        },
        "additionalProperties" : false
      },
      "ReactionMomentType" : {
        "title" : "Reaction",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ReactionMomentType",
            "default" : "REACTION"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "X", "Y", "Z", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "NodalMomentType" : {
        "title" : "Nodal",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NodalMomentType",
            "default" : "NODAL"
          },
          "componentSelection" : {
            "title" : "Component selection",
            "type" : "string",
            "default" : "ALL",
            "enum" : [ "X", "Y", "Z", "ALL" ]
          }
        },
        "additionalProperties" : false
      },
      "TemporalResponseResultControlItem" : {
        "title" : "Point data",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TemporalResponseResultControlItem",
            "default" : "TEMPORAL_RESPONSE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "fieldSelection" : {
            "$ref" : "#/components/schemas/OneOf_TemporalResponseResultControlItemFieldSelection"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL]" ],
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : false,
              "allowedGeometryPrimitiveTypes" : [ "POINT" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "HarmonicResponseResultControlItem" : {
        "title" : "Point data",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: HarmonicResponseResultControlItem",
            "default" : "HARMONIC_RESPONSE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "fieldSelection" : {
            "$ref" : "#/components/schemas/OneOf_HarmonicResponseResultControlItemFieldSelection"
          },
          "complexNumber" : {
            "title" : "Complex number",
            "type" : "string",
            "default" : "REAL_AND_IMAGINARY",
            "enum" : [ "REAL_AND_IMAGINARY", "MAGNITUDE_AND_PHASE" ],
            "x-showWhen" : [ "type == HARMONIC_ANALYSIS" ]
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-showWhen" : [ "type == HARMONIC_ANALYSIS" ],
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : false,
              "allowedGeometryPrimitiveTypes" : [ "POINT" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "DynamicAnalysis" : {
        "title" : "Dynamic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: DynamicAnalysis",
            "default" : "DYNAMIC_ANALYSIS"
          },
          "connectionGroups" : {
            "title" : "Connection groups",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_DynamicAnalysisConnectionGroups"
            }
          },
          "elementTechnology" : {
            "$ref" : "#/components/schemas/SolidElementTechnology"
          },
          "model" : {
            "$ref" : "#/components/schemas/SolidModel"
          },
          "materials" : {
            "title" : "Materials",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SolidMaterial"
            }
          },
          "initialConditions" : {
            "$ref" : "#/components/schemas/SolidInitialConditions"
          },
          "boundaryConditions" : {
            "title" : "Boundary conditions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_DynamicAnalysisBoundaryConditions"
            }
          },
          "numerics" : {
            "$ref" : "#/components/schemas/SolidNumerics"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/SolidSimulationControl"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/SolidResultControl"
          },
          "meshOrder" : {
            "title" : "Mesh order",
            "type" : "string",
            "default" : "NONE",
            "enum" : [ "FIRST", "SECOND", "NONE" ]
          }
        },
        "additionalProperties" : false
      },
      "HeatTransfer" : {
        "title" : "Heat Transfer",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: HeatTransfer",
            "default" : "HEAT_TRANSFER"
          },
          "timeDependency" : {
            "$ref" : "#/components/schemas/OneOf_HeatTransferTimeDependency"
          },
          "nonLinearAnalysis" : {
            "title" : "Nonlinear analysis",
            "type" : "boolean",
            "description" : "<p>Choose if your analysis should feature any kind of <b>nonlinearity</b> like <b>physical contacts, nonlinear materials</b> as hyperelasticity or plasticity or <b>large rotations</b> and <b>large deformations, temperature dependant material properties</b> or <b>temperature dependant boundary conditions</b>. For a <b>linear analysis</b> none of those nonlinearities are available.</p>",
            "default" : false
          },
          "connectionGroups" : {
            "title" : "Connection groups",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/Contact"
            }
          },
          "elementTechnology" : {
            "$ref" : "#/components/schemas/SolidElementTechnology"
          },
          "model" : {
            "$ref" : "#/components/schemas/SolidModel"
          },
          "materials" : {
            "title" : "Materials",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SolidMaterial"
            }
          },
          "initialConditions" : {
            "$ref" : "#/components/schemas/SolidInitialConditions"
          },
          "boundaryConditions" : {
            "title" : "Boundary conditions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_HeatTransferBoundaryConditions"
            }
          },
          "numerics" : {
            "$ref" : "#/components/schemas/SolidNumerics"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/SolidSimulationControl"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/SolidResultControl"
          },
          "meshOrder" : {
            "title" : "Mesh order",
            "type" : "string",
            "default" : "NONE",
            "enum" : [ "FIRST", "SECOND", "NONE" ]
          }
        },
        "additionalProperties" : false
      },
      "TransientTimeDependency" : {
        "title" : "Transient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TransientTimeDependency",
            "default" : "TRANSIENT"
          }
        },
        "additionalProperties" : false
      },
      "StationaryTimeDependency" : {
        "title" : "Steady-state",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: StationaryTimeDependency",
            "default" : "STATIONARY"
          }
        },
        "additionalProperties" : false
      },
      "FixedTemperatureValueBC" : {
        "title" : "Fixed temperature value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This is a boundary condition for the <b>temperature</b> variable. It prescribes the given temperature value on all selected groups.<br /><br />Important remarks: <br /><ul><li>Do not define a temperature and a heat flux boundary condition on the same group</li><li>Do not define the temperature on slave entities of <b>Contact Constraints</b> as they are constrained by the master temperature</li><li>You may define a <b>parameter dependent (x,y,z,t)</b> value by defining a formula or uploading a table (csv-file)</li></ul>\n\nSchema name: FixedTemperatureValueBC",
            "default" : "FIXED_TEMPERATURE_VALUE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "temperatureValue" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Temperature"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This is a boundary condition for the <b>temperature</b> variable. It prescribes the given temperature value on all selected groups.<br /><br />Important remarks: <br /><ul><li>Do not define a temperature and a heat flux boundary condition on the same group</li><li>Do not define the temperature on slave entities of <b>Contact Constraints</b> as they are constrained by the master temperature</li><li>You may define a <b>parameter dependent (x,y,z,t)</b> value by defining a formula or uploading a table (csv-file)</li></ul>"
      },
      "SurfaceHeatFluxBC" : {
        "title" : "Surface heat flux",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Define the heatflux per unit area that enters the body through the assigned faces. Negative sign determines flux leaving the body.\n\nSchema name: SurfaceHeatFluxBC",
            "default" : "SURFACE_HEAT_FLUX"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "heatfluxValue" : {
            "$ref" : "#/components/schemas/DimensionalFunction_HeatFlux"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "Define the heatflux per unit area that enters the body through the assigned faces. Negative sign determines flux leaving the body."
      },
      "DimensionalFunction_HeatFlux" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_HeatFluxValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "W/m", "Btu/(sin)" ]
          }
        },
        "additionalProperties" : false
      },
      "VariableGroup_X_Y_Z_TIME_TEMP" : {
        "type" : "object",
        "properties" : {
          "X" : {
            "$ref" : "#/components/schemas/Unit_Length"
          },
          "Y" : {
            "$ref" : "#/components/schemas/Unit_Length"
          },
          "Z" : {
            "$ref" : "#/components/schemas/Unit_Length"
          },
          "T" : {
            "$ref" : "#/components/schemas/Unit_Time"
          },
          "Temperature" : {
            "$ref" : "#/components/schemas/Unit_Temperature"
          }
        }
      },
      "ConvectiveHeatFluxBC" : {
        "title" : "Convective heat flux",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This is a <b>heat flux</b> boundary condition representing a <b>convective heat flux</b> on the selected face groups. It is defined by the <b>reference temperature</b> (surrounding temperature) and the <b>convection coefficient</b>.<br /><br />Important remarks: <br /><ul><li>The convection coefficient is not only dependent on the material of the surrounding fluid but a property of the flow</li><li>You may define a <b>parameter dependent (x,y,z,t)</b> value by defining a formula or uploading a table (csv-file) for the <b>reference temperature</b> and the <b>convection coefficient</b></li></ul>\n\nSchema name: ConvectiveHeatFluxBC",
            "default" : "CONVECTIVE_HEAT_FLUX"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "referenceTemperature" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Temperature"
          },
          "heatTransferCoefficient" : {
            "$ref" : "#/components/schemas/DimensionalFunction_ThermalTransmittance"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This is a <b>heat flux</b> boundary condition representing a <b>convective heat flux</b> on the selected face groups. It is defined by the <b>reference temperature</b> (surrounding temperature) and the <b>convection coefficient</b>.<br /><br />Important remarks: <br /><ul><li>The convection coefficient is not only dependent on the material of the surrounding fluid but a property of the flow</li><li>You may define a <b>parameter dependent (x,y,z,t)</b> value by defining a formula or uploading a table (csv-file) for the <b>reference temperature</b> and the <b>convection coefficient</b></li></ul>"
      },
      "DimensionalFunction_ThermalTransmittance" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_ThermalTransmittanceValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "W/(Km)", "Btu/(sinF)" ]
          }
        },
        "additionalProperties" : false
      },
      "VolumeHeatFluxBC" : {
        "title" : "Volume heat flux",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This is a <b>volume heat source</b> boundary condition. It is applied to the <b>volume elements</b> in the selected volumes or volume groups.<br /><br />Important remarks: <br /><ul><li>The total heat generated depends on the volume of the selection as the value is given as Watt per cubic meter.</li><li>For positive values heat is generated, for negative values the bc represents a heat sink.</li><li>You may define a <b>parameter dependent (x,y,z,t)</b> value by defining a formula or uploading a table (csv-file)</li></ul>\n\nSchema name: VolumeHeatFluxBC",
            "default" : "VOLUME_HEAT_FLUX"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "heatfluxValue" : {
            "$ref" : "#/components/schemas/DimensionalFunction_VolumetricPower"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This is a <b>volume heat source</b> boundary condition. It is applied to the <b>volume elements</b> in the selected volumes or volume groups.<br /><br />Important remarks: <br /><ul><li>The total heat generated depends on the volume of the selection as the value is given as Watt per cubic meter.</li><li>For positive values heat is generated, for negative values the bc represents a heat sink.</li><li>You may define a <b>parameter dependent (x,y,z,t)</b> value by defining a formula or uploading a table (csv-file)</li></ul>"
      },
      "DimensionalFunction_VolumetricPower" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_VolumetricPowerValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "W/m", "Btu/(sin)" ]
          }
        },
        "additionalProperties" : false
      },
      "ThermalMechanical" : {
        "title" : "Thermomechanical",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ThermalMechanical",
            "default" : "THERMAL_MECHANICAL"
          },
          "timeDependency" : {
            "$ref" : "#/components/schemas/OneOf_ThermalMechanicalTimeDependency"
          },
          "inertiaEffect" : {
            "title" : "Inertia effect",
            "type" : "string",
            "description" : "<p>Select if inertia effects should be considered in the analysis. If high loading accelerations or impacts are present then <b>dynamic</b> is the right choice for this parameter. If the dynamic effects are negligible, <b>static</b> should be selected.</p>",
            "default" : "STATIC",
            "x-conditionalEnum" : [ {
              "value" : "STATIC"
            }, {
              "value" : "DYNAMIC",
              "when" : [ "timeDependency.type == TRANSIENT" ]
            } ]
          },
          "nonLinearAnalysis" : {
            "title" : "Nonlinear analysis",
            "type" : "boolean",
            "description" : "<p>Choose if your analysis should feature any kind of <b>nonlinearity</b> like <b>physical contacts, nonlinear materials</b> as hyperelasticity or plasticity or <b>large rotations</b> and <b>large deformations, temperature dependant material properties</b> or <b>temperature dependant boundary conditions</b>. For a <b>linear analysis</b> none of those nonlinearities are available.</p>",
            "default" : false,
            "x-conditionalEnum" : [ {
              "value" : true,
              "when" : [ "timeDependency.type == TRANSIENT && inertiaEffect == STATIC" ]
            }, {
              "value" : true,
              "when" : [ "timeDependency.type == TRANSIENT && inertiaEffect == DYNAMIC" ]
            }, {
              "value" : false,
              "when" : [ "timeDependency.type == STATIONARY && inertiaEffect == STATIC" ]
            }, {
              "value" : false,
              "when" : [ "timeDependency.type == TRANSIENT && inertiaEffect == STATIC" ]
            } ]
          },
          "connectionGroups" : {
            "title" : "Connection groups",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_ThermalMechanicalConnectionGroups"
            }
          },
          "elementTechnology" : {
            "$ref" : "#/components/schemas/SolidElementTechnology"
          },
          "model" : {
            "$ref" : "#/components/schemas/SolidModel"
          },
          "materials" : {
            "title" : "Materials",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SolidMaterial"
            }
          },
          "initialConditions" : {
            "$ref" : "#/components/schemas/SolidInitialConditions"
          },
          "boundaryConditions" : {
            "title" : "Boundary conditions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_ThermalMechanicalBoundaryConditions"
            }
          },
          "numerics" : {
            "$ref" : "#/components/schemas/SolidNumerics"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/SolidSimulationControl"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/SolidResultControl"
          },
          "meshOrder" : {
            "title" : "Mesh order",
            "type" : "string",
            "default" : "NONE",
            "enum" : [ "FIRST", "SECOND", "NONE" ]
          }
        },
        "additionalProperties" : false
      },
      "Incompressible" : {
        "title" : "Incompressible",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: Incompressible",
            "default" : "INCOMPRESSIBLE"
          },
          "turbulenceModel" : {
            "title" : "Turbulence model",
            "type" : "string",
            "description" : "Choose a turbulence model for your CFD analysis:<ul><li><strong>No turbulence</strong>: Laminar</li><li><strong>RANS</strong>: <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-epsilon/' target='_blank'>k-epsilon</a>, <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-omega-sst/' target='_blank'>k-omega and k-omega SST</a></li><li><strong>LES</strong>: Smagorinsky, Spalart-Allmaras</li></ul><p><p><a href='https://www.simscale.com/blog/2017/12/turbulence-cfd-analysis/' target='_blank'>Learn more</a>.</p>",
            "default" : "KOMEGASST",
            "enum" : [ "SMAGORINSKY", "SPALARTALLMARAS", "NONE", "KEPSILON", "KOMEGA", "KOMEGASST" ]
          },
          "timeDependency" : {
            "$ref" : "#/components/schemas/OneOf_IncompressibleTimeDependency"
          },
          "algorithm" : {
            "title" : "Algorithm",
            "type" : "string",
            "default" : "SIMPLE",
            "x-conditionalEnum" : [ {
              "value" : "SIMPLE",
              "when" : [ "type == INCOMPRESSIBLE && timeDependency.type == STATIONARY" ]
            }, {
              "value" : "PIMPLE",
              "when" : [ "type == INCOMPRESSIBLE && timeDependency.type == TRANSIENT" ]
            }, {
              "value" : "ICO",
              "when" : [ "type == INCOMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel == NONE" ]
            }, {
              "value" : "PISO",
              "when" : [ "type == INCOMPRESSIBLE && timeDependency.type == TRANSIENT" ]
            } ]
          },
          "numOfPassiveSpecies" : {
            "title" : "Passive species",
            "maximum" : 10,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "Select the number of passive species involved in the simulation. Passive species allow you to simulate the transport of a scalar quantity within a fluid flow without affecting it. <a href='https://www.simscale.com/docs/simulation-setup/global-settings/#passive-species' target='_blank'>Learn more</a>.",
            "format" : "int64",
            "default" : 0,
            "enum" : [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
          },
          "enableAdjointOptimization" : {
            "title" : "Adjoint optimization",
            "type" : "boolean",
            "default" : false,
            "x-conditionalEnum" : [ {
              "value" : true,
              "when" : [ "timeDependency.type == STATIONARY" ]
            }, {
              "value" : false,
              "when" : [ "timeDependency.type == TRANSIENT" ]
            }, {
              "value" : false,
              "when" : [ "timeDependency.type == STATIONARY" ]
            } ]
          },
          "model" : {
            "$ref" : "#/components/schemas/FluidModel"
          },
          "materials" : {
            "$ref" : "#/components/schemas/IncompressibleFluidMaterials"
          },
          "initialConditions" : {
            "$ref" : "#/components/schemas/FluidInitialConditions"
          },
          "boundaryConditions" : {
            "title" : "Boundary conditions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_IncompressibleBoundaryConditions"
            }
          },
          "advancedConcepts" : {
            "$ref" : "#/components/schemas/AdvancedConcepts"
          },
          "numerics" : {
            "$ref" : "#/components/schemas/FluidNumerics"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/FluidSimulationControl"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/FluidResultControls"
          }
        },
        "additionalProperties" : false
      },
      "FluidModel" : {
        "type" : "object",
        "properties" : {
          "turbulentSchmidtNumber" : {
            "title" : "(Sc<t>) Turb. Schmidt number",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.7,
            "x-showWhen" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 0", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 0", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 0" ]
          },
          "diffusionCoefficients" : {
            "title" : "Diffusion coefficients",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
            },
            "x-showWhen" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 0", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 0", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 0" ]
          },
          "deltaCoefficient" : {
            "$ref" : "#/components/schemas/OneOf_FluidModelDeltaCoefficient"
          },
          "gravity" : {
            "$ref" : "#/components/schemas/DimensionalVector_Acceleration"
          },
          "surfaceTension" : {
            "$ref" : "#/components/schemas/Dimensional_SurfaceTension"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_KinematicViscosity" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "lbfsin/lb" ]
          }
        },
        "additionalProperties" : false
      },
      "PrandtlLesDelta" : {
        "title" : "Prandtl LES delta",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PrandtlLesDelta",
            "default" : "PRANDTL"
          },
          "deltaCoefficient" : {
            "$ref" : "#/components/schemas/OneOf_PrandtlLesDeltaDeltaCoefficient"
          },
          "deltaReductionCoefficient" : {
            "title" : "Delta reduction coefficient",
            "type" : "number",
            "default" : 0.158
          }
        },
        "additionalProperties" : false
      },
      "SmoothLesDelta" : {
        "title" : "Smooth LES delta",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SmoothLesDelta",
            "default" : "SMOOTH"
          },
          "deltaCoefficient" : {
            "$ref" : "#/components/schemas/CubeRootVolLesDelta"
          },
          "maxDeltaRatio" : {
            "title" : "Max delta ratio",
            "type" : "number",
            "default" : 1.1
          }
        },
        "additionalProperties" : false
      },
      "CubeRootVolLesDelta" : {
        "title" : "Cube root vol LES delta",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CubeRootVolLesDelta",
            "default" : "CUBE_ROOT_VOL"
          },
          "deltaCoefficient" : {
            "title" : "Delta coefficient",
            "type" : "number",
            "default" : 1
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVector_Acceleration" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/DecimalVector"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "in/s" ]
          }
        },
        "additionalProperties" : false
      },
      "IncompressibleFluidMaterials" : {
        "type" : "object",
        "properties" : {
          "fluids" : {
            "title" : "Materials",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IncompressibleMaterial"
            }
          }
        },
        "additionalProperties" : false
      },
      "IncompressibleMaterial" : {
        "title" : "Material",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: IncompressibleMaterial",
            "default" : "INCOMPRESSIBLE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "associatedPhase" : {
            "title" : "Associated phase",
            "type" : "string",
            "description" : "<p>Select the corresponding phase for this material:</p><p><b>Phase 0</b> would mean this material is represented by the phase fraction value of 0. Hence, a phase fraction of '0' in your setup corresponds to 100% of this fluid material.</p><p><b>Phase 1</b> would mean this material is represented by the phase fraction value of 1. Hence, a phase fraction of '1' in your setup corresponds to 100% of this fluid material.</p>",
            "default" : "PHASE_1",
            "enum" : [ "PHASE_0", "PHASE_1" ],
            "x-showWhen" : [ "type == MULTIPHASE" ]
          },
          "viscosityModel" : {
            "$ref" : "#/components/schemas/OneOf_IncompressibleMaterialViscosityModel"
          },
          "density" : {
            "$ref" : "#/components/schemas/Dimensional_Density"
          },
          "thermalExpansionCoefficient" : {
            "$ref" : "#/components/schemas/Dimensional_ThermalExpansionRate"
          },
          "referenceTemperature" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          },
          "laminarPrandtlNumber" : {
            "title" : "(Pr<lam>) Laminar Prandtl number",
            "type" : "number",
            "description" : "Laminar Prandtl number is used to calculate the heat transfer in the domain.",
            "x-showWhen" : [ "type in [CONVECTIVE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ]
          },
          "turbulentPrandtlNumber" : {
            "title" : "(Pr<t>) Turb. Prandtl number",
            "type" : "number",
            "description" : "Turbulent Prandtl number is used to calculate the heat transfer due to turbulent effects in the domain.",
            "x-showWhen" : [ "type in [CONVECTIVE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ]
          },
          "specificHeat" : {
            "$ref" : "#/components/schemas/Dimensional_SpecificHeat"
          },
          "molarWeight" : {
            "$ref" : "#/components/schemas/Dimensional_MolarMass"
          },
          "cavitation" : {
            "$ref" : "#/components/schemas/Cavitation"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-showWhen" : [ "type == EMBEDDED_BOUNDARY && isInternalFlow == false" ],
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX" ]
            }
          },
          "builtInMaterial" : {
            "type" : "string"
          },
          "materialLibraryReference" : {
            "$ref" : "#/components/schemas/MaterialLibraryReference"
          }
        },
        "additionalProperties" : false
      },
      "NewtonianViscosityModel" : {
        "title" : "Newtonian",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Choose between <a href='https://www.simscale.com/docs/simulation-setup/materials/#newtonian-model' target='_blank'>Newtonian</a> and <a href='https://www.simscale.com/docs/simulation-setup/materials/non-newtonian-models/' target='_blank'>Non-Newtonian</a> viscosity models.\n\nSchema name: NewtonianViscosityModel",
            "default" : "NEWTONIAN"
          },
          "kinematicViscosity" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          }
        },
        "additionalProperties" : false,
        "description" : "Choose between <a href='https://www.simscale.com/docs/simulation-setup/materials/#newtonian-model' target='_blank'>Newtonian</a> and <a href='https://www.simscale.com/docs/simulation-setup/materials/non-newtonian-models/' target='_blank'>Non-Newtonian</a> viscosity models."
      },
      "PowerLawViscosityModel" : {
        "title" : "Power law",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Choose between <a href='https://www.simscale.com/docs/simulation-setup/materials/#newtonian-model' target='_blank'>Newtonian</a> and <a href='https://www.simscale.com/docs/simulation-setup/materials/non-newtonian-models/' target='_blank'>Non-Newtonian</a> viscosity models.\n\nSchema name: PowerLawViscosityModel",
            "default" : "POWER_LAW"
          },
          "k" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          },
          "n" : {
            "$ref" : "#/components/schemas/Dimensional_Dimensionless"
          },
          "nuMin" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          },
          "nuMax" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          }
        },
        "additionalProperties" : false,
        "description" : "Choose between <a href='https://www.simscale.com/docs/simulation-setup/materials/#newtonian-model' target='_blank'>Newtonian</a> and <a href='https://www.simscale.com/docs/simulation-setup/materials/non-newtonian-models/' target='_blank'>Non-Newtonian</a> viscosity models."
      },
      "Dimensional_Dimensionless" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "" ]
          }
        },
        "additionalProperties" : false
      },
      "HerschelBulkleyViscosityModel" : {
        "title" : "HerschelBulkley",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Choose between <a href='https://www.simscale.com/docs/simulation-setup/materials/#newtonian-model' target='_blank'>Newtonian</a> and <a href='https://www.simscale.com/docs/simulation-setup/materials/non-newtonian-models/' target='_blank'>Non-Newtonian</a> viscosity models.\n\nSchema name: HerschelBulkleyViscosityModel",
            "default" : "HERSCHEL_BULKLEY"
          },
          "k" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          },
          "n" : {
            "$ref" : "#/components/schemas/Dimensional_Dimensionless"
          },
          "tau0" : {
            "$ref" : "#/components/schemas/Dimensional_TurbulenceKineticEnergy"
          },
          "nu0" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          }
        },
        "additionalProperties" : false,
        "description" : "Choose between <a href='https://www.simscale.com/docs/simulation-setup/materials/#newtonian-model' target='_blank'>Newtonian</a> and <a href='https://www.simscale.com/docs/simulation-setup/materials/non-newtonian-models/' target='_blank'>Non-Newtonian</a> viscosity models."
      },
      "Dimensional_TurbulenceKineticEnergy" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "Btu/lb" ]
          }
        },
        "additionalProperties" : false
      },
      "CrossPowerLawViscosityModel" : {
        "title" : "Cross-Power law",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Choose between <a href='https://www.simscale.com/docs/simulation-setup/materials/#newtonian-model' target='_blank'>Newtonian</a> and <a href='https://www.simscale.com/docs/simulation-setup/materials/non-newtonian-models/' target='_blank'>Non-Newtonian</a> viscosity models.\n\nSchema name: CrossPowerLawViscosityModel",
            "default" : "CROSS_POWER_LAW"
          },
          "nu0" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          },
          "nuInf" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          },
          "m" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "n" : {
            "$ref" : "#/components/schemas/Dimensional_Dimensionless"
          }
        },
        "additionalProperties" : false,
        "description" : "Choose between <a href='https://www.simscale.com/docs/simulation-setup/materials/#newtonian-model' target='_blank'>Newtonian</a> and <a href='https://www.simscale.com/docs/simulation-setup/materials/non-newtonian-models/' target='_blank'>Non-Newtonian</a> viscosity models."
      },
      "BirdCarreauViscosityModel" : {
        "title" : "Bird-Carreau",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Choose between <a href='https://www.simscale.com/docs/simulation-setup/materials/#newtonian-model' target='_blank'>Newtonian</a> and <a href='https://www.simscale.com/docs/simulation-setup/materials/non-newtonian-models/' target='_blank'>Non-Newtonian</a> viscosity models.\n\nSchema name: BirdCarreauViscosityModel",
            "default" : "BIRD_CARREAU"
          },
          "nu0" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          },
          "nuInf" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          },
          "k" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "n" : {
            "$ref" : "#/components/schemas/Dimensional_Dimensionless"
          },
          "a" : {
            "$ref" : "#/components/schemas/Dimensional_Dimensionless"
          }
        },
        "additionalProperties" : false,
        "description" : "Choose between <a href='https://www.simscale.com/docs/simulation-setup/materials/#newtonian-model' target='_blank'>Newtonian</a> and <a href='https://www.simscale.com/docs/simulation-setup/materials/non-newtonian-models/' target='_blank'>Non-Newtonian</a> viscosity models."
      },
      "Dimensional_Density" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "kg/m", "lb/in" ]
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_ThermalExpansionRate" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/K", "1/F" ]
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_SpecificHeat" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "J/(kgK)", "Btu/(lbF)" ]
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_MolarMass" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "kg/kmol", "lb/kmol" ]
          }
        },
        "additionalProperties" : false
      },
      "Cavitation" : {
        "type" : "object",
        "properties" : {
          "vaporMolecularWeight" : {
            "$ref" : "#/components/schemas/Dimensional_MolarMass"
          },
          "liquidBulkModulus" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "liquidBulkModulusCoefficient" : {
            "title" : "Liquid bulk modulus coefficient",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "The <b>liquid bulk modulus coefficient</b> <i>B<sub>1</sub></i> accounts for a linear rate of change in the liquid bulk modulus with respect to pressure such that <i>B = B<sub>0</sub> + B<sub>1</sub> (P - P<sub>ref</sub>)</i>, where <i>B<sub>0</sub></i> is the constant liquid bulk modulus. Typically only applicable in cases where pressure differences exceed 100 bar, otherwise a zero value should be specified.",
            "default" : 0
          },
          "liquidReferencePressure" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "saturationPressure" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "liquidTemperature" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          }
        },
        "additionalProperties" : false
      },
      "FluidInitialConditions" : {
        "type" : "object",
        "properties" : {
          "pressure" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_Pressure"
          },
          "pressureRgh" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_Pressure"
          },
          "gaugePressure" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_Pressure"
          },
          "gaugePressureRgh" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_Pressure"
          },
          "velocity" : {
            "$ref" : "#/components/schemas/DimensionalVectorInitialConditionDomains_Speed"
          },
          "temperature" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_Temperature"
          },
          "turbulentKineticEnergy" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_TurbulenceKineticEnergy"
          },
          "omegaDissipationRate" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_SpecificTurbulenceDissipationRate"
          },
          "epsilonDissipationRate" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_TurbulentDissipation"
          },
          "eddyViscosity" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_DynamicViscosity"
          },
          "eddyViscosityMultiphase" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_KinematicViscosity"
          },
          "eddyViscosityCompressible" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_DynamicViscosity"
          },
          "nuTilda" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_KinematicViscosity"
          },
          "turbulentThermalDiffusivity" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_DynamicViscosity"
          },
          "turbulentThermalDiffusivityCompressible" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_DynamicViscosity"
          },
          "turbulentDynamicViscosity" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_DynamicViscosity"
          },
          "passiveScalars" : {
            "title" : "Passive scalars",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_Dimensionless"
            },
            "x-showWhen" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 0", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 0", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 0" ]
          },
          "phaseFraction" : {
            "$ref" : "#/components/schemas/DimensionalInitialConditionDomains_Dimensionless"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalInitialConditionDomains_Pressure" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "subdomains" : {
            "title" : "Subdomains",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SubdomainDimensionalInitialCondition_Pressure"
            },
            "x-showWhen" : [ "1# in [pressureRgh,temperature,phaseFraction,passiveScalars]", "2# == passiveScalars", "type == CONVECTIVE_HEAT_TRANSFER && 1# == gaugePressureRgh" ]
          }
        },
        "additionalProperties" : false
      },
      "SubdomainDimensionalInitialCondition_Pressure" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "subdomainValue" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVectorInitialConditionDomains_Speed" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/DimensionalVector_Speed"
          },
          "subdomains" : {
            "title" : "Subdomains",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SubdomainDimensionalVectorInitialCondition_Speed"
            },
            "x-showWhen" : [ "1# == velocity" ]
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVector_Speed" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/DecimalVector"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "in/s", "cm/s", "km/h", "mph", "ft/s", "ft/min" ]
          }
        },
        "additionalProperties" : false
      },
      "SubdomainDimensionalVectorInitialCondition_Speed" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "subdomainValue" : {
            "$ref" : "#/components/schemas/DimensionalVector_Speed"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "DimensionalInitialConditionDomains_Temperature" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          },
          "subdomains" : {
            "title" : "Subdomains",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SubdomainDimensionalInitialCondition_Temperature"
            },
            "x-showWhen" : [ "1# in [pressureRgh,temperature,phaseFraction,passiveScalars]", "2# == passiveScalars", "type == CONVECTIVE_HEAT_TRANSFER && 1# == gaugePressureRgh" ]
          }
        },
        "additionalProperties" : false
      },
      "SubdomainDimensionalInitialCondition_Temperature" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "subdomainValue" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "DimensionalInitialConditionDomains_TurbulenceKineticEnergy" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/Dimensional_TurbulenceKineticEnergy"
          },
          "subdomains" : {
            "title" : "Subdomains",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SubdomainDimensionalInitialCondition_TurbulenceKineticEnergy"
            },
            "x-showWhen" : [ "1# in [pressureRgh,temperature,phaseFraction,passiveScalars]", "2# == passiveScalars", "type == CONVECTIVE_HEAT_TRANSFER && 1# == gaugePressureRgh" ]
          }
        },
        "additionalProperties" : false
      },
      "SubdomainDimensionalInitialCondition_TurbulenceKineticEnergy" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "subdomainValue" : {
            "$ref" : "#/components/schemas/Dimensional_TurbulenceKineticEnergy"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "DimensionalInitialConditionDomains_SpecificTurbulenceDissipationRate" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/Dimensional_SpecificTurbulenceDissipationRate"
          },
          "subdomains" : {
            "title" : "Subdomains",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SubdomainDimensionalInitialCondition_SpecificTurbulenceDissipationRate"
            },
            "x-showWhen" : [ "1# in [pressureRgh,temperature,phaseFraction,passiveScalars]", "2# == passiveScalars", "type == CONVECTIVE_HEAT_TRANSFER && 1# == gaugePressureRgh" ]
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_SpecificTurbulenceDissipationRate" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/s" ]
          }
        },
        "additionalProperties" : false
      },
      "SubdomainDimensionalInitialCondition_SpecificTurbulenceDissipationRate" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "subdomainValue" : {
            "$ref" : "#/components/schemas/Dimensional_SpecificTurbulenceDissipationRate"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "DimensionalInitialConditionDomains_TurbulentDissipation" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/Dimensional_TurbulentDissipation"
          },
          "subdomains" : {
            "title" : "Subdomains",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SubdomainDimensionalInitialCondition_TurbulentDissipation"
            },
            "x-showWhen" : [ "1# in [pressureRgh,temperature,phaseFraction,passiveScalars]", "2# == passiveScalars", "type == CONVECTIVE_HEAT_TRANSFER && 1# == gaugePressureRgh" ]
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_TurbulentDissipation" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "lbfin/(slb)" ]
          }
        },
        "additionalProperties" : false
      },
      "SubdomainDimensionalInitialCondition_TurbulentDissipation" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "subdomainValue" : {
            "$ref" : "#/components/schemas/Dimensional_TurbulentDissipation"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "DimensionalInitialConditionDomains_DynamicViscosity" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/Dimensional_DynamicViscosity"
          },
          "subdomains" : {
            "title" : "Subdomains",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SubdomainDimensionalInitialCondition_DynamicViscosity"
            },
            "x-showWhen" : [ "1# in [pressureRgh,temperature,phaseFraction,passiveScalars]", "2# == passiveScalars", "type == CONVECTIVE_HEAT_TRANSFER && 1# == gaugePressureRgh" ]
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_DynamicViscosity" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "kg/(sm)", "lbfs/in" ]
          }
        },
        "additionalProperties" : false
      },
      "SubdomainDimensionalInitialCondition_DynamicViscosity" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "subdomainValue" : {
            "$ref" : "#/components/schemas/Dimensional_DynamicViscosity"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "DimensionalInitialConditionDomains_KinematicViscosity" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          },
          "subdomains" : {
            "title" : "Subdomains",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SubdomainDimensionalInitialCondition_KinematicViscosity"
            },
            "x-showWhen" : [ "1# in [pressureRgh,temperature,phaseFraction,passiveScalars]", "2# == passiveScalars", "type == CONVECTIVE_HEAT_TRANSFER && 1# == gaugePressureRgh" ]
          }
        },
        "additionalProperties" : false
      },
      "SubdomainDimensionalInitialCondition_KinematicViscosity" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "subdomainValue" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "DimensionalInitialConditionDomains_Dimensionless" : {
        "type" : "object",
        "properties" : {
          "global" : {
            "$ref" : "#/components/schemas/Dimensional_Dimensionless"
          },
          "subdomains" : {
            "title" : "Subdomains",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SubdomainDimensionalInitialCondition_Dimensionless"
            },
            "x-showWhen" : [ "1# in [pressureRgh,temperature,phaseFraction,passiveScalars]", "2# == passiveScalars", "type == CONVECTIVE_HEAT_TRANSFER && 1# == gaugePressureRgh" ]
          }
        },
        "additionalProperties" : false
      },
      "SubdomainDimensionalInitialCondition_Dimensionless" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "subdomainValue" : {
            "$ref" : "#/components/schemas/Dimensional_Dimensionless"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "VelocityInletBC" : {
        "title" : "Velocity inlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This boundary condition imposes a known <b>velocity</b>-based constraint at an inlet.\n\nSchema name: VelocityInletBC",
            "default" : "VELOCITY_INLET_V3"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "velocity" : {
            "$ref" : "#/components/schemas/OneOf_VelocityInletBCVelocity"
          },
          "temperature" : {
            "$ref" : "#/components/schemas/OneOf_VelocityInletBCTemperature"
          },
          "passiveScalars" : {
            "title" : "Passive scalars",
            "type" : "array",
            "description" : "Please choose a boundary condition for passive scalar (T).",
            "items" : {
              "$ref" : "#/components/schemas/FixedValuePSBC"
            },
            "x-showWhen" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 0", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 0", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 0" ]
          },
          "phaseFraction" : {
            "$ref" : "#/components/schemas/FixedValuePFBC"
          },
          "turbulenceIntensity" : {
            "$ref" : "#/components/schemas/OneOf_VelocityInletBCTurbulenceIntensity"
          },
          "dissipationType" : {
            "$ref" : "#/components/schemas/OneOf_VelocityInletBCDissipationType"
          },
          "netRadiativeHeatFlux" : {
            "$ref" : "#/components/schemas/OneOf_VelocityInletBCNetRadiativeHeatFlux"
          },
          "radiativeIntensityRay" : {
            "$ref" : "#/components/schemas/OneOf_VelocityInletBCRadiativeIntensityRay"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This boundary condition imposes a known <b>velocity</b>-based constraint at an inlet."
      },
      "FixedValueVBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedValueVBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Speed"
          }
        },
        "additionalProperties" : false
      },
      "MeanValueVBC" : {
        "title" : "Mean value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: MeanValueVBC",
            "default" : "FIXED_MEAN"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalVector_Speed"
          }
        },
        "additionalProperties" : false
      },
      "FixedMagnitudeVBC" : {
        "title" : "Fixed magnitude",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedMagnitudeVBC",
            "default" : "FIXED_VALUE_NO_EXPRESSION"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Speed"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalFunction_Speed" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_SpeedValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "in/s", "cm/s", "km/h", "mph", "ft/s", "ft/min" ]
          }
        },
        "additionalProperties" : false
      },
      "VariableGroup_HEIGHT" : {
        "type" : "object",
        "properties" : {
          "HEIGHT" : {
            "$ref" : "#/components/schemas/Unit_Length"
          }
        }
      },
      "FlowRateInletVBC" : {
        "title" : "Flow rate",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FlowRateInletVBC",
            "default" : "FLOW_RATE_INLET_VELOCITY"
          },
          "flowRate" : {
            "$ref" : "#/components/schemas/OneOf_FlowRateInletVBCFlowRate"
          }
        },
        "additionalProperties" : false
      },
      "MassFlow" : {
        "title" : "() Mass flow",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Defines the mass flow rate <strong>per each face</strong> of the assignment.</p>\n\nSchema name: MassFlow",
            "default" : "MASS"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalFunction_MassFlowRate"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Defines the mass flow rate <strong>per each face</strong> of the assignment.</p>"
      },
      "DimensionalFunction_MassFlowRate" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_MassFlowRateValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "kg/s", "lb/s" ]
          }
        },
        "additionalProperties" : false
      },
      "VolumetricFlow" : {
        "title" : "(V) Volumetric flow",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Defines the volumetric flow rate <strong>per each face</strong> of the assignment.</p>\n\nSchema name: VolumetricFlow",
            "default" : "VOLUMETRIC"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalFunction_VolumetricFlowRate"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Defines the volumetric flow rate <strong>per each face</strong> of the assignment.</p>"
      },
      "DimensionalFunction_VolumetricFlowRate" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_VolumetricFlowRateValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "in/s" ]
          }
        },
        "additionalProperties" : false
      },
      "FlowRateMeanInletVBC" : {
        "title" : "Mean flow rate",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FlowRateMeanInletVBC",
            "default" : "FLOW_RATE_MEAN_INLET_VELOCITY"
          },
          "flowRate" : {
            "$ref" : "#/components/schemas/OneOf_FlowRateMeanInletVBCFlowRate"
          }
        },
        "additionalProperties" : false
      },
      "FreestreamVBC" : {
        "title" : "Freestream",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FreestreamVBC",
            "default" : "FREESTREAM"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalVector_Speed"
          }
        },
        "additionalProperties" : false
      },
      "FixedValueTBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedValueTBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Temperature"
          }
        },
        "additionalProperties" : false
      },
      "TotalTBC" : {
        "title" : "Total temperature",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TotalTBC",
            "default" : "TOTAL_TEMPERATURE"
          },
          "totalTemperature" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          },
          "specificHeatRatio" : {
            "title" : "() Gamma",
            "minimum" : 0,
            "exclusiveMinimum" : true,
            "type" : "number",
            "default" : 1.4,
            "x-showWhen" : [ "type != SIMERICS_ANALYSIS" ]
          }
        },
        "additionalProperties" : false
      },
      "FixedValuePSBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedValuePSBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_Dimensionless"
          }
        },
        "additionalProperties" : false
      },
      "FixedValuePFBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedValuePFBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_Dimensionless"
          }
        },
        "additionalProperties" : false
      },
      "TurbulenceIntensityTIBC" : {
        "title" : "Intensity",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TurbulenceIntensityTIBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Dimensionless"
          }
        },
        "additionalProperties" : false
      },
      "TurbulenceKineticEnergyTIBC" : {
        "title" : "Turbulent Kinetic Energy",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TurbulenceKineticEnergyTIBC",
            "default" : "TURBULENCE_KINETIC_ENERGY"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalFunction_TurbulenceKineticEnergy"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalFunction_TurbulenceKineticEnergy" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_TurbulenceKineticEnergyValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "Btu/lb" ]
          }
        },
        "additionalProperties" : false
      },
      "AutomaticOmegaDissipation" : {
        "title" : "Automatic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AutomaticOmegaDissipation",
            "default" : "AUTOMATIC_DISSIPATION"
          }
        },
        "additionalProperties" : false
      },
      "CustomOmegaDissipation" : {
        "title" : "Custom",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CustomOmegaDissipation",
            "default" : "CUSTOM_DISSIPATION"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalFunction_SpecificTurbulenceDissipationRate"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalFunction_SpecificTurbulenceDissipationRate" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_SpecificTurbulenceDissipationRateValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/s" ]
          }
        },
        "additionalProperties" : false
      },
      "GreybodyDiffusiveRSBC" : {
        "title" : "Opaque",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GreybodyDiffusiveRSBC",
            "default" : "GREYBODY_DIFFUSIVE"
          },
          "emissivity" : {
            "$ref" : "#/components/schemas/Dimensional_Dimensionless"
          }
        },
        "additionalProperties" : false
      },
      "OpenWindowRSBC" : {
        "title" : "Transparent",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: OpenWindowRSBC",
            "default" : "OPEN_WINDOW"
          },
          "radiativeSourceValue" : {
            "$ref" : "#/components/schemas/Dimensional_HeatFlux"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_HeatFlux" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "W/m", "Btu/(sin)" ]
          }
        },
        "additionalProperties" : false
      },
      "GreybodyDiffusiveRayBC" : {
        "title" : "Opaque",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GreybodyDiffusiveRayBC",
            "default" : "GREYBODY_DIFFUSIVE_RAY"
          },
          "emissivity" : {
            "title" : "Emissivity",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.9
          }
        },
        "additionalProperties" : false
      },
      "OpenBoundaryRayBC" : {
        "title" : "Transparent",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: OpenBoundaryRayBC",
            "default" : "OPEN_BOUNDARY_RAY"
          },
          "farfieldBlackBodyTemperature" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          }
        },
        "additionalProperties" : false
      },
      "SemiOpenBoundaryRayBC" : {
        "title" : "Semi-transparent",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SemiOpenBoundaryRayBC",
            "default" : "SEMI_OPEN_BOUNDARY_RAY"
          },
          "emissivity" : {
            "title" : "Emissivity",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.1
          },
          "transmissivity" : {
            "title" : "Transmissivity",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.7
          },
          "farfieldBlackBodyTemperature" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          }
        },
        "additionalProperties" : false
      },
      "VelocityOutletBC" : {
        "title" : "Velocity outlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This boundary condition imposes a known <b>velocity</b>-based constraint at an outlet.\n\nSchema name: VelocityOutletBC",
            "default" : "VELOCITY_OUTLET_V7"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "velocity" : {
            "$ref" : "#/components/schemas/OneOf_VelocityOutletBCVelocity"
          },
          "phaseFraction" : {
            "$ref" : "#/components/schemas/OneOf_VelocityOutletBCPhaseFraction"
          },
          "netRadiativeHeatFlux" : {
            "$ref" : "#/components/schemas/OneOf_VelocityOutletBCNetRadiativeHeatFlux"
          },
          "radiativeIntensityRay" : {
            "$ref" : "#/components/schemas/OneOf_VelocityOutletBCRadiativeIntensityRay"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This boundary condition imposes a known <b>velocity</b>-based constraint at an outlet."
      },
      "OutletMeanPhaseVBC" : {
        "title" : "Outlet mean phase",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: OutletMeanPhaseVBC",
            "default" : "OUTLET_MEAN_PHASE"
          },
          "phase" : {
            "title" : "Phase",
            "type" : "string",
            "default" : "PHASE_1",
            "enum" : [ "PHASE_0", "PHASE_1" ]
          },
          "meanVelocity" : {
            "$ref" : "#/components/schemas/Dimensional_Speed"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_Speed" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "in/s", "cm/s", "km/h", "mph", "ft/s", "ft/min" ]
          }
        },
        "additionalProperties" : false
      },
      "FlowRateOutletVBC" : {
        "title" : "Flow rate",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FlowRateOutletVBC",
            "default" : "FLOW_RATE_OUTLET_VELOCITY"
          },
          "flowRate" : {
            "$ref" : "#/components/schemas/OneOf_FlowRateOutletVBCFlowRate"
          }
        },
        "additionalProperties" : false
      },
      "FlowRateMeanOutletVBC" : {
        "title" : "Mean flow rate",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FlowRateMeanOutletVBC",
            "default" : "FLOW_RATE_MEAN_OUTLET_VELOCITY"
          },
          "flowRate" : {
            "$ref" : "#/components/schemas/OneOf_FlowRateMeanOutletVBCFlowRate"
          }
        },
        "additionalProperties" : false
      },
      "FlowRateStableOutletVBC" : {
        "title" : "Flow rate",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FlowRateStableOutletVBC",
            "default" : "FLOW_RATE_STABLE_OUTLET_VELOCITY"
          },
          "flowRate" : {
            "$ref" : "#/components/schemas/OneOf_FlowRateStableOutletVBCFlowRate"
          }
        },
        "additionalProperties" : false
      },
      "MeanValueOutletVBC" : {
        "title" : "Face normal value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: MeanValueOutletVBC",
            "default" : "MEAN_VALUE_OUTLET_VELOCITY"
          },
          "normalVelocity" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Speed"
          }
        },
        "additionalProperties" : false
      },
      "FlowDependentValuePFBC" : {
        "title" : "Flow dependent value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FlowDependentValuePFBC",
            "default" : "FLOW_DEPENDENT_VALUE"
          },
          "lowerBound" : {
            "title" : "Lower bound",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0
          },
          "upperBound" : {
            "title" : "Upper bound",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 1
          }
        },
        "additionalProperties" : false
      },
      "PressureInletBC" : {
        "title" : "Pressure inlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This boundary condition is suitable for inlet and open boundaries where the value of <b>pressure</b> is known.\n\nSchema name: PressureInletBC",
            "default" : "PRESSURE_INLET_V31"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "pressure" : {
            "$ref" : "#/components/schemas/TotalPBC"
          },
          "pressureRgh" : {
            "$ref" : "#/components/schemas/TotalPBC"
          },
          "gaugePressure" : {
            "$ref" : "#/components/schemas/OneOf_PressureInletBCGaugePressure"
          },
          "gaugePressureRgh" : {
            "$ref" : "#/components/schemas/TotalPBC"
          },
          "temperature" : {
            "$ref" : "#/components/schemas/OneOf_PressureInletBCTemperature"
          },
          "passiveScalars" : {
            "title" : "Passive scalars",
            "type" : "array",
            "description" : "Please choose a boundary condition for passive scalar (T).",
            "items" : {
              "$ref" : "#/components/schemas/FixedValuePSBC"
            },
            "x-showWhen" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 0", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 0", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 0" ]
          },
          "phaseFraction" : {
            "$ref" : "#/components/schemas/FixedValuePFBC"
          },
          "netRadiativeHeatFlux" : {
            "$ref" : "#/components/schemas/OneOf_PressureInletBCNetRadiativeHeatFlux"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This boundary condition is suitable for inlet and open boundaries where the value of <b>pressure</b> is known."
      },
      "TotalPBC" : {
        "title" : "Total pressure",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TotalPBC",
            "default" : "TOTAL_PRESSURE"
          },
          "totalPressure" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Pressure"
          }
        },
        "additionalProperties" : false
      },
      "FixedValuePBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedValuePBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Pressure"
          }
        },
        "additionalProperties" : false
      },
      "PressureOutletBC" : {
        "title" : "Pressure outlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This boundary condition allows to specify a <b>pressure</b> value at an outlet boundary.\n\nSchema name: PressureOutletBC",
            "default" : "PRESSURE_OUTLET_V30"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "pressure" : {
            "$ref" : "#/components/schemas/OneOf_PressureOutletBCPressure"
          },
          "pressureRgh" : {
            "$ref" : "#/components/schemas/OneOf_PressureOutletBCPressureRgh"
          },
          "gaugePressure" : {
            "$ref" : "#/components/schemas/OneOf_PressureOutletBCGaugePressure"
          },
          "gaugePressureRgh" : {
            "$ref" : "#/components/schemas/OneOf_PressureOutletBCGaugePressureRgh"
          },
          "netRadiativeHeatFlux" : {
            "$ref" : "#/components/schemas/OneOf_PressureOutletBCNetRadiativeHeatFlux"
          },
          "radiativeIntensityRay" : {
            "$ref" : "#/components/schemas/OneOf_PressureOutletBCRadiativeIntensityRay"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This boundary condition allows to specify a <b>pressure</b> value at an outlet boundary."
      },
      "MeanValuePBC" : {
        "title" : "Mean value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: MeanValuePBC",
            "default" : "FIXED_MEAN"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          }
        },
        "additionalProperties" : false
      },
      "WallBC" : {
        "title" : "Wall",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>This boundary provides several Solid Wall conditions.</P>The default <b>no-slip</b> corresponds to friction wall with no movement. The <b>slip wall</b> models a surface with no friction. The <b>rotating/moving wall</b> model wall movement by prescribing velocities. <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/wall/' target='_blank'>Learn more</a>.\n\nSchema name: WallBC",
            "default" : "WALL_V34"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "velocity" : {
            "$ref" : "#/components/schemas/OneOf_WallBCVelocity"
          },
          "temperature" : {
            "$ref" : "#/components/schemas/OneOf_WallBCTemperature"
          },
          "phaseFraction" : {
            "$ref" : "#/components/schemas/OneOf_WallBCPhaseFraction"
          },
          "netRadiativeHeatFlux" : {
            "$ref" : "#/components/schemas/OneOf_WallBCNetRadiativeHeatFlux"
          },
          "radiativeIntensityRay" : {
            "$ref" : "#/components/schemas/OneOf_WallBCRadiativeIntensityRay"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>This boundary provides several Solid Wall conditions.</P>The default <b>no-slip</b> corresponds to friction wall with no movement. The <b>slip wall</b> models a surface with no friction. The <b>rotating/moving wall</b> model wall movement by prescribing velocities. <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/wall/' target='_blank'>Learn more</a>."
      },
      "MovingWallVBC" : {
        "title" : "Moving wall",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: MovingWallVBC",
            "default" : "MOVING_WALL_VELOCITY"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalVector_Speed"
          },
          "turbulenceWall" : {
            "title" : "Turbulence wall",
            "type" : "string",
            "default" : "WALL_FUNCTION",
            "enum" : [ "WALL_FUNCTION", "FULL_RESOLUTION" ],
            "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE] && turbulenceModel != NONE" ]
          },
          "orientationReference" : {
            "title" : "Orientation reference",
            "type" : "string",
            "default" : "FLOW_DOMAIN",
            "enum" : [ "GEOMETRY", "FLOW_DOMAIN" ],
            "x-showWhen" : [ "type == INCOMPRESSIBLE_PACEFISH" ]
          }
        },
        "additionalProperties" : false
      },
      "NoSlipVBC" : {
        "title" : "No-slip",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NoSlipVBC",
            "default" : "NO_SLIP"
          },
          "turbulenceWall" : {
            "title" : "Turbulence wall",
            "type" : "string",
            "default" : "WALL_FUNCTION",
            "enum" : [ "WALL_FUNCTION", "FULL_RESOLUTION" ],
            "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE] && turbulenceModel != NONE" ]
          },
          "surfaceRoughness" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "RotatingWallVBC" : {
        "title" : "Rotating wall",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: RotatingWallVBC",
            "default" : "ROTATING_WALL_VELOCITY"
          },
          "rotation" : {
            "$ref" : "#/components/schemas/AngularRotation"
          },
          "turbulenceWall" : {
            "title" : "Turbulence wall",
            "type" : "string",
            "default" : "WALL_FUNCTION",
            "enum" : [ "WALL_FUNCTION", "FULL_RESOLUTION" ],
            "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE] && turbulenceModel != NONE" ]
          }
        },
        "additionalProperties" : false
      },
      "SlipVBC" : {
        "title" : "Slip",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SlipVBC",
            "default" : "SLIP"
          }
        },
        "additionalProperties" : false
      },
      "ExternalWallHeatFluxTBC" : {
        "title" : "External wall heat flux",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ExternalWallHeatFluxTBC",
            "default" : "EXTERNAL_WALL_HEAT_FLUX_TEMPERATURE"
          },
          "heatFlux" : {
            "$ref" : "#/components/schemas/OneOf_ExternalWallHeatFluxTBCHeatFlux"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          }
        },
        "additionalProperties" : false
      },
      "DerivedHeatFlux" : {
        "title" : "Derived heat flux",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: DerivedHeatFlux",
            "default" : "DERIVED"
          },
          "heatTransferCoefficient" : {
            "$ref" : "#/components/schemas/Dimensional_ThermalTransmittance"
          },
          "ambientTemperature" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          },
          "additionalHeatFlux" : {
            "$ref" : "#/components/schemas/Dimensional_HeatFlux"
          },
          "wallThermal" : {
            "$ref" : "#/components/schemas/OneOf_DerivedHeatFluxWallThermal"
          },
          "outerSurfaceEmissivity" : {
            "title" : "Outer surface emissivity",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "Emissivity/Absorptivity of the outer side of the surface or the last wall thermal layer.",
            "default" : 0.9,
            "x-showWhen" : [ "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableRadiation == true", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableSolarLoad == true" ]
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_ThermalTransmittance" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "W/(Km)", "Btu/(sinF)" ]
          }
        },
        "additionalProperties" : false
      },
      "NoWallThermal" : {
        "title" : "No wall thermal",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NoWallThermal",
            "default" : "NO_RESISTANCE"
          }
        },
        "additionalProperties" : false
      },
      "TotalResistanceWallThermal" : {
        "title" : "Total resistance wall thermal",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TotalResistanceWallThermal",
            "default" : "TOTAL_RESISTANCE"
          },
          "contactResistance" : {
            "$ref" : "#/components/schemas/Dimensional_ContactResistance"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_ContactResistance" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "K/W", "Fs/Btu" ]
          }
        },
        "additionalProperties" : false
      },
      "SpecificConductanceWallThermal" : {
        "title" : "Specific conductance wall thermal",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SpecificConductanceWallThermal",
            "default" : "SPECIFIC_CONDUCTANCE"
          },
          "contactConductance" : {
            "$ref" : "#/components/schemas/Dimensional_ThermalTransmittance"
          }
        },
        "additionalProperties" : false
      },
      "LayerWallThermal" : {
        "title" : "Layer wall thermal",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: LayerWallThermal",
            "default" : "CONTACT_INTERFACE_MATERIAL"
          },
          "conductivityThicknessPairs" : {
            "title" : "Conductivity thickness pairs",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ConductivityThicknessPair"
            }
          }
        },
        "additionalProperties" : false
      },
      "ConductivityThicknessPair" : {
        "type" : "object",
        "properties" : {
          "thermalConductivity" : {
            "$ref" : "#/components/schemas/Dimensional_ThermalConductivity"
          },
          "layerThickness" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_ThermalConductivity" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "W/(mK)", "Btu/(sinF)" ]
          }
        },
        "additionalProperties" : false
      },
      "FixedHeatFlux" : {
        "title" : "Fixed heat flux",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedHeatFlux",
            "default" : "FIXED"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_HeatFlux"
          }
        },
        "additionalProperties" : false
      },
      "FixedPowerHeatFlux" : {
        "title" : "Fixed power",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedPowerHeatFlux",
            "default" : "FIXED_POWER"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_Power"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_Power" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "W", "Btu/s" ]
          }
        },
        "additionalProperties" : false
      },
      "AdiabaticTBC" : {
        "title" : "Adiabatic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AdiabaticTBC",
            "default" : "ADIABATIC"
          }
        },
        "additionalProperties" : false
      },
      "TurbulentHeatFluxTBC" : {
        "title" : "Turbulent heat flux",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TurbulentHeatFluxTBC",
            "default" : "TURBULENT_HEAT_FLUX_TEMPERATURE"
          },
          "heatSource" : {
            "$ref" : "#/components/schemas/OneOf_TurbulentHeatFluxTBCHeatSource"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          }
        },
        "additionalProperties" : false
      },
      "FluxHeatSource" : {
        "title" : "Flux heat source",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FluxHeatSource",
            "default" : "FLUX"
          },
          "heatFlux" : {
            "$ref" : "#/components/schemas/Dimensional_HeatFlux"
          }
        },
        "additionalProperties" : false
      },
      "PowerHeatSource" : {
        "title" : "Power heat source",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PowerHeatSource",
            "default" : "POWER"
          },
          "power" : {
            "$ref" : "#/components/schemas/Dimensional_Power"
          }
        },
        "additionalProperties" : false
      },
      "ConstantContactAnglePFBC" : {
        "title" : "Constant contact angle",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ConstantContactAnglePFBC",
            "default" : "CONSTANT_CONTACT_ANGLE"
          },
          "equilibriumContactAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "limit" : {
            "title" : "Limit",
            "type" : "string",
            "default" : "NONE",
            "enum" : [ "GRADIENT", "NONE", "PHASE_FRACTION", "ZERO_GRADIENT" ]
          }
        },
        "additionalProperties" : false
      },
      "DynamicContactAnglePFBC" : {
        "title" : "Dynamic contact angle",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: DynamicContactAnglePFBC",
            "default" : "DYNAMIC_CONTACT_ANGLE"
          },
          "equilibriumContactAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "advancingContactAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "recedingContactAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "velocityScaleOfContactAngle" : {
            "title" : "Velocity scale of contact angle",
            "type" : "number",
            "default" : 1
          },
          "limit" : {
            "title" : "Limit",
            "type" : "string",
            "default" : "NONE",
            "enum" : [ "GRADIENT", "NONE", "PHASE_FRACTION", "ZERO_GRADIENT" ]
          }
        },
        "additionalProperties" : false
      },
      "ZeroGradientPFBC" : {
        "title" : "Zero gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ZeroGradientPFBC",
            "default" : "ZERO_GRADIENT"
          }
        },
        "additionalProperties" : false
      },
      "FanBC" : {
        "title" : "Fan",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FanBC",
            "default" : "FAN"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "pressure" : {
            "$ref" : "#/components/schemas/FanPBC"
          },
          "pressureRgh" : {
            "$ref" : "#/components/schemas/FanPBC"
          },
          "gaugePressure" : {
            "$ref" : "#/components/schemas/FanPBC"
          },
          "gaugePressureRgh" : {
            "$ref" : "#/components/schemas/FanPBC"
          },
          "temperature" : {
            "$ref" : "#/components/schemas/FixedValueTBC"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "FanPBC" : {
        "title" : "(P<fan>) Fan pressure",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FanPBC",
            "default" : "FAN_PRESSURE"
          },
          "direction" : {
            "title" : "Fan Type",
            "type" : "string",
            "default" : "IN",
            "enum" : [ "IN", "OUT" ]
          },
          "fanPressure" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Pressure"
          },
          "environmentalTotalPressure" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          }
        },
        "additionalProperties" : false
      },
      "VariableGroup_V_DOT" : {
        "type" : "object",
        "properties" : {
          "V_DOT" : {
            "$ref" : "#/components/schemas/Unit_VolumetricFlowRate"
          }
        }
      },
      "Unit_VolumetricFlowRate" : {
        "type" : "object",
        "properties" : {
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "in/s" ]
          }
        }
      },
      "SymmetryBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This boundary condition provides a symmetry condition on any face by applying a mirror effect. The fluxes and the normal components across the symmetry face are set to zero. <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/symmetry/' target='_blank'>Learn more</a>.\n\nSchema name: SymmetryBC",
            "default" : "SYMMETRY"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This boundary condition provides a symmetry condition on any face by applying a mirror effect. The fluxes and the normal components across the symmetry face are set to zero. <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/symmetry/' target='_blank'>Learn more</a>."
      },
      "PeriodicBC" : {
        "title" : "Periodic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This boundary condition should be used on two faces of a system as if they are physically connected. It is required that the two faces are of same size and shape and the face elements of the mesh are congruent on both sides. Works for uploaded meshes only. <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/periodic-boundary-condition/' target='_blank'>Learn more</a>.\n\nSchema name: PeriodicBC",
            "default" : "PERIODIC"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This boundary condition should be used on two faces of a system as if they are physically connected. It is required that the two faces are of same size and shape and the face elements of the mesh are congruent on both sides. Works for uploaded meshes only. <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/periodic-boundary-condition/' target='_blank'>Learn more</a>."
      },
      "WedgeBC" : {
        "title" : "Wedge",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This boundary condition is applied to the front and back faces of an axisymmetric system (eg. cylinder). Note that the face elements of the mesh need to be congruent on both the faces. Works for uploaded 2D meshes only.  <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/wedge/' target='_blank'>Learn more</a>.\n\nSchema name: WedgeBC",
            "default" : "WEDGE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This boundary condition is applied to the front and back faces of an axisymmetric system (eg. cylinder). Note that the face elements of the mesh need to be congruent on both the faces. Works for uploaded 2D meshes only.  <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/wedge/' target='_blank'>Learn more</a>."
      },
      "CustomFluidBC" : {
        "title" : "Custom",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This boundary condition allows the user to choose conditions for each physical variable separately. It provides full flexibility over the choice of boundary conditions to make advanced customization possible.\n\nSchema name: CustomFluidBC",
            "default" : "CUSTOM_V37"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "velocity" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCVelocity"
          },
          "pressure" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCPressure"
          },
          "pressureRgh" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCPressureRgh"
          },
          "gaugePressure" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCGaugePressure"
          },
          "gaugePressureRgh" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCGaugePressureRgh"
          },
          "temperature" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCTemperature"
          },
          "turbulentKineticEnergy" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCTurbulentKineticEnergy"
          },
          "omegaDissipationRate" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCOmegaDissipationRate"
          },
          "epsilonDissipationRate" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCEpsilonDissipationRate"
          },
          "eddyViscosity" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCEddyViscosity"
          },
          "eddyViscosityCompressible" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCEddyViscosityCompressible"
          },
          "nuTilda" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCNuTilda"
          },
          "turbulentThermalDiffusivity" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCTurbulentThermalDiffusivity"
          },
          "turbulentThermalDiffusivityCompressible" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCTurbulentThermalDiffusivityCompressible"
          },
          "turbulentDynamicViscosity" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCTurbulentDynamicViscosity"
          },
          "passiveScalars" : {
            "title" : "Passive scalars",
            "type" : "array",
            "description" : "Please choose a boundary condition for passive scalar (T).",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_CustomFluidBCPassiveScalars"
            },
            "x-showWhen" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 0", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 0", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 0" ]
          },
          "phaseFraction" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCPhaseFraction"
          },
          "netRadiativeHeatFlux" : {
            "$ref" : "#/components/schemas/OneOf_CustomFluidBCNetRadiativeHeatFlux"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This boundary condition allows the user to choose conditions for each physical variable separately. It provides full flexibility over the choice of boundary conditions to make advanced customization possible."
      },
      "AdvectiveVBC" : {
        "title" : "Advective",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AdvectiveVBC",
            "default" : "ADVECTIVE"
          },
          "relaxBoundary" : {
            "title" : "Relax boundary",
            "type" : "boolean",
            "default" : false
          },
          "farFieldValue" : {
            "$ref" : "#/components/schemas/DimensionalVector_Speed"
          },
          "relaxationLengthScale" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "SymmetryVBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SymmetryVBC",
            "default" : "SYMMETRY"
          }
        },
        "additionalProperties" : false
      },
      "FixedGradientVBC" : {
        "title" : "Fixed gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedGradientVBC",
            "default" : "FIXED_GRADIENT"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/DimensionalVector_SpecificTurbulenceDissipationRate"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVector_SpecificTurbulenceDissipationRate" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/DecimalVector"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/s" ]
          }
        },
        "additionalProperties" : false
      },
      "InletOutletVBC" : {
        "title" : "Inlet-outlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: InletOutletVBC",
            "default" : "INLET_OUTLET"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalVector_Speed"
          }
        },
        "additionalProperties" : false
      },
      "PressureInletVBC" : {
        "title" : "Pressure inlet velocity",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PressureInletVBC",
            "default" : "PRESSURE_INLET_VELOCITY"
          }
        },
        "additionalProperties" : false
      },
      "PressureInletOutletVBC" : {
        "title" : "Pressure inlet-outlet velocity",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PressureInletOutletVBC",
            "default" : "PRESSURE_INLET_OUTLET_VELOCITY"
          }
        },
        "additionalProperties" : false
      },
      "ZeroGradientVBC" : {
        "title" : "Zero gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ZeroGradientVBC",
            "default" : "ZERO_GRADIENT"
          }
        },
        "additionalProperties" : false
      },
      "TurbulentDFSEMInletVBC" : {
        "title" : "Turbulent DFSEM inlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TurbulentDFSEMInletVBC",
            "default" : "TURBULENT_DFSEM_INLET"
          },
          "domainLengthScale" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "eddyLengthScale" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Length"
          },
          "velocity" : {
            "$ref" : "#/components/schemas/DimensionalVectorFunction_Speed"
          },
          "reynoldsStressTensor" : {
            "$ref" : "#/components/schemas/StressTensor_Pressure"
          }
        },
        "additionalProperties" : false
      },
      "AdvectivePBC" : {
        "title" : "Advective",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AdvectivePBC",
            "default" : "ADVECTIVE"
          },
          "relaxBoundary" : {
            "title" : "Relax boundary",
            "type" : "boolean",
            "default" : false
          },
          "farFieldValue" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "relaxationLengthScale" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "SymmetryPBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SymmetryPBC",
            "default" : "SYMMETRY"
          }
        },
        "additionalProperties" : false
      },
      "FixedGradientPBC" : {
        "title" : "Fixed gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedGradientPBC",
            "default" : "FIXED_GRADIENT"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/Dimensional_ForceDensity"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_ForceDensity" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "Pa/m", "lbf/in" ]
          }
        },
        "additionalProperties" : false
      },
      "FreestreamPBC" : {
        "title" : "Freestream",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FreestreamPBC",
            "default" : "FREESTREAM"
          }
        },
        "additionalProperties" : false
      },
      "ZeroGradientPBC" : {
        "title" : "Zero gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ZeroGradientPBC",
            "default" : "ZERO_GRADIENT"
          }
        },
        "additionalProperties" : false
      },
      "WaveTransmissivePBC" : {
        "title" : "Wave transmissive",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WaveTransmissivePBC",
            "default" : "WAVE_TRANSMISSIVE"
          },
          "specificHeatRatio" : {
            "title" : "() Gamma",
            "type" : "number",
            "default" : 1.4
          },
          "relaxBoundary" : {
            "title" : "Relax boundary",
            "type" : "boolean",
            "default" : false
          },
          "farFieldValue" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "relaxationLengthScale" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "FixedFluxPBC" : {
        "title" : "Fixed flux",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedFluxPBC",
            "default" : "FIXED_FLUX_PRESSURE"
          }
        },
        "additionalProperties" : false
      },
      "FixedGradientTBC" : {
        "title" : "Fixed gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedGradientTBC",
            "default" : "FIXED_GRADIENT"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/DimensionalFunction_TemperatureGradient"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalFunction_TemperatureGradient" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_TemperatureGradientValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "K/m", "F/in" ]
          }
        },
        "additionalProperties" : false
      },
      "InletOutletTBC" : {
        "title" : "Inlet-outlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: InletOutletTBC",
            "default" : "INLET_OUTLET"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          }
        },
        "additionalProperties" : false
      },
      "SymmetryTBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SymmetryTBC",
            "default" : "SYMMETRY"
          }
        },
        "additionalProperties" : false
      },
      "WallHeatTransferTBC" : {
        "title" : "Wall heat transfer",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WallHeatTransferTBC",
            "default" : "WALL_HEAT_TRANSFER"
          },
          "wallTemperature" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          },
          "thermalDiffusivity" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          }
        },
        "additionalProperties" : false
      },
      "SymmetryTKEBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SymmetryTKEBC",
            "default" : "SYMMETRY"
          }
        },
        "additionalProperties" : false
      },
      "FixedGradientTKEBC" : {
        "title" : "Fixed gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedGradientTKEBC",
            "default" : "FIXED_GRADIENT"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/Dimensional_Acceleration"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_Acceleration" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "in/s" ]
          }
        },
        "additionalProperties" : false
      },
      "FixedValueTKEBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedValueTKEBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalFunction_TurbulenceKineticEnergy"
          }
        },
        "additionalProperties" : false
      },
      "InletOutletTKEBC" : {
        "title" : "Inlet-outlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: InletOutletTKEBC",
            "default" : "INLET_OUTLET"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_TurbulenceKineticEnergy"
          }
        },
        "additionalProperties" : false
      },
      "ZeroGradientTKEBC" : {
        "title" : "Zero gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ZeroGradientTKEBC",
            "default" : "ZERO_GRADIENT"
          }
        },
        "additionalProperties" : false
      },
      "IntensityKineticEnergyInletTKEBC" : {
        "title" : "Intensity inlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: IntensityKineticEnergyInletTKEBC",
            "default" : "TURBULENT_INTENSITY_KINETIC_ENERGY_INLET"
          },
          "intensity" : {
            "title" : "Intensity",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.05
          }
        },
        "additionalProperties" : false
      },
      "WallFunctionTKEBC" : {
        "title" : "Wall function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WallFunctionTKEBC",
            "default" : "WALL_FUNCTION"
          },
          "wallRoughness" : {
            "title" : "Wall roughness",
            "type" : "boolean",
            "default" : false
          },
          "roughnessHeight" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "roughnessConstant" : {
            "title" : "Roughness constant",
            "minimum" : 0.5,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.5
          }
        },
        "additionalProperties" : false
      },
      "FullResolutionTKEBC" : {
        "title" : "Full resolution",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FullResolutionTKEBC",
            "default" : "FULL_RESOLUTION"
          }
        },
        "additionalProperties" : false
      },
      "SymmetryOBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SymmetryOBC",
            "default" : "SYMMETRY"
          }
        },
        "additionalProperties" : false
      },
      "FixedGradientOBC" : {
        "title" : "Fixed gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedGradientOBC",
            "default" : "FIXED_GRADIENT"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/Dimensional_SpecificTurbulenceDissipationRateGradient"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_SpecificTurbulenceDissipationRateGradient" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/(sm)", "1/(sin)" ]
          }
        },
        "additionalProperties" : false
      },
      "FixedValueOBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedValueOBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalFunction_SpecificTurbulenceDissipationRate"
          }
        },
        "additionalProperties" : false
      },
      "InletOutletOBC" : {
        "title" : "Inlet-outlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: InletOutletOBC",
            "default" : "INLET_OUTLET"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_SpecificTurbulenceDissipationRate"
          }
        },
        "additionalProperties" : false
      },
      "ZeroGradientOBC" : {
        "title" : "Zero gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ZeroGradientOBC",
            "default" : "ZERO_GRADIENT"
          }
        },
        "additionalProperties" : false
      },
      "WallFunctionOBC" : {
        "title" : "Wall function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WallFunctionOBC",
            "default" : "WALL_FUNCTION"
          }
        },
        "additionalProperties" : false
      },
      "FullResolutionOBC" : {
        "title" : "Full resolution",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FullResolutionOBC",
            "default" : "FULL_RESOLUTION"
          }
        },
        "additionalProperties" : false
      },
      "SymmetryEBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SymmetryEBC",
            "default" : "SYMMETRY"
          }
        },
        "additionalProperties" : false
      },
      "FixedGradientEBC" : {
        "title" : "Fixed gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedGradientEBC",
            "default" : "FIXED_GRADIENT"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/Dimensional_EpsilonGradient"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_EpsilonGradient" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "lbf/(slb)" ]
          }
        },
        "additionalProperties" : false
      },
      "FixedValueEBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedValueEBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/DimensionalFunction_TurbulentDissipation"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalFunction_TurbulentDissipation" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_TurbulentDissipationValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m/s", "lbfin/(slb)" ]
          }
        },
        "additionalProperties" : false
      },
      "InletOutletEBC" : {
        "title" : "Inlet-outlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: InletOutletEBC",
            "default" : "INLET_OUTLET"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_TurbulentDissipation"
          }
        },
        "additionalProperties" : false
      },
      "MixingLengthInletEBC" : {
        "title" : "Mixing length inlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: MixingLengthInletEBC",
            "default" : "TURBULENCE_MIXING_LENGTH_DISSIPATION_RATE_INLET"
          },
          "mixingLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "ZeroGradientEBC" : {
        "title" : "Zero gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ZeroGradientEBC",
            "default" : "ZERO_GRADIENT"
          }
        },
        "additionalProperties" : false
      },
      "WallFunctionEBC" : {
        "title" : "Wall function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WallFunctionEBC",
            "default" : "WALL_FUNCTION"
          }
        },
        "additionalProperties" : false
      },
      "FullResolutionEBC" : {
        "title" : "Full resolution",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FullResolutionEBC",
            "default" : "FULL_RESOLUTION"
          }
        },
        "additionalProperties" : false
      },
      "CalculatedEVBC" : {
        "title" : "Calculated",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CalculatedEVBC",
            "default" : "CALCULATED"
          }
        },
        "additionalProperties" : false
      },
      "SymmetryEVBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SymmetryEVBC",
            "default" : "SYMMETRY"
          }
        },
        "additionalProperties" : false
      },
      "FixedGradientEVBC" : {
        "title" : "Fixed gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedGradientEVBC",
            "default" : "FIXED_GRADIENT"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/Dimensional_EddyViscosityGradient"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_EddyViscosityGradient" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "kg/(sm)", "lbfs/in" ]
          }
        },
        "additionalProperties" : false
      },
      "FixedValueEVBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedValueEVBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_DynamicViscosity"
          }
        },
        "additionalProperties" : false
      },
      "InletOutletEVBC" : {
        "title" : "Inlet-outlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: InletOutletEVBC",
            "default" : "INLET_OUTLET"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_DynamicViscosity"
          }
        },
        "additionalProperties" : false
      },
      "ZeroGradientEVBC" : {
        "title" : "Zero gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ZeroGradientEVBC",
            "default" : "ZERO_GRADIENT"
          }
        },
        "additionalProperties" : false
      },
      "WallFunctionEVBC" : {
        "title" : "Wall function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WallFunctionEVBC",
            "default" : "WALL_FUNCTION"
          }
        },
        "additionalProperties" : false
      },
      "FullResolutionEVBC" : {
        "title" : "Full resolution",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FullResolutionEVBC",
            "default" : "FULL_RESOLUTION"
          }
        },
        "additionalProperties" : false
      },
      "CalculatedEVCBC" : {
        "title" : "Calculated",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CalculatedEVCBC",
            "default" : "CALCULATED"
          }
        },
        "additionalProperties" : false
      },
      "SymmetryEVCBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SymmetryEVCBC",
            "default" : "SYMMETRY"
          }
        },
        "additionalProperties" : false
      },
      "FixedGradientEVCBC" : {
        "title" : "Fixed gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedGradientEVCBC",
            "default" : "FIXED_GRADIENT"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/Dimensional_EddyViscosityGradient"
          }
        },
        "additionalProperties" : false
      },
      "FixedValueEVCBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedValueEVCBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_DynamicViscosity"
          }
        },
        "additionalProperties" : false
      },
      "InletOutletEVCBC" : {
        "title" : "Inlet-outlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: InletOutletEVCBC",
            "default" : "INLET_OUTLET"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_DynamicViscosity"
          }
        },
        "additionalProperties" : false
      },
      "ZeroGradientEVCBC" : {
        "title" : "Zero gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ZeroGradientEVCBC",
            "default" : "ZERO_GRADIENT"
          }
        },
        "additionalProperties" : false
      },
      "WallFunctionEVCBC" : {
        "title" : "Wall function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WallFunctionEVCBC",
            "default" : "WALL_FUNCTION"
          }
        },
        "additionalProperties" : false
      },
      "FullResolutionEVCBC" : {
        "title" : "Full resolution",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FullResolutionEVCBC",
            "default" : "FULL_RESOLUTION"
          }
        },
        "additionalProperties" : false
      },
      "SymmetryNBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SymmetryNBC",
            "default" : "SYMMETRY"
          }
        },
        "additionalProperties" : false
      },
      "FixedGradientNBC" : {
        "title" : "Fixed gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedGradientNBC",
            "default" : "FIXED_GRADIENT"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/Dimensional_Speed"
          }
        },
        "additionalProperties" : false
      },
      "FixedValueNBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedValueNBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          }
        },
        "additionalProperties" : false
      },
      "InletOutletNBC" : {
        "title" : "Inlet-outlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: InletOutletNBC",
            "default" : "INLET_OUTLET"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_KinematicViscosity"
          }
        },
        "additionalProperties" : false
      },
      "ZeroGradientNBC" : {
        "title" : "Zero gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ZeroGradientNBC",
            "default" : "ZERO_GRADIENT"
          }
        },
        "additionalProperties" : false
      },
      "WallFunctionNBC" : {
        "title" : "Wall function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WallFunctionNBC",
            "default" : "WALL_FUNCTION"
          }
        },
        "additionalProperties" : false
      },
      "FullResolutionNBC" : {
        "title" : "Full resolution",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FullResolutionNBC",
            "default" : "FULL_RESOLUTION"
          }
        },
        "additionalProperties" : false
      },
      "CalculatedTDBC" : {
        "title" : "Calculated",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CalculatedTDBC",
            "default" : "CALCULATED"
          }
        },
        "additionalProperties" : false
      },
      "FixedGradientTDBC" : {
        "title" : "Fixed gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedGradientTDBC",
            "default" : "FIXED_GRADIENT"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/Dimensional_EddyViscosityGradient"
          }
        },
        "additionalProperties" : false
      },
      "FixedValueTDBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedValueTDBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_DynamicViscosity"
          }
        },
        "additionalProperties" : false
      },
      "ZeroGradientTDBC" : {
        "title" : "Zero gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ZeroGradientTDBC",
            "default" : "ZERO_GRADIENT"
          }
        },
        "additionalProperties" : false
      },
      "SymmetryTDBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SymmetryTDBC",
            "default" : "SYMMETRY"
          }
        },
        "additionalProperties" : false
      },
      "WallFunctionTDBC" : {
        "title" : "Wall function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WallFunctionTDBC",
            "default" : "WALL_FUNCTION"
          },
          "prandtlNumber" : {
            "title" : "(Pr) Prandtl number",
            "minimum" : 0,
            "exclusiveMinimum" : true,
            "type" : "number",
            "default" : 0.85
          }
        },
        "additionalProperties" : false
      },
      "FullResolutionTDBC" : {
        "title" : "Full resolution",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FullResolutionTDBC",
            "default" : "FULL_RESOLUTION"
          },
          "prandtlNumber" : {
            "title" : "(Pr) Prandtl number",
            "minimum" : 0,
            "exclusiveMinimum" : true,
            "type" : "number",
            "default" : 0.85
          }
        },
        "additionalProperties" : false
      },
      "CalculatedTDCBC" : {
        "title" : "Calculated",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CalculatedTDCBC",
            "default" : "CALCULATED"
          }
        },
        "additionalProperties" : false
      },
      "FixedGradientTDCBC" : {
        "title" : "Fixed gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedGradientTDCBC",
            "default" : "FIXED_GRADIENT"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/Dimensional_EddyViscosityGradient"
          }
        },
        "additionalProperties" : false
      },
      "FixedValueTDCBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedValueTDCBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_DynamicViscosity"
          }
        },
        "additionalProperties" : false
      },
      "ZeroGradientTDCBC" : {
        "title" : "Zero gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ZeroGradientTDCBC",
            "default" : "ZERO_GRADIENT"
          }
        },
        "additionalProperties" : false
      },
      "SymmetryTDCBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SymmetryTDCBC",
            "default" : "SYMMETRY"
          }
        },
        "additionalProperties" : false
      },
      "WallFunctionTDCBC" : {
        "title" : "Wall function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WallFunctionTDCBC",
            "default" : "WALL_FUNCTION"
          },
          "prandtlNumber" : {
            "title" : "(Pr) Prandtl number",
            "minimum" : 0,
            "exclusiveMinimum" : true,
            "type" : "number",
            "default" : 0.85
          }
        },
        "additionalProperties" : false
      },
      "FullResolutionTDCBC" : {
        "title" : "Full resolution",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FullResolutionTDCBC",
            "default" : "FULL_RESOLUTION"
          },
          "prandtlNumber" : {
            "title" : "(Pr) Prandtl number",
            "minimum" : 0,
            "exclusiveMinimum" : true,
            "type" : "number",
            "default" : 0.85
          }
        },
        "additionalProperties" : false
      },
      "CalculatedDVBC" : {
        "title" : "Calculated",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CalculatedDVBC",
            "default" : "CALCULATED"
          }
        },
        "additionalProperties" : false
      },
      "FixedGradientDVBC" : {
        "title" : "Fixed gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedGradientDVBC",
            "default" : "FIXED_GRADIENT"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/Dimensional_EddyViscosityGradient"
          }
        },
        "additionalProperties" : false
      },
      "FixedValueDVBC" : {
        "title" : "Fixed value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedValueDVBC",
            "default" : "FIXED_VALUE"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_DynamicViscosity"
          }
        },
        "additionalProperties" : false
      },
      "InletOutletDVBC" : {
        "title" : "Inlet-outlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: InletOutletDVBC",
            "default" : "INLET_OUTLET"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_DynamicViscosity"
          }
        },
        "additionalProperties" : false
      },
      "ZeroGradientDVBC" : {
        "title" : "Zero gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ZeroGradientDVBC",
            "default" : "ZERO_GRADIENT"
          }
        },
        "additionalProperties" : false
      },
      "SymmetryDVBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SymmetryDVBC",
            "default" : "SYMMETRY"
          }
        },
        "additionalProperties" : false
      },
      "WallFunctionDVBC" : {
        "title" : "Wall function",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WallFunctionDVBC",
            "default" : "WALL_FUNCTION"
          }
        },
        "additionalProperties" : false
      },
      "FullResolutionDVBC" : {
        "title" : "Full resolution",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FullResolutionDVBC",
            "default" : "FULL_RESOLUTION"
          }
        },
        "additionalProperties" : false
      },
      "FixedGradientPSBC" : {
        "title" : "Fixed gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedGradientPSBC",
            "default" : "FIXED_GRADIENT"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/Dimensional_Absorptivity"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_Absorptivity" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/m", "1/in" ]
          }
        },
        "additionalProperties" : false
      },
      "InletOutletPSBC" : {
        "title" : "Inlet-outlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: InletOutletPSBC",
            "default" : "INLET_OUTLET"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_Dimensionless"
          }
        },
        "additionalProperties" : false
      },
      "ZeroGradientPSBC" : {
        "title" : "Zero gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ZeroGradientPSBC",
            "default" : "ZERO_GRADIENT"
          }
        },
        "additionalProperties" : false
      },
      "SymmetryPSBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SymmetryPSBC",
            "default" : "SYMMETRY"
          }
        },
        "additionalProperties" : false
      },
      "FixedGradientPFBC" : {
        "title" : "Fixed gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedGradientPFBC",
            "default" : "FIXED_GRADIENT"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/Dimensional_PhaseFractionGradient"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_PhaseFractionGradient" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/m", "1/in" ]
          }
        },
        "additionalProperties" : false
      },
      "InletOutletPFBC" : {
        "title" : "Inlet-outlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: InletOutletPFBC",
            "default" : "INLET_OUTLET"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_Dimensionless"
          }
        },
        "additionalProperties" : false
      },
      "SymmetryPFBC" : {
        "title" : "Symmetry",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SymmetryPFBC",
            "default" : "SYMMETRY"
          }
        },
        "additionalProperties" : false
      },
      "Empty2DBC" : {
        "title" : "Empty 2D",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This boundary condition is intended only for uploaded 2D OpenFOAM meshes. A 2D mesh is ensured by having a single cell thickness in one of the 3 spatial directions. <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/empty-2d/' target='_blank'>Learn more.</a>\n\nSchema name: Empty2DBC",
            "default" : "EMPTY_2D"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "This boundary condition is intended only for uploaded 2D OpenFOAM meshes. A 2D mesh is ensured by having a single cell thickness in one of the 3 spatial directions. <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/empty-2d/' target='_blank'>Learn more.</a>"
      },
      "AdvancedConcepts" : {
        "type" : "object",
        "properties" : {
          "rotatingZones" : {
            "title" : "Rotating zones",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_AdvancedConceptsRotatingZones"
            },
            "x-showWhen" : [ "type == COMPRESSIBLE", "type == CONVECTIVE_HEAT_TRANSFER && enableRadiation == false", "type == INCOMPRESSIBLE && algorithm in [SIMPLE,PIMPLE,PISO]", "type == MULTIPHASE && useLocalTimeStepping == false", "type == CONJUGATE_HEAT_TRANSFER && enableRadiation == false", "type == SIMERICS_ANALYSIS" ]
          },
          "porousMediums" : {
            "title" : "Porous media",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_AdvancedConceptsPorousMediums"
            },
            "x-showWhen" : [ "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]", "type == INCOMPRESSIBLE && algorithm in [SIMPLE,PIMPLE]" ]
          },
          "solidBodyMotions" : {
            "title" : "Solid body motions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_AdvancedConceptsSolidBodyMotions"
            },
            "x-showWhen" : [ "type == INCOMPRESSIBLE && algorithm == PIMPLE", "type == MULTIPHASE && useLocalTimeStepping == false" ]
          },
          "powerSources" : {
            "title" : "Power sources",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_AdvancedConceptsPowerSources"
            },
            "x-showWhen" : [ "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ]
          },
          "momentumSources" : {
            "title" : "Momentum sources",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_AdvancedConceptsMomentumSources"
            },
            "x-showWhen" : [ "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]", "type == INCOMPRESSIBLE && algorithm in [SIMPLE,PIMPLE]" ]
          },
          "passiveScalarSources" : {
            "title" : "Passive scalar sources",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_AdvancedConceptsPassiveScalarSources"
            },
            "x-showWhen" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 0", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 0", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 0" ]
          },
          "thermalResistanceNetworks" : {
            "title" : "Thermal Resistance Networks",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_AdvancedConceptsThermalResistanceNetworks"
            },
            "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER && enableRadiation == false", "type == COUPLED_CONJUGATE_HEAT_TRANSFER" ]
          }
        },
        "additionalProperties" : false
      },
      "AMIRotatingZone" : {
        "title" : "AMI rotating zone",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AMIRotatingZone",
            "default" : "ARBITRARY_MESH_INTERFACE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "motionType" : {
            "$ref" : "#/components/schemas/OneOf_AMIRotatingZoneMotionType"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "OscillatingRotatingMotionType" : {
        "title" : "Oscillating rotating motion",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: OscillatingRotatingMotionType",
            "default" : "OSCILLATING_ROTATING_MOTION"
          },
          "rotationCenter" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "amplitude" : {
            "$ref" : "#/components/schemas/DimensionalVector_Angle"
          },
          "angularVelocity" : {
            "$ref" : "#/components/schemas/DimensionalFunction_RotationSpeed"
          }
        },
        "additionalProperties" : false
      },
      "RotatingMotionType" : {
        "title" : "Rotating motion",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: RotatingMotionType",
            "default" : "ROTATING_MOTION"
          },
          "rotation" : {
            "$ref" : "#/components/schemas/OneOf_RotatingMotionTypeRotation"
          }
        },
        "additionalProperties" : false
      },
      "VectorRotation" : {
        "title" : "Vector rotation",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: VectorRotation",
            "default" : "VECTOR_ROTATION"
          },
          "rotationCenter" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "angularVelocity" : {
            "$ref" : "#/components/schemas/DimensionalVector_RotationSpeed"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVector_RotationSpeed" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/DecimalVector"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "rad/s", "/s" ]
          }
        },
        "additionalProperties" : false
      },
      "MRFRotatingZone" : {
        "title" : "MRF rotating zone",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: MRFRotatingZone",
            "default" : "MULTI_REFERENCE_FRAME"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "origin" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "axis" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "angularVelocity" : {
            "$ref" : "#/components/schemas/DimensionalFunction_RotationSpeed"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "DarcyForchheimerMedium" : {
        "title" : "Darcy-Forchheimer medium",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: DarcyForchheimerMedium",
            "default" : "DARCY_FORCHHEIMER"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "coefficientD" : {
            "$ref" : "#/components/schemas/DimensionalVector_ReciprocalPermeability"
          },
          "coefficientF" : {
            "$ref" : "#/components/schemas/DimensionalVector_Absorptivity"
          },
          "orientation" : {
            "$ref" : "#/components/schemas/OneOf_DarcyForchheimerMediumOrientation"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVector_ReciprocalPermeability" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/DecimalVector"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/m", "1/in" ]
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVector_Absorptivity" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/DecimalVector"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/m", "1/in" ]
          }
        },
        "additionalProperties" : false
      },
      "CartesianOrientation" : {
        "title" : "Cartesian",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CartesianOrientation",
            "default" : "CARTESIAN"
          }
        },
        "additionalProperties" : false
      },
      "CustomOrientation" : {
        "title" : "Custom",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CustomOrientation",
            "default" : "CUSTOM"
          },
          "unitVector1" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "unitVector2" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          }
        },
        "additionalProperties" : false
      },
      "FixedCoeffMedium" : {
        "title" : "Fixed coeff medium",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FixedCoeffMedium",
            "default" : "FIXED_COEFFICIENTS"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "alpha" : {
            "$ref" : "#/components/schemas/DimensionalVector_SpecificTurbulenceDissipationRate"
          },
          "beta" : {
            "$ref" : "#/components/schemas/DimensionalVector_Absorptivity"
          },
          "referenceDensity" : {
            "$ref" : "#/components/schemas/Dimensional_Density"
          },
          "orientation" : {
            "$ref" : "#/components/schemas/OneOf_FixedCoeffMediumOrientation"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "PowerLawMedium" : {
        "title" : "Power law medium",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PowerLawMedium",
            "default" : "POWER_LAW"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "linearCoefficient" : {
            "title" : "Linear coefficient",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 1
          },
          "exponentCoefficient" : {
            "title" : "Exponent coefficient",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 2
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "PressureLossCurve" : {
        "title" : "Pressure loss curve",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PressureLossCurve",
            "default" : "PRESSURE_LOSS_CURVE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "pressureLossData" : {
            "$ref" : "#/components/schemas/PressureLossData"
          },
          "directionalDependency" : {
            "$ref" : "#/components/schemas/DirectionalDependency"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "PressureLossData" : {
        "type" : "object",
        "properties" : {
          "pressureLossCurve" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Pressure"
          },
          "flowDirectionLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "crossSectionArea" : {
            "$ref" : "#/components/schemas/Dimensional_Area"
          }
        },
        "additionalProperties" : false
      },
      "DirectionalDependency" : {
        "title" : "Directional dependency",
        "type" : "object",
        "properties" : {
          "darcyForchheimerType" : {
            "$ref" : "#/components/schemas/OneOf_DirectionalDependencyDarcyForchheimerType"
          }
        },
        "additionalProperties" : false
      },
      "IsotropicDarcyForchheimer" : {
        "title" : "Isotropic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Isotropic porous object where the same permeability and friction form coefficient are applied in all directions.\n\nSchema name: IsotropicDarcyForchheimer",
            "default" : "ISOTROPIC"
          }
        },
        "additionalProperties" : false,
        "description" : "Isotropic porous object where the same permeability and friction form coefficient are applied in all directions."
      },
      "RectifyingDarcyForchheimer" : {
        "title" : "Directional",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Directional porous object where the permeability and friction form coefficient are applied only in the specified direction. For directions orthogonal to the specified direction, the permeability is set to zero, i.e. there is no flow in the orthogonal directions.\n\nSchema name: RectifyingDarcyForchheimer",
            "default" : "RECTIFYING"
          },
          "direction" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          }
        },
        "additionalProperties" : false,
        "description" : "Directional porous object where the permeability and friction form coefficient are applied only in the specified direction. For directions orthogonal to the specified direction, the permeability is set to zero, i.e. there is no flow in the orthogonal directions."
      },
      "PerforatedPlate" : {
        "title" : "Perforated plate",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PerforatedPlate",
            "default" : "PERFORATED_PLATE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "plateData" : {
            "$ref" : "#/components/schemas/PlateData"
          },
          "darcyForchheimerType" : {
            "$ref" : "#/components/schemas/RectifyingDarcyForchheimer"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "PlateData" : {
        "title" : "Plate data",
        "type" : "object",
        "properties" : {
          "freeAreaRatio" : {
            "title" : "Free area ratio",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : true,
            "type" : "number",
            "description" : "Free area ratio is the ratio of open area of the perforated plate to its total area.",
            "default" : 0.5
          },
          "holeShape" : {
            "$ref" : "#/components/schemas/OneOf_PlateDataHoleShape"
          }
        },
        "additionalProperties" : false
      },
      "GeneralHoleShape" : {
        "title" : "General",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "General formulation that does not depend on the shape of the holes. Valid only for thin plates where thickness to hole ratio is less than 0.015 and Reynolds number is greater than 10000.\n\nSchema name: GeneralHoleShape",
            "default" : "GENERAL"
          }
        },
        "additionalProperties" : false,
        "description" : "General formulation that does not depend on the shape of the holes. Valid only for thin plates where thickness to hole ratio is less than 0.015 and Reynolds number is greater than 10000."
      },
      "CircularHoleShape" : {
        "title" : "Circular",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Circular holes in the perforated plate.\n\nSchema name: CircularHoleShape",
            "default" : "CIRCULAR"
          },
          "averageHoleDiameter" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false,
        "description" : "Circular holes in the perforated plate."
      },
      "LinearSBM" : {
        "title" : "Linear motion",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: LinearSBM",
            "default" : "LINEAR_MOTION"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "velocity" : {
            "$ref" : "#/components/schemas/DimensionalVector_Speed"
          }
        },
        "additionalProperties" : false
      },
      "OscillatingRotatingSBM" : {
        "title" : "Oscillating rotating motion",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: OscillatingRotatingSBM",
            "default" : "OSCILLATING_ROTATING_MOTION"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "rotationCenter" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "amplitude" : {
            "$ref" : "#/components/schemas/DimensionalVector_Angle"
          },
          "angularVelocity" : {
            "$ref" : "#/components/schemas/Dimensional_RotationSpeed"
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_RotationSpeed" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "rad/s", "/s" ]
          }
        },
        "additionalProperties" : false
      },
      "OscillatingLinearSBM" : {
        "title" : "Oscillating linear motion",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: OscillatingLinearSBM",
            "default" : "OSCILLATING_LINEAR_MOTION"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "amplitude" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "angularVelocity" : {
            "$ref" : "#/components/schemas/Dimensional_RotationSpeed"
          }
        },
        "additionalProperties" : false
      },
      "RotatingSBM" : {
        "title" : "Rotating motion",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: RotatingSBM",
            "default" : "ROTATING_MOTION"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "rotation" : {
            "$ref" : "#/components/schemas/OneOf_RotatingSBMRotation"
          }
        },
        "additionalProperties" : false
      },
      "ShipDesignAnalysisSBM" : {
        "title" : "Ship design analysis",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ShipDesignAnalysisSBM",
            "default" : "SHIP_DESIGN_ANALYSIS"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "centerOfGravity" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "modelScaleRatio" : {
            "title" : "Model scale ratio",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 1
          },
          "maxRollAmplitude" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "minRollAmplitude" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "heaveAmplitude" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "swayAmplitude" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "dampingCoefficient" : {
            "title" : "Damping coefficient",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 1
          },
          "timePeriodForLiquid" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "naturalPeriodOfShip" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "referenceTimeStep" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "increaseInLiquidPerTimeStep" : {
            "title" : "Increase in liquid per time step",
            "type" : "number",
            "default" : -0.001
          }
        },
        "additionalProperties" : false
      },
      "AbsolutePowerSource" : {
        "title" : "Absolute power source",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<i>Power sources</i> can be used to simulate heat generation from a volume. Two types are available:<br><li><b>Absolute</b></li>: Used when total power emitted by the assigned volume is known.<li><b>Specific</b></li>: Used when power density of the assigned volume is known. <a href='https://www.simscale.com/docs/simulation-setup/advanced-concepts/power-sources/' target='_blank'>Learn more</a>.\n\nSchema name: AbsolutePowerSource",
            "default" : "ABSOLUTE_V23"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "heatFlux" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Power"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE" ]
            }
          }
        },
        "additionalProperties" : false,
        "description" : "<i>Power sources</i> can be used to simulate heat generation from a volume. Two types are available:<br><li><b>Absolute</b></li>: Used when total power emitted by the assigned volume is known.<li><b>Specific</b></li>: Used when power density of the assigned volume is known. <a href='https://www.simscale.com/docs/simulation-setup/advanced-concepts/power-sources/' target='_blank'>Learn more</a>."
      },
      "DimensionalFunction_Power" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_PowerValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "W", "Btu/s" ]
          }
        },
        "additionalProperties" : false
      },
      "SpecificPowerSource" : {
        "title" : "Specific power source",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<i>Power sources</i> can be used to simulate heat generation from a volume. Two types are available:<br><li><b>Absolute</b></li>: Used when total power emitted by the assigned volume is known.<li><b>Specific</b></li>: Used when power density of the assigned volume is known. <a href='https://www.simscale.com/docs/simulation-setup/advanced-concepts/power-sources/' target='_blank'>Learn more</a>.\n\nSchema name: SpecificPowerSource",
            "default" : "SPECIFIC_V23"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "heatFlux" : {
            "$ref" : "#/components/schemas/DimensionalFunction_VolumetricPower"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE" ]
            }
          }
        },
        "additionalProperties" : false,
        "description" : "<i>Power sources</i> can be used to simulate heat generation from a volume. Two types are available:<br><li><b>Absolute</b></li>: Used when total power emitted by the assigned volume is known.<li><b>Specific</b></li>: Used when power density of the assigned volume is known. <a href='https://www.simscale.com/docs/simulation-setup/advanced-concepts/power-sources/' target='_blank'>Learn more</a>."
      },
      "AverageVelocityMomentumSource" : {
        "title" : "Average velocity",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AverageVelocityMomentumSource",
            "default" : "AVERAGE_VELOCITY"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "averageVelocity" : {
            "$ref" : "#/components/schemas/DimensionalVector_Speed"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "FanPressureDropMomentumSource" : {
        "title" : "Fan model",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FanPressureDropMomentumSource",
            "default" : "FAN_PRESSURE_DROP"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "fanDirection" : {
            "$ref" : "#/components/schemas/DimensionalVector_Dimensionless"
          },
          "fanPressure" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Pressure"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVector_Dimensionless" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/DecimalVector"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "" ]
          }
        },
        "additionalProperties" : false
      },
      "AbsolutePassiveScalarSource" : {
        "title" : "Passive scalar source",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AbsolutePassiveScalarSource",
            "default" : "ABSOLUTE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "passiveScalarVariable" : {
            "title" : "Passive scalar variable",
            "type" : "string",
            "default" : "passive_scalar_one",
            "x-conditionalEnum" : [ {
              "value" : "passive_scalar_one"
            }, {
              "value" : "passive_scalar_two",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 1", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 1", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 1" ]
            }, {
              "value" : "passive_scalar_three",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 2", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 2", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 2" ]
            }, {
              "value" : "passive_scalar_four",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 3", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 3", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 3" ]
            }, {
              "value" : "passive_scalar_five",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 4", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 4", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 4" ]
            }, {
              "value" : "passive_scalar_six",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 5", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 5", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 5" ]
            }, {
              "value" : "passive_scalar_seven",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 6", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 6", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 6" ]
            }, {
              "value" : "passive_scalar_eight",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 7", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 7", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 7" ]
            }, {
              "value" : "passive_scalar_nine",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 8", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 8", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 8" ]
            } ]
          },
          "flux" : {
            "$ref" : "#/components/schemas/Dimensional_PassiveScalarSourceRate"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE", "POINT" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_PassiveScalarSourceRate" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/s" ]
          }
        },
        "additionalProperties" : false
      },
      "SpecificPassiveScalarSource" : {
        "title" : "Volumetric passive scalar source",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SpecificPassiveScalarSource",
            "default" : "SPECIFIC"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "passiveScalarVariable" : {
            "title" : "Passive scalar variable",
            "type" : "string",
            "default" : "passive_scalar_one",
            "x-conditionalEnum" : [ {
              "value" : "passive_scalar_one"
            }, {
              "value" : "passive_scalar_two",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 1", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 1", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 1" ]
            }, {
              "value" : "passive_scalar_three",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 2", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 2", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 2" ]
            }, {
              "value" : "passive_scalar_four",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 3", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 3", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 3" ]
            }, {
              "value" : "passive_scalar_five",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 4", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 4", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 4" ]
            }, {
              "value" : "passive_scalar_six",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 5", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 5", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 5" ]
            }, {
              "value" : "passive_scalar_seven",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 6", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 6", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 6" ]
            }, {
              "value" : "passive_scalar_eight",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 7", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 7", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 7" ]
            }, {
              "value" : "passive_scalar_nine",
              "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 8", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 8", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 8" ]
            } ]
          },
          "flux" : {
            "$ref" : "#/components/schemas/Dimensional_VolumetricPassiveScalarSourceRate"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER", "SPHERE", "POINT" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "Dimensional_VolumetricPassiveScalarSourceRate" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "1/(ms)", "1/(ins)" ]
          }
        },
        "additionalProperties" : false
      },
      "StarThermalResistanceNetwork" : {
        "title" : "Star Network Resistance Model",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<br>A <i>Thermal Resistance Network</i> can be used to approximate the effect of heat sources and heat transfer from that source to the surrounding domain without resolving the source geometry.  Select the top face of the body you want to assign. <p>The models for <b>Thermal resistance network</b> are as follows:</p><ul><li><b>Star Network Resistance Model:</b> defines a thermal resistance network consisting out of a top, a board, a board to interface and four side resistances. A power source is assigned to the body.</li><li><b>Two resistor Model:</b> defines a thermal resistance network consisting out of a top, a board and a board to interface resistance. A power source is assigned to the body.</li></ul> <br> <a href='https://www.simscale.com/docs/simulation-setup/advanced-concepts/thermal-resistance-networks/' target='_blank'>Learn more</a>.\n\nSchema name: StarThermalResistanceNetwork",
            "default" : "STAR_NETWORK"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "resistanceTop" : {
            "$ref" : "#/components/schemas/Dimensional_ContactResistance"
          },
          "resistanceBottom" : {
            "$ref" : "#/components/schemas/Dimensional_ContactResistance"
          },
          "resistanceSides" : {
            "$ref" : "#/components/schemas/Dimensional_ContactResistance"
          },
          "resistanceInterface" : {
            "$ref" : "#/components/schemas/Dimensional_ContactResistance"
          },
          "networkPower" : {
            "$ref" : "#/components/schemas/Dimensional_Power"
          },
          "emissivity" : {
            "title" : "Emissivity",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.9,
            "x-showWhen" : [ "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableRadiation == true" ]
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<br>A <i>Thermal Resistance Network</i> can be used to approximate the effect of heat sources and heat transfer from that source to the surrounding domain without resolving the source geometry.  Select the top face of the body you want to assign. <p>The models for <b>Thermal resistance network</b> are as follows:</p><ul><li><b>Star Network Resistance Model:</b> defines a thermal resistance network consisting out of a top, a board, a board to interface and four side resistances. A power source is assigned to the body.</li><li><b>Two resistor Model:</b> defines a thermal resistance network consisting out of a top, a board and a board to interface resistance. A power source is assigned to the body.</li></ul> <br> <a href='https://www.simscale.com/docs/simulation-setup/advanced-concepts/thermal-resistance-networks/' target='_blank'>Learn more</a>."
      },
      "TwoResistorNetwork" : {
        "title" : "Two Resistor Model",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<br>A <i>Thermal Resistance Network</i> can be used to approximate the effect of heat sources and heat transfer from that source to the surrounding domain without resolving the source geometry.  Select the top face of the body you want to assign. <p>The models for <b>Thermal resistance network</b> are as follows:</p><ul><li><b>Star Network Resistance Model:</b> defines a thermal resistance network consisting out of a top, a board, a board to interface and four side resistances. A power source is assigned to the body.</li><li><b>Two resistor Model:</b> defines a thermal resistance network consisting out of a top, a board and a board to interface resistance. A power source is assigned to the body.</li></ul> <br> <a href='https://www.simscale.com/docs/simulation-setup/advanced-concepts/thermal-resistance-networks/' target='_blank'>Learn more</a>.\n\nSchema name: TwoResistorNetwork",
            "default" : "TWO_RESISTOR_NETWORK"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "resistanceTop" : {
            "$ref" : "#/components/schemas/Dimensional_ContactResistance"
          },
          "resistanceBottom" : {
            "$ref" : "#/components/schemas/Dimensional_ContactResistance"
          },
          "resistanceInterface" : {
            "$ref" : "#/components/schemas/Dimensional_ContactResistance"
          },
          "networkPower" : {
            "$ref" : "#/components/schemas/Dimensional_Power"
          },
          "emissivity" : {
            "title" : "Emissivity",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.9,
            "x-showWhen" : [ "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableRadiation == true" ]
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<br>A <i>Thermal Resistance Network</i> can be used to approximate the effect of heat sources and heat transfer from that source to the surrounding domain without resolving the source geometry.  Select the top face of the body you want to assign. <p>The models for <b>Thermal resistance network</b> are as follows:</p><ul><li><b>Star Network Resistance Model:</b> defines a thermal resistance network consisting out of a top, a board, a board to interface and four side resistances. A power source is assigned to the body.</li><li><b>Two resistor Model:</b> defines a thermal resistance network consisting out of a top, a board and a board to interface resistance. A power source is assigned to the body.</li></ul> <br> <a href='https://www.simscale.com/docs/simulation-setup/advanced-concepts/thermal-resistance-networks/' target='_blank'>Learn more</a>."
      },
      "FluidNumerics" : {
        "type" : "object",
        "properties" : {
          "relaxationType" : {
            "title" : "Relaxation type",
            "type" : "string",
            "default" : "MANUAL",
            "x-showWhen" : [ "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]", "type == INCOMPRESSIBLE && algorithm != PISO", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT", "type == MULTIPHASE" ],
            "x-conditionalEnum" : [ {
              "value" : "AUTOMATIC",
              "when" : [ "type == INCOMPRESSIBLE && enableAdjointOptimization == false", "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER] && timeDependency.type == STATIONARY" ]
            }, {
              "value" : "MANUAL"
            } ]
          },
          "relaxationFactor" : {
            "$ref" : "#/components/schemas/RelaxationFactor"
          },
          "radiationResolution" : {
            "title" : "Radiation resolution",
            "type" : "string",
            "default" : "MODERATE",
            "enum" : [ "COARSE", "MODERATE", "FINE" ],
            "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && enableRadiation == true", "type == CONJUGATE_HEAT_TRANSFER && enableRadiation == true", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableRadiation == true", "type == EMBEDDED_BOUNDARY && enableRadiation == true" ]
          },
          "momentumPredictor" : {
            "title" : "Momentum predictor",
            "type" : "boolean",
            "x-showWhen" : [ "type in [CONJUGATE_HEAT_TRANSFER,MULTIPHASE,CONVECTIVE_HEAT_TRANSFER]", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "type == MULTIPHASE && useLocalTimeStepping == false", "type == COMPRESSIBLE", "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER] && timeDependency.type == TRANSIENT" ],
              "default" : false
            }, {
              "when" : [ "type == MULTIPHASE && useLocalTimeStepping == true", "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER] && timeDependency.type == STATIONARY" ],
              "default" : true
            } ]
          },
          "transonic" : {
            "title" : "Transonic",
            "type" : "boolean",
            "default" : false,
            "x-showWhen" : [ "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && timeDependency.type == TRANSIENT && isCompressible == true" ]
          },
          "numOuterCorrectors" : {
            "title" : "Number of outer correctors",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 3,
            "x-showWhen" : [ "type == MULTIPHASE", "type == INCOMPRESSIBLE && algorithm == PIMPLE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT", "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER] && timeDependency.type == TRANSIENT" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "type == MULTIPHASE" ],
              "default" : 6
            }, {
              "when" : [ "type == INCOMPRESSIBLE && algorithm == PIMPLE" ],
              "default" : 4
            } ]
          },
          "numCorrectors" : {
            "title" : "Number of correctors",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 4,
            "x-showWhen" : [ "type == MULTIPHASE", "type == INCOMPRESSIBLE && algorithm in [PIMPLE,PISO,ICO]", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT", "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER] && timeDependency.type == TRANSIENT" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "type == MULTIPHASE" ],
              "default" : 3
            }, {
              "when" : [ "type == INCOMPRESSIBLE && algorithm == PIMPLE" ],
              "default" : 2
            } ]
          },
          "numNonOrthogonalCorrectors" : {
            "title" : "Number of non-orthogonal correctors",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>The pressure equation is repeatedly solved based on the value of non-orthogonal correctors in the PISO/SIMPLE/PIMPLE algorithm. This may reduce the effect of bad mesh.</p>",
            "default" : 1,
            "x-showWhen" : [ "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,INCOMPRESSIBLE,MULTIPHASE,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT" ]
          },
          "smoothingParameter" : {
            "title" : "Smoothing parameter",
            "maximum" : 10000000,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.05,
            "x-showWhen" : [ "type == MULTIPHASE && useLocalTimeStepping == true" ]
          },
          "dampingCoefficient" : {
            "title" : "Damping coefficient",
            "maximum" : 10000000,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.5,
            "x-showWhen" : [ "type == MULTIPHASE && useLocalTimeStepping == true" ]
          },
          "numAlphaSpreadIterations" : {
            "title" : "Number of alpha spread iterations",
            "maximum" : 10000000,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 0,
            "x-showWhen" : [ "type == MULTIPHASE && useLocalTimeStepping == true" ]
          },
          "numAlphaSweepIterations" : {
            "title" : "Number of alpha sweep iterations",
            "maximum" : 10000000,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 0,
            "x-showWhen" : [ "type == MULTIPHASE && useLocalTimeStepping == true" ]
          },
          "evaluateTurbulenceOnlyOnFinalIteration" : {
            "title" : "Evaluate turbulence only on final iteration",
            "type" : "boolean",
            "default" : false,
            "x-showWhen" : [ "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && timeDependency.type == TRANSIENT && isCompressible == true" ]
          },
          "pressureReferenceCell" : {
            "title" : "Pressure reference cell",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Enter the cell where you want to define reference pressure in the PISO/SIMPLE/PIMPLE algorithm.</p>",
            "default" : 0,
            "x-showWhen" : [ "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,INCOMPRESSIBLE,MULTIPHASE]", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT" ]
          },
          "pressureReferenceValue" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "velocityLimit" : {
            "$ref" : "#/components/schemas/Dimensional_Speed"
          },
          "residualControls" : {
            "$ref" : "#/components/schemas/ResidualControls"
          },
          "solvers" : {
            "$ref" : "#/components/schemas/FluidSolvers"
          },
          "schemes" : {
            "$ref" : "#/components/schemas/Schemes"
          },
          "stabilization" : {
            "$ref" : "#/components/schemas/Stabilization"
          }
        },
        "additionalProperties" : false
      },
      "RelaxationFactor" : {
        "type" : "object",
        "properties" : {
          "pressureField" : {
            "title" : "(P) Pressure field",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>With this parameter you can initialize the under-relaxation of a field or equation. The solver will dynamically adapt this factor to improve stability.</p>",
            "x-showWhen" : [ "type == INCOMPRESSIBLE && algorithm == PIMPLE", "type == INCOMPRESSIBLE && algorithm == SIMPLE && turbulenceModel in [NONE,KEPSILON,KOMEGA,KOMEGASST]", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "timeDependency.type == TRANSIENT", "timeDependency.type == STATIONARY && 2/relaxationType == AUTOMATIC" ],
              "default" : 0.7
            }, {
              "when" : [ "timeDependency.type == STATIONARY && 2/relaxationType == MANUAL" ],
              "default" : 0.3
            } ]
          },
          "pressureRghField" : {
            "title" : "(P) Modified pressure field",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.7,
            "x-showWhen" : [ "type in [CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,MULTIPHASE,EMBEDDED_BOUNDARY]" ]
          },
          "passiveScalarEquation" : {
            "title" : "(T*) Passive Scalar Equation",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 1,
            "x-showWhen" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 0", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 0", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 0" ]
          },
          "velocityEquation" : {
            "title" : "(U) Velocity equation",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>With this parameter you can initialize the under-relaxation of a field or equation. The solver will dynamically adapt this factor to improve stability.</p>",
            "x-showWhen" : [ "type == MULTIPHASE", "type in [CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]", "type == INCOMPRESSIBLE && algorithm == PIMPLE", "type == INCOMPRESSIBLE && algorithm == SIMPLE && turbulenceModel in [NONE,KEPSILON,KOMEGA,KOMEGASST]", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && timeDependency.type == STATIONARY && 2/relaxationType == AUTOMATIC" ],
              "default" : 0.01
            }, {
              "when" : [ "type in [EMBEDDED_BOUNDARY,COUPLED_CONJUGATE_HEAT_TRANSFER]", "type in [CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && timeDependency.type == STATIONARY && 2/relaxationType == MANUAL" ],
              "default" : 0.3
            }, {
              "when" : [ "type in [INCOMPRESSIBLE,COMPRESSIBLE] && timeDependency.type == STATIONARY && 2/relaxationType == MANUAL" ],
              "default" : 0.7
            }, {
              "when" : [ "type == MULTIPHASE", "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && timeDependency.type == TRANSIENT" ],
              "default" : 0.8
            } ]
          },
          "temperatureEquation" : {
            "title" : "(T) Temperature equation",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false", "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "type == CONVECTIVE_HEAT_TRANSFER && 2/relaxationType == AUTOMATIC" ],
              "default" : 0.01
            }, {
              "when" : [ "type in [EMBEDDED_BOUNDARY,COUPLED_CONJUGATE_HEAT_TRANSFER]", "type == CONVECTIVE_HEAT_TRANSFER && 2/relaxationType == MANUAL" ],
              "default" : 0.8
            } ]
          },
          "densityField" : {
            "title" : "() Density field",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>With this parameter you can initialize the under-relaxation of a field or equation. The solver will dynamically adapt this factor to improve stability.</p>",
            "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == true" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "timeDependency.type == STATIONARY && 2/relaxationType == AUTOMATIC" ],
              "default" : 0.01
            }, {
              "when" : [ "timeDependency.type == TRANSIENT", "type != COMPRESSIBLE && timeDependency.type == STATIONARY && 2/relaxationType == MANUAL" ],
              "default" : 0.8
            }, {
              "when" : [ "type == COMPRESSIBLE && timeDependency.type == STATIONARY && 2/relaxationType == MANUAL" ],
              "default" : 0.1
            } ]
          },
          "enthalpyEquation" : {
            "title" : "(h) Enthalpy equation",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>With this parameter you can initialize the under-relaxation of a field or equation. The solver will dynamically adapt this factor to improve stability.</p>",
            "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == true" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "timeDependency.type == STATIONARY && 2/relaxationType == AUTOMATIC" ],
              "default" : 0.01
            }, {
              "when" : [ "timeDependency.type == TRANSIENT", "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER] && timeDependency.type == STATIONARY && 2/relaxationType == MANUAL" ],
              "default" : 0.8
            }, {
              "when" : [ "type == COMPRESSIBLE && timeDependency.type == STATIONARY && 2/relaxationType == MANUAL" ],
              "default" : 0.1
            } ]
          },
          "internalEnergyEquation" : {
            "title" : "(e) Internal energy equation",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>With this parameter you can initialize the under-relaxation of a field or equation. The solver will dynamically adapt this factor to improve stability.</p>",
            "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == true" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "timeDependency.type == STATIONARY && 2/relaxationType == AUTOMATIC" ],
              "default" : 0.01
            }, {
              "when" : [ "timeDependency.type == TRANSIENT", "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER] && timeDependency.type == STATIONARY && 2/relaxationType == MANUAL" ],
              "default" : 0.8
            }, {
              "when" : [ "type == COMPRESSIBLE && timeDependency.type == STATIONARY && 2/relaxationType == MANUAL" ],
              "default" : 0.1
            } ]
          },
          "turbulentKineticEnergyEquation" : {
            "title" : "(k) Turb. kinetic energy equation",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "x-showWhen" : [ "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY] && turbulenceModel in [KEPSILON,KOMEGASST]", "type == MULTIPHASE && turbulenceModel in [KEPSILON,KOMEGA,KOMEGASST]", "type == INCOMPRESSIBLE && turbulenceModel in [KEPSILON,KOMEGA,KOMEGASST] && algorithm in [PIMPLE,SIMPLE]" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && timeDependency.type == STATIONARY && 2/relaxationType == AUTOMATIC" ],
              "default" : 0.01
            }, {
              "when" : [ "type in [EMBEDDED_BOUNDARY,COUPLED_CONJUGATE_HEAT_TRANSFER]", "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && timeDependency.type == STATIONARY && 2/relaxationType == MANUAL" ],
              "default" : 0.3
            }, {
              "when" : [ "type == MULTIPHASE", "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && timeDependency.type == TRANSIENT" ],
              "default" : 0.7
            } ]
          },
          "omegaDissipationRateEquation" : {
            "title" : "() Specific dissipation rate equation",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "x-showWhen" : [ "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY] && turbulenceModel == KOMEGASST", "type == MULTIPHASE && turbulenceModel in [KOMEGA,KOMEGASST]", "type == INCOMPRESSIBLE && turbulenceModel in [KOMEGA,KOMEGASST] && algorithm in [PIMPLE,SIMPLE]" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && timeDependency.type == STATIONARY && 2/relaxationType == AUTOMATIC" ],
              "default" : 0.01
            }, {
              "when" : [ "type in [EMBEDDED_BOUNDARY,COUPLED_CONJUGATE_HEAT_TRANSFER]", "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && timeDependency.type == STATIONARY && 2/relaxationType == MANUAL" ],
              "default" : 0.3
            }, {
              "when" : [ "type == MULTIPHASE", "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && timeDependency.type == TRANSIENT" ],
              "default" : 0.7
            } ]
          },
          "epsilonDissipationRateEquation" : {
            "title" : "() Dissipation rate equation",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "x-showWhen" : [ "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER,MULTIPHASE] && turbulenceModel == KEPSILON", "type == INCOMPRESSIBLE && turbulenceModel == KEPSILON && algorithm in [PIMPLE,SIMPLE]" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "timeDependency.type == STATIONARY && 2/relaxationType == AUTOMATIC" ],
              "default" : 0.01
            }, {
              "when" : [ "timeDependency.type == STATIONARY && 2/relaxationType == MANUAL" ],
              "default" : 0.3
            }, {
              "when" : [ "timeDependency.type == TRANSIENT", "type == MULTIPHASE" ],
              "default" : 0.7
            } ]
          },
          "nuTildaEquation" : {
            "title" : "() nuTilda equation",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "x-showWhen" : [ "type == INCOMPRESSIBLE && algorithm in [PIMPLE,PISO] && turbulenceModel == SPALARTALLMARAS", "type == COMPRESSIBLE && turbulenceModel == SPALARTALLMARAS", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel == SPALARTALLMARAS" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "timeDependency.type == STATIONARY" ],
              "default" : 0.3
            }, {
              "when" : [ "timeDependency.type == TRANSIENT", "type == MULTIPHASE" ],
              "default" : 0.7
            } ]
          },
          "netRadiativeHeatFluxField" : {
            "title" : "(Qr) Net radiative heat flux field",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.3,
            "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && enableRadiation == true", "type == CONJUGATE_HEAT_TRANSFER && enableRadiation == true" ]
          },
          "radiativeIntensityRayEquation" : {
            "title" : "(I) Radiative intensity ray equation",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.5,
            "x-showWhen" : [ "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableRadiation == true", "type == EMBEDDED_BOUNDARY && enableRadiation == true" ]
          }
        },
        "additionalProperties" : false
      },
      "ResidualControls" : {
        "type" : "object",
        "properties" : {
          "velocity" : {
            "$ref" : "#/components/schemas/Tolerance"
          },
          "pressure" : {
            "$ref" : "#/components/schemas/Tolerance"
          },
          "pressureRgh" : {
            "$ref" : "#/components/schemas/Tolerance"
          },
          "temperature" : {
            "$ref" : "#/components/schemas/Tolerance"
          },
          "turbulentKineticEnergy" : {
            "$ref" : "#/components/schemas/Tolerance"
          },
          "omegaDissipationRate" : {
            "$ref" : "#/components/schemas/Tolerance"
          },
          "epsilonDissipationRate" : {
            "$ref" : "#/components/schemas/Tolerance"
          }
        },
        "additionalProperties" : false
      },
      "Tolerance" : {
        "type" : "object",
        "properties" : {
          "absoluteTolerance" : {
            "title" : "Absolute tolerance",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "Absolute tolerance is the measure of residual in the solution after the current iteration is solved. The solution is stopped when the absolute residual falls below this value.",
            "default" : 1.0E-5,
            "x-showWhen" : [ "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER]", "type == INCOMPRESSIBLE && algorithm in [PIMPLE,SIMPLE]", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "type == INCOMPRESSIBLE && timeDependency.type == STATIONARY" ],
              "default" : 1.0E-6
            } ]
          },
          "relativeTolerance" : {
            "title" : "Relative tolerance",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "Relative tolerance is the ratio of current residual to the initial residual. The solution is stopped when the relative residual falls below this value.",
            "default" : 0.01,
            "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == INCOMPRESSIBLE && timeDependency.type == TRANSIENT && algorithm == PIMPLE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == true && timeDependency.type == TRANSIENT" ]
          }
        },
        "additionalProperties" : false
      },
      "FluidSolvers" : {
        "type" : "object",
        "properties" : {
          "phaseFractionSolver" : {
            "$ref" : "#/components/schemas/MULESSolver"
          },
          "velocitySolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversVelocitySolver"
          },
          "velocityFinalSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversVelocityFinalSolver"
          },
          "densitySolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversDensitySolver"
          },
          "densityFinalSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversDensityFinalSolver"
          },
          "pressureSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversPressureSolver"
          },
          "pressureFinalSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversPressureFinalSolver"
          },
          "temperatureSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversTemperatureSolver"
          },
          "temperatureFinalSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversTemperatureFinalSolver"
          },
          "pressureRghSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversPressureRghSolver"
          },
          "pressureRghFinalSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversPressureRghFinalSolver"
          },
          "solidEnthalpySolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversSolidEnthalpySolver"
          },
          "solidEnthalpyFinalSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversSolidEnthalpyFinalSolver"
          },
          "enthalpySolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversEnthalpySolver"
          },
          "enthalpyFinalSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversEnthalpyFinalSolver"
          },
          "internalEnergySolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversInternalEnergySolver"
          },
          "internalEnergyFinalSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversInternalEnergyFinalSolver"
          },
          "turbulentKineticEnergySolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversTurbulentKineticEnergySolver"
          },
          "turbulentKineticEnergyFinalSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversTurbulentKineticEnergyFinalSolver"
          },
          "nuTildaSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversNuTildaSolver"
          },
          "nuTildaFinalSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversNuTildaFinalSolver"
          },
          "omegaDissipationRateSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversOmegaDissipationRateSolver"
          },
          "omegaDissipationRateFinalSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversOmegaDissipationRateFinalSolver"
          },
          "epsilonDissipationRateSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversEpsilonDissipationRateSolver"
          },
          "epsilonDissipationRateFinalSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversEpsilonDissipationRateFinalSolver"
          },
          "passiveScalarSolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversPassiveScalarSolver"
          },
          "radiativeIntensityRaySolver" : {
            "$ref" : "#/components/schemas/OneOf_FluidSolversRadiativeIntensityRaySolver"
          }
        },
        "additionalProperties" : false
      },
      "MULESSolver" : {
        "title" : "MULES",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: MULESSolver",
            "default" : "MULES_V7"
          },
          "alphaCorrectors" : {
            "title" : "Alpha correctors",
            "type" : "integer",
            "default" : 2
          },
          "alphaSubCycles" : {
            "title" : "Alpha sub cycles",
            "type" : "integer",
            "default" : 2
          },
          "compressionCoefficient" : {
            "title" : "Compression coefficient",
            "type" : "number",
            "default" : 1
          },
          "isotropicCompressionCoefficient" : {
            "title" : "Isotropic compression coefficient",
            "type" : "number",
            "default" : 0.25
          },
          "semiImplicit" : {
            "$ref" : "#/components/schemas/OneOf_MULESSolverSemiImplicit"
          }
        },
        "additionalProperties" : false
      },
      "FalseSemiImplicit" : {
        "title" : "No",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FalseSemiImplicit",
            "default" : "FALSE_SEMI_IMPLICIT"
          }
        },
        "additionalProperties" : false
      },
      "TrueSemiImplicit" : {
        "title" : "Yes",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TrueSemiImplicit",
            "default" : "TRUE_SEMI_IMPLICIT"
          },
          "limiterIterations" : {
            "title" : "Limiter iterations",
            "type" : "integer",
            "default" : 8
          },
          "compressionCorrection" : {
            "title" : "Compression correction",
            "type" : "boolean",
            "default" : true
          },
          "solver" : {
            "$ref" : "#/components/schemas/OneOf_TrueSemiImplicitSolver"
          }
        },
        "additionalProperties" : false
      },
      "PBICGSolver" : {
        "title" : "PBiCG",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PBICGSolver",
            "default" : "PBICG"
          },
          "absoluteTolerance" : {
            "title" : "Absolute tolerance",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Define the absolute tolerance for the residual. The convergence process will be stopped as soon as the residual falls below the absolute tolerance.</p>",
            "default" : 1.0E-5,
            "x-conditionalDefaults" : [ {
              "when" : [ "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ],
              "default" : 1.0E-15
            }, {
              "when" : [ "1# == passiveScalarSolver" ],
              "default" : 1.0E-8
            } ]
          },
          "relativeTolerance" : {
            "title" : "Relative tolerance",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Choose the relative tolerance for the residual. The convergence process will be stopped as soon as the ratio of current to initial residual falls below the relative tolerance.</p>",
            "x-conditionalDefaults" : [ {
              "when" : [ "1# in [velocitySolver,nuTildaSolver,nuTildaFinalSolver,turbulentKineticEnergySolver,epsilonDissipationRateSolver,turbulentKineticEnergyFinalSolver,epsilonDissipationRateFinalSolver,omegaDissipationRateSolver,omegaDissipationRateFinalSolver,enthalpySolver,internalEnergySolver,phaseFractionSolver,temperatureSolver,temperatureFinalSolver,passiveScalarSolver,radiativeIntensityRaySolver]", "type in [INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE] && 1# in [velocityFinalSolver,enthalpyFinalSolver,internalEnergyFinalSolver]" ],
              "default" : 0.01
            }, {
              "when" : [ "type == COMPRESSIBLE && 1# in [velocityFinalSolver,enthalpyFinalSolver,internalEnergyFinalSolver]" ],
              "default" : 0
            } ]
          },
          "preconditioner" : {
            "$ref" : "#/components/schemas/OneOf_PBICGSolverPreconditioner"
          }
        },
        "additionalProperties" : false
      },
      "DILUPreconditioner" : {
        "title" : "DILU",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Diagonal incomplete lower-upper (ILU) algorithm for non-symmetric matrices without fill-in.\n\nSchema name: DILUPreconditioner",
            "default" : "DILU"
          }
        },
        "additionalProperties" : false,
        "description" : "Diagonal incomplete lower-upper (ILU) algorithm for non-symmetric matrices without fill-in."
      },
      "ILUCpPreconditioner" : {
        "title" : "ILUCP",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Crout's version of the incomplete lower-upper (ILU) algorithm with arbitrary level of fill-in.\n\nSchema name: ILUCpPreconditioner",
            "default" : "ILUCP"
          },
          "fillInLevel" : {
            "title" : "Fill in level",
            "maximum" : 4,
            "exclusiveMaximum" : false,
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "Number of face-neighbour layers to fill in. Increasing the level of fill-in improves the performance of preconditioner at the expense of computational overhead.",
            "default" : 1
          }
        },
        "additionalProperties" : false,
        "description" : "Crout's version of the incomplete lower-upper (ILU) algorithm with arbitrary level of fill-in."
      },
      "SmoothSolver" : {
        "title" : "Smooth solver",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SmoothSolver",
            "default" : "SMOOTH"
          },
          "absoluteTolerance" : {
            "title" : "Absolute tolerance",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Define the absolute tolerance for the residual. The convergence process will be stopped as soon as the residual falls below the absolute tolerance.</p>",
            "x-conditionalDefaults" : [ {
              "when" : [ "1# in [phaseFractionSolver,passiveScalarSolver]" ],
              "default" : 1.0E-8
            }, {
              "when" : [ "type == INCOMPRESSIBLE && 1# == velocityFinalSolver", "type == INCOMPRESSIBLE && numOfPassiveSpecies > 0", "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER]" ],
              "default" : 1.0E-7
            }, {
              "when" : [ "type == MULTIPHASE", "type == INCOMPRESSIBLE && 1# != velocityFinalSolver", "type == INCOMPRESSIBLE && numOfPassiveSpecies == 0" ],
              "default" : 1.0E-6
            }, {
              "when" : [ "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ],
              "default" : 1.0E-15
            } ]
          },
          "relativeTolerance" : {
            "title" : "Relative tolerance",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Choose the relative tolerance for the residual. The convergence process will be stopped as soon as the ratio of current to initial residual falls below the relative tolerance.</p>",
            "default" : 0.01,
            "x-conditionalDefaults" : [ {
              "when" : [ "1# == phaseFractionSolver" ],
              "default" : 0.01
            }, {
              "when" : [ "type == INCOMPRESSIBLE && 1# in [turbulentKineticEnergyFinalSolver,omegaDissipationRateFinalSolver]", "type == MULTIPHASE && 1# in [velocityFinalSolver,turbulentKineticEnergyFinalSolver,omegaDissipationRateFinalSolver]" ],
              "default" : 0.001
            }, {
              "when" : [ "type == INCOMPRESSIBLE && 1# == omegaDissipationRateFinalSolver && numOfPassiveSpecies > 0" ],
              "default" : 0.05
            } ]
          },
          "smoother" : {
            "title" : "Smoother",
            "type" : "string",
            "description" : "<p>Choose a smoother for your solver.</p>",
            "default" : "GAUSSSEIDEL",
            "enum" : [ "GAUSSSEIDEL", "SYMGAUSSSEIDEL" ]
          },
          "numSweeps" : {
            "title" : "Number of sweeps",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the numbers of sweeps.</p>",
            "default" : 1
          }
        },
        "additionalProperties" : false
      },
      "GAMGSolver" : {
        "title" : "GAMG",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GAMGSolver",
            "default" : "GAMG"
          },
          "absoluteTolerance" : {
            "title" : "Absolute tolerance",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Define the absolute tolerance for the residual. The convergence process will be stopped as soon as the residual falls below the absolute tolerance.</p>",
            "x-conditionalDefaults" : [ {
              "when" : [ "type == MULTIPHASE && 1# in [pressureRghSolver,pressureRghFinalSolver]" ],
              "default" : 1.0E-8
            }, {
              "when" : [ "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ],
              "default" : 1.0E-15
            }, {
              "when" : [ "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER]", "type == INCOMPRESSIBLE && 1# == pressureSolver && numOfPassiveSpecies > 0" ],
              "default" : 1.0E-7
            }, {
              "when" : [ "type == MULTIPHASE && 1# != pressureRghSolver", "type == MULTIPHASE && 1# != pressureRghFinalSolver", "type == INCOMPRESSIBLE && numOfPassiveSpecies == 0", "type == INCOMPRESSIBLE && 1# != pressureSolver" ],
              "default" : 1.0E-6
            } ]
          },
          "relativeTolerance" : {
            "title" : "Relative tolerance",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Choose the relative tolerance for the residual. The convergence process will be stopped as soon as the ratio of current to initial residual falls below the relative tolerance.</p>",
            "x-conditionalDefaults" : [ {
              "when" : [ "type == INCOMPRESSIBLE && 1# == pressureSolver && timeDependency.type == TRANSIENT", "type == MULTIPHASE && 1# == pressureRghFinalSolver" ],
              "default" : 0.005
            }, {
              "when" : [ "type == INCOMPRESSIBLE && 1# != pressureSolver", "type == INCOMPRESSIBLE && timeDependency.type == STATIONARY" ],
              "default" : 0.001
            }, {
              "when" : [ "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]", "type == MULTIPHASE && 1# != pressureRghFinalSolver" ],
              "default" : 0.01
            } ]
          },
          "smoother" : {
            "title" : "Smoother",
            "type" : "string",
            "description" : "<p>Choose a smoother for your solver.</p>",
            "default" : "GAUSSSEIDEL",
            "enum" : [ "GAUSSSEIDEL" ]
          },
          "numPreSweeps" : {
            "title" : "Number of pre sweeps",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "x-conditionalDefaults" : [ {
              "when" : [ "type in [CONJUGATE_HEAT_TRANSFER,MULTIPHASE,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ],
              "default" : 1
            }, {
              "when" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER]" ],
              "default" : 2
            } ]
          },
          "numPostSweeps" : {
            "title" : "Number of post sweeps",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 1
          },
          "cacheAgglomerationOn" : {
            "title" : "Cache agglomeration on",
            "type" : "boolean",
            "default" : true
          },
          "numCellsCoarsestLevel" : {
            "title" : "Number of cells coarsest level",
            "minimum" : 2,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 100
          },
          "numMergeLevels" : {
            "title" : "Number of merge levels",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 1
          }
        },
        "additionalProperties" : false
      },
      "PCGSolver" : {
        "title" : "PCG",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PCGSolver",
            "default" : "PCG"
          },
          "absoluteTolerance" : {
            "title" : "Absolute tolerance",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Define the absolute tolerance for the residual. The convergence process will be stopped as soon as the residual falls below the absolute tolerance.</p>",
            "x-conditionalDefaults" : [ {
              "when" : [ "1# == solidEnthalpySolver" ],
              "default" : 1.0E-5
            }, {
              "when" : [ "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ],
              "default" : 1.0E-15
            }, {
              "when" : [ "type != COUPLED_CONJUGATE_HEAT_TRANSFER && type != EMBEDDED_BOUNDARY", "1# != solidEnthalpySolver" ],
              "default" : 1.0E-4
            } ]
          },
          "relativeTolerance" : {
            "title" : "Relative tolerance",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Choose the relative tolerance for the residual. The convergence process will be stopped as soon as the ratio of current to initial residual falls below the relative tolerance.</p>",
            "default" : 0.01
          },
          "preconditioner" : {
            "$ref" : "#/components/schemas/OneOf_PCGSolverPreconditioner"
          }
        },
        "additionalProperties" : false
      },
      "DICPreconditioner" : {
        "title" : "DIC",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Diagonal incomplete Cholesky algorithm for symmetric matrices without fill-in.\n\nSchema name: DICPreconditioner",
            "default" : "DIC"
          }
        },
        "additionalProperties" : false,
        "description" : "Diagonal incomplete Cholesky algorithm for symmetric matrices without fill-in."
      },
      "Schemes" : {
        "type" : "object",
        "properties" : {
          "flux" : {
            "$ref" : "#/components/schemas/FluxSchemes"
          },
          "timeDifferentiation" : {
            "$ref" : "#/components/schemas/TimeDifferentiationSchemes"
          },
          "gradient" : {
            "$ref" : "#/components/schemas/GradientSchemes"
          },
          "divergence" : {
            "$ref" : "#/components/schemas/DivergenceSchemes"
          },
          "laplacian" : {
            "$ref" : "#/components/schemas/LaplacianSchemes"
          },
          "interpolation" : {
            "$ref" : "#/components/schemas/InterpolationSchemes"
          },
          "surfaceNormalGradient" : {
            "$ref" : "#/components/schemas/SurfaceNormalGradientSchemes"
          },
          "secondOrderConvection" : {
            "title" : "Second order convection",
            "type" : "boolean",
            "description" : "Whether to use second-order convection scheme, which is less stable but more accurate for a given mesh. If false, first-order accurate upwind scheme is used.",
            "default" : false,
            "x-showWhen" : [ "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ]
          }
        },
        "additionalProperties" : false
      },
      "FluxSchemes" : {
        "type" : "object",
        "properties" : {
          "forDefault" : {
            "$ref" : "#/components/schemas/OneOf_FluxSchemesForDefault"
          }
        },
        "additionalProperties" : false
      },
      "TadmorFluxScheme" : {
        "title" : "Tadmor flux scheme",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TadmorFluxScheme",
            "default" : "TADMOR"
          }
        },
        "additionalProperties" : false
      },
      "KurganovFluxScheme" : {
        "title" : "Kurganov",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: KurganovFluxScheme",
            "default" : "KURGANOV"
          }
        },
        "additionalProperties" : false
      },
      "TimeDifferentiationSchemes" : {
        "type" : "object",
        "properties" : {
          "forDefault" : {
            "$ref" : "#/components/schemas/OneOf_TimeDifferentiationSchemesForDefault"
          }
        },
        "additionalProperties" : false
      },
      "EulerTimeDifferentiationScheme" : {
        "title" : "Euler",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: EulerTimeDifferentiationScheme",
            "default" : "EULER"
          }
        },
        "additionalProperties" : false
      },
      "LocalEulerTimeDifferentiationScheme" : {
        "title" : "Local euler",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: LocalEulerTimeDifferentiationScheme",
            "default" : "LOCAL_EULER"
          }
        },
        "additionalProperties" : false
      },
      "BackwardTimeDifferentiationScheme" : {
        "title" : "Backward time differentiation",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: BackwardTimeDifferentiationScheme",
            "default" : "BACKWARD"
          }
        },
        "additionalProperties" : false
      },
      "SteadystateTimeDifferentiationScheme" : {
        "title" : "Steady-state",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SteadystateTimeDifferentiationScheme",
            "default" : "STEADYSTATE"
          }
        },
        "additionalProperties" : false
      },
      "GradientSchemes" : {
        "type" : "object",
        "properties" : {
          "forDefault" : {
            "$ref" : "#/components/schemas/OneOf_GradientSchemesForDefault"
          },
          "grad_pressure" : {
            "$ref" : "#/components/schemas/OneOf_GradientSchemesGrad_pressure"
          },
          "grad_velocity" : {
            "$ref" : "#/components/schemas/OneOf_GradientSchemesGrad_velocity"
          },
          "grad_pressureRgh" : {
            "$ref" : "#/components/schemas/OneOf_GradientSchemesGrad_pressureRgh"
          },
          "grad_density" : {
            "$ref" : "#/components/schemas/OneOf_GradientSchemesGrad_density"
          },
          "grad_enthalpy" : {
            "$ref" : "#/components/schemas/OneOf_GradientSchemesGrad_enthalpy"
          },
          "grad_internalEnergy" : {
            "$ref" : "#/components/schemas/OneOf_GradientSchemesGrad_internalEnergy"
          },
          "grad_turbulentKineticEnergy" : {
            "$ref" : "#/components/schemas/OneOf_GradientSchemesGrad_turbulentKineticEnergy"
          },
          "grad_epsilonDissipationRate" : {
            "$ref" : "#/components/schemas/OneOf_GradientSchemesGrad_epsilonDissipationRate"
          },
          "grad_omegaDissipationRate" : {
            "$ref" : "#/components/schemas/OneOf_GradientSchemesGrad_omegaDissipationRate"
          },
          "grad_nuTilda" : {
            "$ref" : "#/components/schemas/OneOf_GradientSchemesGrad_nuTilda"
          },
          "grad_temperature" : {
            "$ref" : "#/components/schemas/OneOf_GradientSchemesGrad_temperature"
          },
          "grad_rhok" : {
            "$ref" : "#/components/schemas/OneOf_GradientSchemesGrad_rhok"
          }
        },
        "additionalProperties" : false
      },
      "GaussLinearGradientScheme" : {
        "title" : "Gauss linear",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GaussLinearGradientScheme",
            "default" : "GAUSS_LINEAR"
          }
        },
        "additionalProperties" : false
      },
      "CelllimitedGaussLinearGradientScheme" : {
        "title" : "Celllimited Gauss linear",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CelllimitedGaussLinearGradientScheme",
            "default" : "CELLLIMITED_GAUSS_LINEAR"
          },
          "limiterCoefficient" : {
            "title" : "Limiter coefficient",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "This property defines a limiter coefficient for the scheme. 1 ensures boundedness while 0 applies no limiting.",
            "default" : 1
          }
        },
        "additionalProperties" : false
      },
      "CelllimitedLeastSquaresGradientScheme" : {
        "title" : "Celllimited leastSquares",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CelllimitedLeastSquaresGradientScheme",
            "default" : "CELLLIMITED_LEASTSQUARES"
          },
          "limiterCoefficient" : {
            "title" : "Limiter coefficient",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "This property defines a limiter coefficient for the scheme. 1 ensures boundedness while 0 applies no limiting.",
            "default" : 1
          }
        },
        "additionalProperties" : false
      },
      "FourthGradientScheme" : {
        "title" : "Fourth gradient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FourthGradientScheme",
            "default" : "FOURTH"
          }
        },
        "additionalProperties" : false
      },
      "LeastsquaresGradientScheme" : {
        "title" : "Least squares",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: LeastsquaresGradientScheme",
            "default" : "LEASTSQUARES"
          }
        },
        "additionalProperties" : false
      },
      "DivergenceSchemes" : {
        "type" : "object",
        "properties" : {
          "forDefault" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesForDefault"
          },
          "div_Phi_velocity" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_Phi_velocity"
          },
          "div_Phi_kineticEnergy" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_Phi_kineticEnergy"
          },
          "div_Phi_enthalpy" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_Phi_enthalpy"
          },
          "div_Phi_internalEnergy" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_Phi_internalEnergy"
          },
          "div_Phiv_pressure" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_Phiv_pressure"
          },
          "div_Phi_turbulentKineticEnergy" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_Phi_turbulentKineticEnergy"
          },
          "div_NuEff_dev_T_grad_velocity" : {
            "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
          },
          "div_MuEff_dev2_T_grad_velocity" : {
            "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
          },
          "div_Phi_omegaDissipationRate" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_Phi_omegaDissipationRate"
          },
          "div_Phi_epsilonDissipationRate" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_Phi_epsilonDissipationRate"
          },
          "div_R" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_R"
          },
          "div_Phi_R" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_Phi_R"
          },
          "div_Phi_nuTilda" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_Phi_nuTilda"
          },
          "div_Phi_temperature" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_Phi_temperature"
          },
          "div_Phi_passiveScalar" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_Phi_passiveScalar"
          },
          "div_tauMC" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_tauMC"
          },
          "div_phid_pressure" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_phid_pressure"
          },
          "div_velocity" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_velocity"
          },
          "div_phi_Ekp" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_phi_Ekp"
          },
          "div_phirb_alpha" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_phirb_alpha"
          },
          "div_muEff_dev_T_grad_velocity" : {
            "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
          },
          "div_phi_alpha" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_phi_alpha"
          },
          "div_rhoPhi_velocity" : {
            "$ref" : "#/components/schemas/OneOf_DivergenceSchemesDiv_rhoPhi_velocity"
          }
        },
        "additionalProperties" : false
      },
      "GaussLinearDivergenceScheme" : {
        "title" : "Gauss linear",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GaussLinearDivergenceScheme",
            "default" : "GAUSS_LINEAR"
          }
        },
        "additionalProperties" : false
      },
      "GaussLinearUpwindVUnlimitedDivergenceScheme" : {
        "title" : "Gauss linear upwind v unlimited",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GaussLinearUpwindVUnlimitedDivergenceScheme",
            "default" : "GAUSS_LINEARUPWINDV_UNLIMITED"
          },
          "limiterCoefficient" : {
            "title" : "Limiter coefficient",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "This property defines a limiter coefficient for the scheme. 1 ensures boundedness while 0 applies no limiting.",
            "default" : 1
          }
        },
        "additionalProperties" : false
      },
      "GaussLinearUpwindUnlimitedDivergenceScheme" : {
        "title" : "Gauss linear upwind unlimited",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GaussLinearUpwindUnlimitedDivergenceScheme",
            "default" : "GAUSS_LINEARUPWIND_UNLIMITED"
          }
        },
        "additionalProperties" : false
      },
      "GaussLinearUpwindLimitedGradDivergenceScheme" : {
        "title" : "Gauss linear upwind limited grad",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GaussLinearUpwindLimitedGradDivergenceScheme",
            "default" : "GAUSS_LINEARUPWIND_LIMITEDGRAD"
          }
        },
        "additionalProperties" : false
      },
      "GaussLimitedLinear1DivergenceScheme" : {
        "title" : "Gauss limited linear 1",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GaussLimitedLinear1DivergenceScheme",
            "default" : "GAUSS_LIMITEDLINEAR_1"
          }
        },
        "additionalProperties" : false
      },
      "GaussLimitedLinearV1DivergenceScheme" : {
        "title" : "Gauss limited linear",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GaussLimitedLinearV1DivergenceScheme",
            "default" : "GAUSS_LIMITEDLINEARV_1"
          }
        },
        "additionalProperties" : false
      },
      "BoundedGaussUpwindDivergenceScheme" : {
        "title" : "Bounded Gauss upwind",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: BoundedGaussUpwindDivergenceScheme",
            "default" : "BOUNDED_GAUSS_UPWIND"
          }
        },
        "additionalProperties" : false
      },
      "GaussUpwindDivergenceScheme" : {
        "title" : "Gauss upwind",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GaussUpwindDivergenceScheme",
            "default" : "GAUSS_UPWIND"
          }
        },
        "additionalProperties" : false
      },
      "GaussVanleerDivergenceScheme" : {
        "title" : "Gauss vanLeer",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GaussVanleerDivergenceScheme",
            "default" : "GAUSS_VANLEER"
          }
        },
        "additionalProperties" : false
      },
      "GaussLinearUpwindVGradUDivergenceScheme" : {
        "title" : "Gauss linear upwind v U ",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GaussLinearUpwindVGradUDivergenceScheme",
            "default" : "GAUSS_LINEARUPWINDV_GRAD_U_"
          }
        },
        "additionalProperties" : false
      },
      "GaussInterfaceCompressionDivergenceScheme" : {
        "title" : "Gauss interface compression",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GaussInterfaceCompressionDivergenceScheme",
            "default" : "GAUSS_INTERFACECOMPRESSION"
          }
        },
        "additionalProperties" : false
      },
      "LaplacianSchemes" : {
        "type" : "object",
        "properties" : {
          "forDefault" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesForDefault"
          },
          "laplacian_NuEff_velocity" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_NuEff_velocity"
          },
          "laplacian_1A_U_pressure" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_1A_U_pressure"
          },
          "laplacian_Nu_velocity" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_Nu_velocity"
          },
          "laplacian_DREff_R" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_DREff_R"
          },
          "laplacian_DnuTildaEff_nuTilda" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_DnuTildaEff_nuTilda"
          },
          "laplacian_DkEff_turbulentKineticEnergy" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_DkEff_turbulentKineticEnergy"
          },
          "laplacian_alphaEff_enthalpy" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_alphaEff_enthalpy"
          },
          "laplacian_alpha_enthalpy" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_alpha_enthalpy"
          },
          "laplacian_muEff_velocity" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_muEff_velocity"
          },
          "laplacian_alphaEff_internalEnergy" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_alphaEff_internalEnergy"
          },
          "laplacian_rhorAUf_pressureRgh" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_rhorAUf_pressureRgh"
          },
          "laplacian_DepsilonEff_epsilonDissipationRate" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_DepsilonEff_epsilonDissipationRate"
          },
          "laplacian_DomegaEff_omegaDissipationRate" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_DomegaEff_omegaDissipationRate"
          },
          "laplacian_rAUf_pressure" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_rAUf_pressure"
          },
          "laplacian_DT_passiveScalar" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_DT_passiveScalar"
          },
          "laplacian_Dp_pressure" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_Dp_pressure"
          },
          "laplacian_rhorAUf_pressure" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_rhorAUf_pressure"
          },
          "laplacian_rho_1_A_U_pressure" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_rho_1_A_U_pressure"
          },
          "laplacian_mut_velocity" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_mut_velocity"
          },
          "laplacian_alphaEff_temperature" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_alphaEff_temperature"
          },
          "laplacian_rAUf_pressureRgh" : {
            "$ref" : "#/components/schemas/OneOf_LaplacianSchemesLaplacian_rAUf_pressureRgh"
          }
        },
        "additionalProperties" : false
      },
      "GaussLinearCorrectedLaplacianScheme" : {
        "title" : "Gauss linear corrected",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GaussLinearCorrectedLaplacianScheme",
            "default" : "GAUSS_LINEAR_CORRECTED"
          }
        },
        "additionalProperties" : false
      },
      "GaussLinearLimitedCorrectedLaplacianScheme" : {
        "title" : "Gauss linear limited corrected",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GaussLinearLimitedCorrectedLaplacianScheme",
            "default" : "GAUSS_LINEAR_LIMITED_CORRECTED"
          },
          "limiterCoefficient" : {
            "title" : "Limiter coefficient",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "This property defines a limiter coefficient for the scheme. 1 ensures boundedness while 0 applies no limiting.",
            "default" : 0.5,
            "x-conditionalDefaults" : [ {
              "when" : [ "type == CONJUGATE_HEAT_TRANSFER" ],
              "default" : 0.33
            } ]
          }
        },
        "additionalProperties" : false
      },
      "GaussLinearUncorrectedLaplacianScheme" : {
        "title" : "Gauss linear uncorrected",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GaussLinearUncorrectedLaplacianScheme",
            "default" : "GAUSS_LINEAR_UNCORRECTED"
          }
        },
        "additionalProperties" : false
      },
      "InterpolationSchemes" : {
        "type" : "object",
        "properties" : {
          "forDefault" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesForDefault"
          },
          "interpolate_HbyA" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesInterpolate_HbyA"
          },
          "interpolate_velocity" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesInterpolate_velocity"
          },
          "interpolate_kappa" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesInterpolate_kappa"
          },
          "interpolate_rho" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesInterpolate_rho"
          },
          "interpolate_thermo_rho_Cp" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesInterpolate_thermo_rho_Cp"
          },
          "interpolate_map_Kappa" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesInterpolate_map_Kappa"
          },
          "interpolate_rho_Hbya" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesInterpolate_rho_Hbya"
          },
          "interpolate_rho_0_velocity0" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesInterpolate_rho_0_velocity0"
          },
          "interpolate_grad_enthalpy" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesInterpolate_grad_enthalpy"
          },
          "interpolate_rho_rAU" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesInterpolate_rho_rAU"
          },
          "interpolate_rAU" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesInterpolate_rAU"
          },
          "interpolate_velocity0" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesInterpolate_velocity0"
          },
          "reconstruct_velocity" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesReconstruct_velocity"
          },
          "reconstruct_temperature" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesReconstruct_temperature"
          },
          "reconstruct_rho" : {
            "$ref" : "#/components/schemas/OneOf_InterpolationSchemesReconstruct_rho"
          }
        },
        "additionalProperties" : false
      },
      "CubicInterpolationScheme" : {
        "title" : "Cubic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CubicInterpolationScheme",
            "default" : "CUBIC"
          }
        },
        "additionalProperties" : false
      },
      "LinearInterpolationScheme" : {
        "title" : "Linear",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: LinearInterpolationScheme",
            "default" : "LINEAR"
          }
        },
        "additionalProperties" : false
      },
      "SurfaceNormalGradientSchemes" : {
        "type" : "object",
        "properties" : {
          "forDefault" : {
            "$ref" : "#/components/schemas/OneOf_SurfaceNormalGradientSchemesForDefault"
          },
          "surfaceNormalGradient_rho" : {
            "$ref" : "#/components/schemas/OneOf_SurfaceNormalGradientSchemesSurfaceNormalGradient_rho"
          },
          "surfaceNormalGradient_pressureRgh" : {
            "$ref" : "#/components/schemas/OneOf_SurfaceNormalGradientSchemesSurfaceNormalGradient_pressureRgh"
          },
          "surfaceNormalGradient_rhok" : {
            "$ref" : "#/components/schemas/OneOf_SurfaceNormalGradientSchemesSurfaceNormalGradient_rhok"
          }
        },
        "additionalProperties" : false
      },
      "CorrectedSurfaceNormalGradientScheme" : {
        "title" : "Corrected",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CorrectedSurfaceNormalGradientScheme",
            "default" : "CORRECTED"
          }
        },
        "additionalProperties" : false
      },
      "UncorrectedSurfaceNormalGradientScheme" : {
        "title" : "Uncorrected",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: UncorrectedSurfaceNormalGradientScheme",
            "default" : "UNCORRECTED"
          }
        },
        "additionalProperties" : false
      },
      "LimitedSurfaceNormalGradientScheme" : {
        "title" : "Limited",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: LimitedSurfaceNormalGradientScheme",
            "default" : "LIMITED"
          },
          "limiterCoefficient" : {
            "title" : "Limiter coefficient",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "This property defines a limiter coefficient for the scheme:<ul><li><strong>0</strong>: no correction, equivalent to the uncorrected scheme</li><li><strong>1</strong>: full non-orthogonal correction applied</li><li><strong>0.5</strong>: non-orthogonal contribution does not exceed the orthogonal part</li></ul>",
            "default" : 0.5
          }
        },
        "additionalProperties" : false
      },
      "Stabilization" : {
        "title" : "Stabilization",
        "type" : "object",
        "properties" : {
          "fieldLimits" : {
            "$ref" : "#/components/schemas/FieldLimits"
          }
        },
        "additionalProperties" : false
      },
      "FieldLimits" : {
        "title" : "Field limits",
        "type" : "object",
        "properties" : {
          "lowerDensityBound" : {
            "$ref" : "#/components/schemas/Dimensional_Density"
          },
          "upperDensityBound" : {
            "$ref" : "#/components/schemas/Dimensional_Density"
          },
          "lowerPressureBound" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "upperPressureBound" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "lowerTemperatureBound" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          },
          "upperTemperatureBound" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          }
        },
        "additionalProperties" : false
      },
      "FluidSimulationControl" : {
        "type" : "object",
        "properties" : {
          "endTime" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "adjointEndTime" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "numberOfIterations" : {
            "title" : "Number of iterations",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<b>Steady-state simulation:</b> This represents the number of total iterations at which the termination of simulation happens. No more iterations will be executed beyond that. <a href='https://www.simscale.com/docs/simulation-setup/simulation-control/' target='_blank'>Learn more</a>.<br> <b>Transient simulation:</b> This represents the number of iterations per time step. The recommended value is 25. The larger the <i>Delta t</i> value is, the larger the <i>Number of iterations</i> has to be, in order to obtain more stable, converged solution. The simulation will terminate only when the <i>End time</i> is reached.</br>",
            "x-showWhen" : [ "type == SIMERICS_ANALYSIS" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "type == SIMERICS_ANALYSIS && timeDependency.type == TRANSIENT" ],
              "default" : 25
            }, {
              "when" : [ "type == SIMERICS_ANALYSIS && timeDependency.type == STATIONARY" ],
              "default" : 500
            } ]
          },
          "deltaT" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "adjustableTimestep" : {
            "$ref" : "#/components/schemas/OneOf_FluidSimulationControlAdjustableTimestep"
          },
          "writeControl" : {
            "$ref" : "#/components/schemas/OneOf_FluidSimulationControlWriteControl"
          },
          "numProcessors" : {
            "title" : "Number of processors",
            "maximum" : 96,
            "exclusiveMaximum" : false,
            "minimum" : -1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Selecting more processor cores will speed up the simulation process. Choosing a smaller computation instance will save core hours. <a href='https://www.simscale.com/docs/simulation-setup/simulation-control-fluid/#number-of-processors' target='_blank'>Learn more</a>.</p>",
            "format" : "int64",
            "default" : -1,
            "enum" : [ -1, 1, 2, 4, 8, 16, 32, 64, 96 ],
            "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ]
          },
          "maxRunTime" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "potentialFoamInitialization" : {
            "title" : "Potential flow initialization",
            "type" : "boolean",
            "description" : "This setting activates the solution of a potential flow field. The potential flow is used as initial condition for the actual simulation. This can accelerate convergence and improve stability during the first time steps. If you experience stability problems, this setting may bring some improvement.",
            "default" : false,
            "x-showWhen" : [ "type in [INCOMPRESSIBLE,MULTIPHASE]", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [NONE,KEPSILON,KOMEGASST]" ]
          },
          "decomposeAlgorithm" : {
            "$ref" : "#/components/schemas/OneOf_FluidSimulationControlDecomposeAlgorithm"
          },
          "relativeConvergenceCriteria" : {
            "title" : "Convergence criteria",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<b>Steady-state simulation:</b> This represents the relative error residuals that once attained by the solver the simulation is considered to be converged and will stop. The recommended value is 0.001.<br> <b>Transient simulation:</b> This represents the relative error residuals that once attained by the solver the simulation will move to the next time-step regardless of the <i>Number of iterations</i>. The recommended value is 0.1.</br> <br> <b>Please note: </b>Relative residual is defined as the residual in the current iteration divided by the initial residual.</br> <br> <b>Please note: </b>Lower convergence criterion is demanded for <b>Steady-state simulations</b> because the initial guess is typically farther from the correct solution.</br>",
            "x-showWhen" : [ "type == SIMERICS_ANALYSIS" ],
            "x-conditionalDefaults" : [ {
              "when" : [ "type == SIMERICS_ANALYSIS && timeDependency.type == TRANSIENT" ],
              "default" : 0.1
            }, {
              "when" : [ "type == SIMERICS_ANALYSIS && timeDependency.type == STATIONARY" ],
              "default" : 0.001
            } ]
          }
        },
        "additionalProperties" : false
      },
      "InactiveAdjustableTimestep" : {
        "title" : "False",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This option activates an adjustable time step. The time step is being modified according to the Courant number.\n\nSchema name: InactiveAdjustableTimestep",
            "default" : "INACTIVE_TIMESTEP"
          }
        },
        "additionalProperties" : false,
        "description" : "This option activates an adjustable time step. The time step is being modified according to the Courant number."
      },
      "ActiveAdjustableTimestep" : {
        "title" : "True",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This option activates an adjustable time step. The time step is being modified according to the Courant number.\n\nSchema name: ActiveAdjustableTimestep",
            "default" : "ACTIVE_TIMESTEP"
          },
          "maximalCourantNumber" : {
            "title" : "Maximal Courant number",
            "type" : "number",
            "description" : "This option defines a maximum Courant number. When using explicit time integration schemes, it may not be greater than 1. Values of 0.5-0.7 are recommended for many cases.",
            "default" : 0.5
          },
          "maximalStep" : {
            "title" : "Maximal step",
            "minimum" : 0,
            "exclusiveMinimum" : true,
            "type" : "number",
            "description" : "This option defines a maximum time step length which may not be exceeded when the time step is adapted during runtime.",
            "default" : 1
          },
          "maxAlphaCo" : {
            "title" : "Max alpha co",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "Define a maximum Courant number based on the interface velocity.",
            "default" : 0.5,
            "x-showWhen" : [ "type == MULTIPHASE" ]
          }
        },
        "additionalProperties" : false,
        "description" : "This option activates an adjustable time step. The time step is being modified according to the Courant number."
      },
      "TimeStepWriteControl" : {
        "title" : "Time step",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This option controls how the simulation results are written and how frequently.\n\nSchema name: TimeStepWriteControl",
            "default" : "TIME_STEP"
          },
          "writeInterval" : {
            "title" : "Write interval",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "Specify an interval value that defines the number of time steps between two writes of the result.",
            "x-conditionalDefaults" : [ {
              "when" : [ "type == INCOMPRESSIBLE && timeDependency.type == TRANSIENT && 2# == simulationControl", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && 2# == simulationControl", "type == CONJUGATE_HEAT_TRANSFER && timeDependency.type == TRANSIENT && 2# == simulationControl", "type == CONVECTIVE_HEAT_TRANSFER && timeDependency.type == TRANSIENT && 2# == simulationControl", "type == MULTIPHASE && 2# == simulationControl", "type == SIMERICS_ANALYSIS && 2# == simulationControl" ],
              "default" : 50
            }, {
              "when" : [ "type == INCOMPRESSIBLE && timeDependency.type == STATIONARY && 2# == simulationControl", "type == COMPRESSIBLE && timeDependency.type == STATIONARY && 2# == simulationControl", "type == CONJUGATE_HEAT_TRANSFER && timeDependency.type == STATIONARY && 2# == simulationControl", "type == CONVECTIVE_HEAT_TRANSFER && timeDependency.type == STATIONARY && 2# == simulationControl", "type == MULTIPHASE && 2# == simulationControl", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && 2# == simulationControl", "type == EMBEDDED_BOUNDARY && 2# == simulationControl" ],
              "default" : 1000
            }, {
              "when" : [ "2# != simulationControl", "2/type in [FORCES_AND_MOMENTS,FORCE_AND_MOMENT_COEFFICIENTS,AREA_AVERAGE,AREA_INTEGRAL,PROBE_POINTS]" ],
              "default" : 1
            } ]
          }
        },
        "additionalProperties" : false,
        "description" : "This option controls how the simulation results are written and how frequently."
      },
      "ClockTimeWriteControl" : {
        "title" : "Clock time",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This option controls how the simulation results are written and how frequently.\n\nSchema name: ClockTimeWriteControl",
            "default" : "CLOCK_TIME"
          },
          "writeInterval" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          }
        },
        "additionalProperties" : false,
        "description" : "This option controls how the simulation results are written and how frequently."
      },
      "RunTimeWriteControl" : {
        "title" : "Runtime",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This option controls how the simulation results are written and how frequently.\n\nSchema name: RunTimeWriteControl",
            "default" : "RUNTIME"
          },
          "writeInterval" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          }
        },
        "additionalProperties" : false,
        "description" : "This option controls how the simulation results are written and how frequently."
      },
      "CpuTimeWriteControl" : {
        "title" : "CPU time",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This option controls how the simulation results are written and how frequently.\n\nSchema name: CpuTimeWriteControl",
            "default" : "CPU_TIME"
          },
          "writeInterval" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          }
        },
        "additionalProperties" : false,
        "description" : "This option controls how the simulation results are written and how frequently."
      },
      "AdjustableRuntimeWriteControl" : {
        "title" : "Adjustable runtime",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This option controls how the simulation results are written and how frequently.\n\nSchema name: AdjustableRuntimeWriteControl",
            "default" : "ADJUSTABLE_RUNTIME"
          },
          "writeInterval" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          }
        },
        "additionalProperties" : false,
        "description" : "This option controls how the simulation results are written and how frequently."
      },
      "NumberIterationsWriteControl" : {
        "title" : "Iterations",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This option controls how the simulation results are written and how frequently.\n\nSchema name: NumberIterationsWriteControl",
            "default" : "NUMBER_OF_ITERATIONS_STEADY_STATE"
          },
          "writeInterval" : {
            "title" : "Write interval",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "Specify an interval value that defines the number of iterations between two writes of the result.",
            "default" : 100
          }
        },
        "additionalProperties" : false,
        "description" : "This option controls how the simulation results are written and how frequently."
      },
      "ScotchDecomposeAlgorithm" : {
        "title" : "Scotch",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ScotchDecomposeAlgorithm",
            "default" : "SCOTCH"
          }
        },
        "additionalProperties" : false
      },
      "HierarchicalDecomposeAlgorithm" : {
        "title" : "Hierarchical",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: HierarchicalDecomposeAlgorithm",
            "default" : "HIERARCHICAL"
          },
          "decompositionOrder" : {
            "title" : "Decomposition order",
            "type" : "string",
            "description" : "<p>Choose the order of domain decomposition .</p>",
            "default" : "XYZ",
            "enum" : [ "XYZ", "XZY", "YXZ", "YZX", "ZXY", "ZYX" ]
          },
          "delta" : {
            "title" : "Delta",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "Delta is cell skew factor. It represents the cell skewness allowed at the decomposed domain boundaries and is generally kept below 10^{-2}. <a href='https://www.simscale.com/docs/simulation-setup/simulation-control/' target='_blank'>Learn more</a>.",
            "default" : 0.01
          },
          "numSubdomainX" : {
            "title" : "Number of subdomain x",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the number of subdomains the mesh is split into in the specific direction.</p>",
            "default" : 1
          },
          "numSubdomainY" : {
            "title" : "Number of subdomain y",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the number of subdomains the mesh is split into in the specific direction.</p>",
            "default" : 1
          },
          "numSubdomainZ" : {
            "title" : "Number of subdomain z",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the number of subdomains the mesh is split into in the specific direction.</p>",
            "default" : 1
          }
        },
        "additionalProperties" : false
      },
      "SimpleDecomposeAlgorithm" : {
        "title" : "Simple",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SimpleDecomposeAlgorithm",
            "default" : "SIMPLE"
          },
          "delta" : {
            "title" : "Delta",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "Delta is cell skew factor. It represents the cell skewness allowed at the decomposed domain boundaries and is generally kept below 10^{-2}. <a href='https://www.simscale.com/docs/simulation-setup/simulation-control/' target='_blank'>Learn more</a>.",
            "default" : 0.01
          },
          "numSubdomainX" : {
            "title" : "Number of subdomain x",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the number of subdomains the mesh is split into in the specific direction.</p>",
            "default" : 1
          },
          "numSubdomainY" : {
            "title" : "Number of subdomain y",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the number of subdomains the mesh is split into in the specific direction.</p>",
            "default" : 1
          },
          "numSubdomainZ" : {
            "title" : "Number of subdomain z",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "<p>Define the number of subdomains the mesh is split into in the specific direction.</p>",
            "default" : 1
          }
        },
        "additionalProperties" : false
      },
      "FluidResultControls" : {
        "type" : "object",
        "properties" : {
          "forcesMoments" : {
            "title" : "Forces and moments",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_FluidResultControlsForcesMoments"
            },
            "x-showWhen" : [ "type in [SIMERICS_ANALYSIS,INCOMPRESSIBLE,INCOMPRESSIBLE_PACEFISH,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE,WIND_COMFORT]" ]
          },
          "surfaceData" : {
            "title" : "Surface data",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_FluidResultControlsSurfaceData"
            },
            "x-showWhen" : [ "type in [SIMERICS_ANALYSIS,COMPRESSIBLE,INCOMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER]", "type in [CONJUGATE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,MULTIPHASE,EMBEDDED_BOUNDARY]" ]
          },
          "scalarTransport" : {
            "title" : "Scalar transport",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ScalarTransportResultControl"
            },
            "x-showWhen" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies == 0" ]
          },
          "probePoints" : {
            "title" : "Probe points",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ProbePointsResultControl"
            },
            "x-showWhen" : [ "type != SIMERICS_ANALYSIS" ]
          },
          "fieldCalculations" : {
            "title" : "Field calculations",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_FluidResultControlsFieldCalculations"
            },
            "x-showWhen" : [ "type in [INCOMPRESSIBLE,INCOMPRESSIBLE_PACEFISH,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER]", "type in [CONJUGATE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER]" ]
          },
          "transientResultControl" : {
            "$ref" : "#/components/schemas/TransientResultControl"
          },
          "statisticalAveragingResultControl" : {
            "$ref" : "#/components/schemas/StatisticalAveragingResultControlV2"
          },
          "snapshotResultControl" : {
            "$ref" : "#/components/schemas/SnapshotResultControl"
          }
        },
        "additionalProperties" : false
      },
      "ForcesMomentsResultControl" : {
        "title" : "Forces and moments",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ForcesMomentsResultControl",
            "default" : "FORCES_AND_MOMENTS"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "centerOfRotation" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "writeControl" : {
            "$ref" : "#/components/schemas/OneOf_ForcesMomentsResultControlWriteControl"
          },
          "fractionFromEnd" : {
            "title" : "Fraction from end",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "It defines the point in simulation where the result output data extraction starts. For instance, <i>Fraction from end</i> of 1 (100%) extracts all data from the beginning of the simulation while default 0.2 extracts 20% data from the end of the simulation.",
            "default" : 0.2,
            "x-showWhen" : [ "type in [INCOMPRESSIBLE_PACEFISH,WIND_COMFORT]" ]
          },
          "exportStatistics" : {
            "title" : "Export statistical data",
            "type" : "boolean",
            "description" : "<p>When this switch is activated, statistical data for the selected forces and moments will be exported:</p><ul><li>Minimum (<strong>MIN</strong>)</li><li>Maximum (<strong>MAX</strong>)</li><li>Absolute minimum (<strong>MIN (Abs)</strong>)</li><li>Absolute maximum (<strong>MAX (Abs)</strong>)</li><li>Average (<strong>AVG</strong>)</li><li>Standard deviation (<strong>STDDEV</strong>)</li><li>Root mean square (<strong>RMS (fluctuation)</strong>)</li></ul>",
            "default" : true,
            "x-showWhen" : [ "type in [INCOMPRESSIBLE_PACEFISH,WIND_COMFORT]" ]
          },
          "groupAssignments" : {
            "title" : "Group assignments",
            "type" : "boolean",
            "description" : "When this switch is activated, forces and moments will be calculated cumulatively on all assignments. When deactivated, they will be calculated individually for each assignment.",
            "default" : true,
            "x-showWhen" : [ "type in [INCOMPRESSIBLE_PACEFISH,WIND_COMFORT]" ]
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "SynchronizeWithFieldOutputWriteControl" : {
        "title" : "Synchronize with field output",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This option controls how the simulation results are written and how frequently.\n\nSchema name: SynchronizeWithFieldOutputWriteControl",
            "default" : "OUTPUT_TIME"
          },
          "writeInterval" : {
            "title" : "Write interval",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 1
          }
        },
        "additionalProperties" : false,
        "description" : "This option controls how the simulation results are written and how frequently."
      },
      "HighResolution" : {
        "title" : "High resolution",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Output will be written every 2 time steps.\n\nSchema name: HighResolution",
            "default" : "HIGH_RESOLUTION"
          }
        },
        "additionalProperties" : false,
        "description" : "Output will be written every 2 time steps."
      },
      "ModerateResolution" : {
        "title" : "Moderate resolution",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Output will be written every 4 time steps.\n\nSchema name: ModerateResolution",
            "default" : "MODERATE_RESOLUTION"
          }
        },
        "additionalProperties" : false,
        "description" : "Output will be written every 4 time steps."
      },
      "CoarseResolution" : {
        "title" : "Coarse resolution",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Output will be written every 8 time steps.\n\nSchema name: CoarseResolution",
            "default" : "COARSE_RESOLUTION"
          }
        },
        "additionalProperties" : false,
        "description" : "Output will be written every 8 time steps."
      },
      "CustomResolution" : {
        "title" : "Custom resolution",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "This option controls how the simulation results are written and how frequently.\n\nSchema name: CustomResolution",
            "default" : "CUSTOM_RESOLUTION"
          },
          "writeInterval" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          }
        },
        "additionalProperties" : false,
        "description" : "This option controls how the simulation results are written and how frequently."
      },
      "ForceMomentCoefficientsResultControl" : {
        "title" : "Force and moment coefficients",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ForceMomentCoefficientsResultControl",
            "default" : "FORCE_AND_MOMENT_COEFFICIENTS"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "centerOfRotation" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "liftDirection" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "dragDirection" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "pitchAxis" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "freestreamVelocityMagnitude" : {
            "$ref" : "#/components/schemas/Dimensional_Speed"
          },
          "referenceLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "referenceAreaValue" : {
            "$ref" : "#/components/schemas/Dimensional_Area"
          },
          "writeControl" : {
            "$ref" : "#/components/schemas/OneOf_ForceMomentCoefficientsResultControlWriteControl"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "AreaAverageResultControl" : {
        "title" : "Area average",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AreaAverageResultControl",
            "default" : "AREA_AVERAGE"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "writeControl" : {
            "$ref" : "#/components/schemas/OneOf_AreaAverageResultControlWriteControl"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "AreaIntegralResultControl" : {
        "title" : "Area integral",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AreaIntegralResultControl",
            "default" : "AREA_INTEGRAL"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "writeControl" : {
            "$ref" : "#/components/schemas/OneOf_AreaIntegralResultControlWriteControl"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "PressureDifferenceResultControl" : {
        "title" : "Pressure difference",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PressureDifferenceResultControl",
            "default" : "PRESSURE_DIFFERENCE"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "inletFaceTopologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "outletFaceTopologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "ScalarTransportResultControl" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "diffusionCoefficient" : {
            "title" : "Diffusion coefficient",
            "type" : "number",
            "default" : 0
          },
          "volumeMode" : {
            "title" : "Volume mode",
            "type" : "string",
            "default" : "SPECIFIC",
            "enum" : [ "SPECIFIC", "ABSOLUTE" ]
          },
          "su" : {
            "title" : "Explicit source term",
            "type" : "number",
            "default" : 1
          },
          "sp" : {
            "title" : "Implicit sink term",
            "type" : "number",
            "default" : 0
          },
          "writeControl" : {
            "$ref" : "#/components/schemas/OneOf_ScalarTransportResultControlWriteControl"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "POINT" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "ProbePointsResultControl" : {
        "title" : "Probe points",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ProbePointsResultControl",
            "default" : "PROBE_POINTS"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "writeControl" : {
            "$ref" : "#/components/schemas/OneOf_ProbePointsResultControlWriteControl"
          },
          "fractionFromEnd" : {
            "title" : "Fraction from end",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "It defines the point in simulation where the result output data extraction starts. For instance, <i>Fraction from end</i> of 1 (100%) extracts all data from the beginning of the simulation while default 0.2 extracts 20% data from the end of the simulation.",
            "default" : 0.2,
            "x-showWhen" : [ "type in [INCOMPRESSIBLE_PACEFISH,WIND_COMFORT]" ]
          },
          "exportStatistics" : {
            "title" : "Export statistical data",
            "type" : "boolean",
            "description" : "<p>When this switch is active, statistical data for the selected probe points will be exported:</p><ul><li>Minimum (<strong>MIN</strong>)</li><li>Maximum (<strong>MAX</strong>)</li><li>Absolute minimum (<strong>MIN (Abs)</strong>)</li><li>Absolute maximum (<strong>MAX (Abs)</strong>)</li><li>Average (<strong>AVG</strong>)</li><li>Standard deviation (<strong>STDDEV</strong>)</li><li>Root mean square (<strong>RMS (fluctuation)</strong>)</li></ul>",
            "default" : true,
            "x-showWhen" : [ "type in [INCOMPRESSIBLE_PACEFISH,WIND_COMFORT]" ]
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE,EMBEDDED_BOUNDARY]" ],
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "POINT" ]
            }
          },
          "probeLocations" : {
            "$ref" : "#/components/schemas/TableDefinedProbeLocations"
          }
        },
        "additionalProperties" : false
      },
      "TableDefinedProbeLocations" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TableDefinedProbeLocations",
            "default" : "TABULAR"
          },
          "tableId" : {
            "type" : "string",
            "description" : "The ID of the imported table.",
            "format" : "uuid"
          }
        },
        "additionalProperties" : false
      },
      "FieldCalculationsPressureResultControl" : {
        "title" : "Pressure fields",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FieldCalculationsPressureResultControl",
            "default" : "PRESSURE"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "pressureType" : {
            "$ref" : "#/components/schemas/OneOf_FieldCalculationsPressureResultControlPressureType"
          },
          "resultType" : {
            "$ref" : "#/components/schemas/OneOf_FieldCalculationsPressureResultControlResultType"
          }
        },
        "additionalProperties" : false
      },
      "TotalPressurePressureType" : {
        "title" : "Total pressure",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TotalPressurePressureType",
            "default" : "TOTAL_PRESSURE"
          },
          "pressureValue" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          }
        },
        "additionalProperties" : false
      },
      "StaticPressurePressureType" : {
        "title" : "Static pressure",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: StaticPressurePressureType",
            "default" : "STATIC_PRESSURE"
          }
        },
        "additionalProperties" : false
      },
      "PressureValueResultType" : {
        "title" : "Pressure value",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PressureValueResultType",
            "default" : "PRESSURE_VALUE"
          }
        },
        "additionalProperties" : false
      },
      "PressureCoefficientResultType" : {
        "title" : "Pressure coefficient",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PressureCoefficientResultType",
            "default" : "PRESSURE_COEFFICIENT"
          },
          "freeStreamPressure" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "freeStreamVelocity" : {
            "$ref" : "#/components/schemas/DimensionalVector_Speed"
          }
        },
        "additionalProperties" : false
      },
      "FieldCalculationsTurbulenceResultControl" : {
        "title" : "Turbulence",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FieldCalculationsTurbulenceResultControl",
            "default" : "TURBULENCE"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "resultType" : {
            "$ref" : "#/components/schemas/OneOf_FieldCalculationsTurbulenceResultControlResultType"
          }
        },
        "additionalProperties" : false
      },
      "YPlusRASResultType" : {
        "title" : "y<plus>",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: YPlusRASResultType",
            "default" : "DIMENSIONLESS_WALL_DISTANCE_YPLUS"
          }
        },
        "additionalProperties" : false
      },
      "ReynoldsStressResultType" : {
        "title" : "Reynolds stress tensor",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ReynoldsStressResultType",
            "default" : "REYNOLDS_STRESS_TENSOR"
          }
        },
        "additionalProperties" : false
      },
      "FieldCalculationsVelocityResultControl" : {
        "title" : "Vorticity",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FieldCalculationsVelocityResultControl",
            "default" : "VELOCITY"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "resultType" : {
            "$ref" : "#/components/schemas/VorticityResultType"
          }
        },
        "additionalProperties" : false
      },
      "VorticityResultType" : {
        "title" : "Vorticity",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: VorticityResultType",
            "default" : "VORTICITY"
          }
        },
        "additionalProperties" : false
      },
      "FieldCalculationsFrictionVelocityResultControl" : {
        "title" : "Friction Velocity",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FieldCalculationsFrictionVelocityResultControl",
            "default" : "FRICTION_VELOCITY_U_TAU"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "resultType" : {
            "$ref" : "#/components/schemas/FrictionVelocityResultType"
          }
        },
        "additionalProperties" : false
      },
      "FrictionVelocityResultType" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FrictionVelocityResultType",
            "default" : "FRICTION_VELOCITY_U_TAU"
          }
        },
        "additionalProperties" : false
      },
      "FieldCalculationsSurfaceNormalsResultControl" : {
        "title" : "Surface Normals",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FieldCalculationsSurfaceNormalsResultControl",
            "default" : "SURFACE_NORMALS"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "resultType" : {
            "$ref" : "#/components/schemas/SurfaceNormalsResultType"
          }
        },
        "additionalProperties" : false
      },
      "SurfaceNormalsResultType" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SurfaceNormalsResultType",
            "default" : "SURFACE_NORMALS"
          }
        },
        "additionalProperties" : false
      },
      "FieldCalculationsWallFluxesResultControl" : {
        "title" : "Wall shear stress",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FieldCalculationsWallFluxesResultControl",
            "default" : "WALL_FLUXES"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "resultType" : {
            "$ref" : "#/components/schemas/WallShearStressResultType"
          }
        },
        "additionalProperties" : false
      },
      "WallShearStressResultType" : {
        "title" : "Wall shear stress",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WallShearStressResultType",
            "default" : "WALL_SHEAR_STRESS"
          }
        },
        "additionalProperties" : false
      },
      "FieldCalculationsThermalComfortResultControl" : {
        "title" : "Thermal Comfort Parameters",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FieldCalculationsThermalComfortResultControl",
            "default" : "THERMAL_COMFORT"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "clothingCoefficientFactor" : {
            "title" : "Clothing Coefficient (clo)",
            "maximum" : 2,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 1
          },
          "metabolicRateFactor" : {
            "title" : "Metabolic Rate (met)",
            "maximum" : 4,
            "exclusiveMaximum" : false,
            "minimum" : 0.8,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 1
          },
          "relativeHumidityFactor" : {
            "title" : "Relative Air Humidity (%)",
            "maximum" : 100,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 50
          }
        },
        "additionalProperties" : false
      },
      "FieldCalculationsAdjointSensitivitiesResultControl" : {
        "title" : "Adjoint sensitivities",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FieldCalculationsAdjointSensitivitiesResultControl",
            "default" : "ADJOINT_SENSITIVITIES"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z()][-+0-9a-zA-Z_()\\h]{0,199}$",
            "type" : "string"
          },
          "computeSensitivitiesTo" : {
            "title" : "Compute sensitivities to",
            "type" : "string",
            "default" : "MINIMIZE_FORCE",
            "enum" : [ "MAXIMIZE_FORCE", "MINIMIZE_FORCE" ]
          },
          "optimizationForceDirection" : {
            "$ref" : "#/components/schemas/DecimalVector"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "TransientResultControl" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TransientResultControl",
            "default" : "TRANSIENT"
          },
          "writeControl" : {
            "$ref" : "#/components/schemas/OneOf_TransientResultControlWriteControl"
          },
          "fractionFromEnd" : {
            "title" : "Fraction from end",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "It defines the point in simulation where the result output data extraction starts. For instance, <i>Fraction from end</i> of 1 (100%) extracts all data from the beginning of the simulation while default 0.2 extracts 20% data from the end of the simulation.",
            "default" : 0.2
          },
          "exportFluid" : {
            "title" : "Export flow-domain fields",
            "type" : "boolean",
            "description" : "When this switch is activated, simulation data of the flow-field enclosed in the assignments will be exported",
            "default" : false
          },
          "exportSurface" : {
            "title" : "Export surface fields",
            "type" : "boolean",
            "description" : "When this switch is activated, simulation data on all surfaces enclosed in the assignments will be exported",
            "default" : false
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-showWhen" : [ "1/exportFluid == true" ],
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "LOCAL_CARTESIAN_BOX", "ROTATABLE_CARTESIAN_BOX", "LOCAL_HALF_SPACE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "StatisticalAveragingResultControlV2" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: StatisticalAveragingResultControlV2",
            "default" : "STATISTICAL_AVERAGING_V2"
          },
          "fractionFromEnd" : {
            "title" : "Fraction from end",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "It defines the point in simulation where the result output data extraction starts. For instance, <i>Fraction from end</i> of 1 (100%) extracts all data from the beginning of the simulation while default 0.2 extracts 20% data from the end of the simulation.",
            "default" : 0.2
          },
          "samplingInterval" : {
            "$ref" : "#/components/schemas/OneOf_StatisticalAveragingResultControlV2SamplingInterval"
          },
          "exportFluid" : {
            "title" : "Export flow-domain fields",
            "type" : "boolean",
            "description" : "When this switch is activated, simulation data of the flow-field enclosed in the assignments will be exported",
            "default" : false
          },
          "exportSurface" : {
            "title" : "Export surface fields",
            "type" : "boolean",
            "description" : "When this switch is activated, simulation data on all surfaces enclosed in the assignments will be exported",
            "default" : false
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-showWhen" : [ "1/exportFluid == true" ],
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "LOCAL_CARTESIAN_BOX", "ROTATABLE_CARTESIAN_BOX", "LOCAL_HALF_SPACE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "SnapshotResultControl" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SnapshotResultControl",
            "default" : "SNAPSHOT"
          },
          "exportFluid" : {
            "title" : "Export flow-domain fields",
            "type" : "boolean",
            "description" : "When this switch is activated, simulation data of the flow-field enclosed in the assignments will be exported",
            "default" : false
          },
          "exportSurface" : {
            "title" : "Export surface fields",
            "type" : "boolean",
            "description" : "When this switch is activated, simulation data on all surfaces enclosed in the assignments will be exported",
            "default" : false
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-showWhen" : [ "1/exportFluid == true" ],
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "LOCAL_CARTESIAN_BOX", "ROTATABLE_CARTESIAN_BOX", "LOCAL_HALF_SPACE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "IncompressiblePacefish" : {
        "title" : "Incompressible (LBM)",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: IncompressiblePacefish",
            "default" : "INCOMPRESSIBLE_PACEFISH"
          },
          "boundingBoxUuid" : {
            "type" : "string",
            "format" : "uuid"
          },
          "turbulenceModel" : {
            "title" : "Turbulence model",
            "type" : "string",
            "description" : "Choose between RANS, LES, or DES turbulence models. <a href='https://www.simscale.com/docs/incompressible-lbm-lattice-boltzmann-advanced/#turbulence-models-in-incompressible-lbm' target='_blank'>Learn more</a>.",
            "default" : "KOMEGASST_DDES",
            "enum" : [ "SMAGORINSKY", "SMAGORINSKY_DIRECT", "NONE", "KOMEGASST", "KOMEGASST_DDES", "KOMEGASST_IDDES" ]
          },
          "material" : {
            "$ref" : "#/components/schemas/IncompressibleMaterial"
          },
          "flowDomainBoundaries" : {
            "$ref" : "#/components/schemas/FlowDomainBoundaries"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/FluidSimulationControl"
          },
          "advancedModelling" : {
            "$ref" : "#/components/schemas/AdvancedModelling"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/FluidResultControls"
          },
          "meshSettingsNew" : {
            "$ref" : "#/components/schemas/OneOf_IncompressiblePacefishMeshSettingsNew"
          }
        },
        "additionalProperties" : false
      },
      "FlowDomainBoundaries" : {
        "type" : "object",
        "properties" : {
          "XMIN" : {
            "$ref" : "#/components/schemas/OneOf_FlowDomainBoundariesXMIN"
          },
          "XMAX" : {
            "$ref" : "#/components/schemas/OneOf_FlowDomainBoundariesXMAX"
          },
          "YMIN" : {
            "$ref" : "#/components/schemas/OneOf_FlowDomainBoundariesYMIN"
          },
          "YMAX" : {
            "$ref" : "#/components/schemas/OneOf_FlowDomainBoundariesYMAX"
          },
          "ZMIN" : {
            "$ref" : "#/components/schemas/OneOf_FlowDomainBoundariesZMIN"
          },
          "ZMAX" : {
            "$ref" : "#/components/schemas/OneOf_FlowDomainBoundariesZMAX"
          }
        },
        "additionalProperties" : false
      },
      "AtmosphericBoundaryLayerInletBC" : {
        "title" : "Atmospheric boundary layer inlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "The atmospheric boundary layer boundary condition implements the standard logarithmic profile for the stream-wise wind velocity component with corresponding profiles for turbulence kinetic energy and specific dissipation rate, where the ground roughness effects are taken into account.\n\nSchema name: AtmosphericBoundaryLayerInletBC",
            "default" : "ATMOSPHERIC_BOUNDARY_LAYER_INLET"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "referenceVelocity" : {
            "$ref" : "#/components/schemas/Dimensional_Speed"
          },
          "referenceHeight" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "groundRoughness" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "The atmospheric boundary layer boundary condition implements the standard logarithmic profile for the stream-wise wind velocity component with corresponding profiles for turbulence kinetic energy and specific dissipation rate, where the ground roughness effects are taken into account."
      },
      "AdvancedModelling" : {
        "type" : "object",
        "properties" : {
          "surfaceRoughness" : {
            "title" : "Surface roughness",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SurfaceRoughness"
            }
          },
          "porousObjects" : {
            "title" : "Porous objects",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_AdvancedModellingPorousObjects"
            }
          },
          "rotatingWalls" : {
            "title" : "Rotating walls",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RotatingWall"
            },
            "x-showWhen" : [ "type in [INCOMPRESSIBLE_PACEFISH]" ]
          }
        },
        "additionalProperties" : false
      },
      "SurfaceRoughness" : {
        "title" : "Surface roughness",
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "surfaceRoughness" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "GeneralDarcyForchheimerPacefish" : {
        "title" : "Darcy-Forchheimer",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GeneralDarcyForchheimerPacefish",
            "default" : "GENERAL_POROSITY"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "darcyForchheimerType" : {
            "$ref" : "#/components/schemas/OneOf_GeneralDarcyForchheimerPacefishDarcyForchheimerType"
          },
          "permeability" : {
            "$ref" : "#/components/schemas/Dimensional_Area"
          },
          "frictionFormCoefficient" : {
            "title" : "Friction form coefficient",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "Friction form coefficient defines the pressure losses due to inertial effects through the porous object. The greater the friction form coefficient, the greater the pressure losses due to inertial effects  are. Friction form coefficient of zero means that there are no inertial losses through the porous object.",
            "default" : 1
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "LOCAL_CARTESIAN_BOX", "LOCAL_SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "PorousTree" : {
        "title" : "Tree",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PorousTree",
            "default" : "POROUS_TREE"
          },
          "name" : {
            "title" : "Name",
            "pattern" : "^[A-Za-z][-+0-9a-zA-Z_\\h]{0,11}$",
            "type" : "string"
          },
          "treeType" : {
            "$ref" : "#/components/schemas/OneOf_PorousTreeTreeType"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "LOCAL_CARTESIAN_BOX", "LOCAL_SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "CustomTree" : {
        "title" : "Custom tree",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CustomTree",
            "default" : "CUSTOM_TREE"
          },
          "leafAreaIndex" : {
            "title" : "Leaf area index",
            "type" : "number",
            "description" : "Leaf Area Index (LAI) is a dimensionless quantity that is defined as the leaf area per unit ground surface area in broadleaf canopies",
            "default" : 5.28
          },
          "averageTreeHeight" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "dragCoefficient" : {
            "title" : "Drag coefficient",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "Drag coefficient of the tree canopy.",
            "default" : 0.2
          }
        },
        "additionalProperties" : false
      },
      "PlaneTree" : {
        "title" : "Plane tree",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: PlaneTree",
            "default" : "PLANE_TREE"
          },
          "averageTreeHeight" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "Oak" : {
        "title" : "Oak",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: Oak",
            "default" : "OAK"
          },
          "averageTreeHeight" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "Sycamore" : {
        "title" : "Sycamore",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: Sycamore",
            "default" : "SYCAMORE"
          },
          "averageTreeHeight" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "SilverBirch" : {
        "title" : "Silver birch",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SilverBirch",
            "default" : "SILVER_BIRCH"
          },
          "averageTreeHeight" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "Chestnut" : {
        "title" : "Chestnut",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: Chestnut",
            "default" : "CHESTNUT"
          },
          "averageTreeHeight" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "RotatingWall" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "origin" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "axis" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          },
          "rotationalVelocity" : {
            "$ref" : "#/components/schemas/Dimensional_RotationSpeed"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "PacefishMeshLegacy" : {
        "title" : "Manual",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose between <i>Automatic</i> and <i>Manual</i> mesh settings. <a href='https://www.simscale.com/docs/analysis-types/incompressible-lbm/#mesh' target='_blank'>Learn more.</a></p><p><b>Note:</b> Mesh fineness impacts the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>\n\nSchema name: PacefishMeshLegacy",
            "default" : "PACEFISH_MESH_LEGACY"
          },
          "fineness" : {
            "title" : "Fineness",
            "type" : "string",
            "default" : "COARSE",
            "enum" : [ "VERY_COARSE", "COARSE", "MODERATE", "FINE", "VERY_FINE" ]
          },
          "referenceLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "reynoldsScalingType" : {
            "$ref" : "#/components/schemas/ManualReynoldsScaling"
          },
          "refinements" : {
            "title" : "Refinements",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_PacefishMeshLegacyRefinements"
            }
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose between <i>Automatic</i> and <i>Manual</i> mesh settings. <a href='https://www.simscale.com/docs/analysis-types/incompressible-lbm/#mesh' target='_blank'>Learn more.</a></p><p><b>Note:</b> Mesh fineness impacts the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>"
      },
      "ManualReynoldsScaling" : {
        "title" : "Manual",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ManualReynoldsScaling",
            "default" : "MANUAL_REYNOLDS_SCALING"
          },
          "reynoldsScalingFactor" : {
            "title" : "Reynolds scaling factor",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0.001,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 1
          }
        },
        "additionalProperties" : false
      },
      "RegionRefinementPacefish" : {
        "title" : "Region refinement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: RegionRefinementPacefish",
            "default" : "REGION_PACEFISH"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Region refinement"
          },
          "targetResolution" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "LOCAL_CARTESIAN_BOX", "LOCAL_SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "SurfaceRefinementPacefish" : {
        "title" : "Surface refinement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SurfaceRefinementPacefish",
            "default" : "SURFACE_PACEFISH"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Surface refinement"
          },
          "targetResolution" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "bufferCellsNoExtrude" : {
            "title" : "Buffer cells between refinement levels",
            "minimum" : 3,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "Specify the minimum number of buffer cells between regions of different refinements.",
            "default" : 4
          },
          "additionalDirectionalCells" : {
            "$ref" : "#/components/schemas/AdditionalDirectionalCells"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "AdditionalDirectionalCells" : {
        "required" : [ "x", "y", "z" ],
        "type" : "object",
        "properties" : {
          "x" : {
            "title" : "X",
            "type" : "integer",
            "description" : "Specify the number of additional cells to be added in the X-direction. Note: additional cells in the negative X direction is not supported."
          },
          "y" : {
            "title" : "Y",
            "type" : "integer",
            "description" : "Specify the number of additional cells to be added in the Y-direction. Note: additional cells in the negative Y direction is not supported."
          },
          "z" : {
            "title" : "Z",
            "type" : "integer",
            "description" : "Specify the number of additional cells to be added in the Z-direction. Note: additional cells in the negative Z direction is not supported."
          }
        },
        "additionalProperties" : false
      },
      "PacefishMeshV38" : {
        "title" : "Automatic - deprecated",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose between <i>Automatic</i> and <i>Manual</i> mesh settings. <a href='https://www.simscale.com/docs/analysis-types/incompressible-lbm/#mesh' target='_blank'>Learn more.</a></p><p><b>Note:</b> Mesh fineness impacts the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>\n\nSchema name: PacefishMeshV38",
            "default" : "PACEFISH_MESH_V38"
          },
          "fineness" : {
            "title" : "Fineness",
            "type" : "string",
            "default" : "COARSE",
            "enum" : [ "VERY_COARSE", "COARSE", "MODERATE", "FINE", "VERY_FINE" ]
          },
          "referenceLength" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "primaryTopology" : {
            "$ref" : "#/components/schemas/OneOf_PacefishMeshV38PrimaryTopology"
          },
          "refinements" : {
            "title" : "Refinements",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_PacefishMeshV38Refinements"
            }
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose between <i>Automatic</i> and <i>Manual</i> mesh settings. <a href='https://www.simscale.com/docs/analysis-types/incompressible-lbm/#mesh' target='_blank'>Learn more.</a></p><p><b>Note:</b> Mesh fineness impacts the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>"
      },
      "NoPrimaryTopology" : {
        "title" : "None",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NoPrimaryTopology",
            "default" : "NO_PRIMARY_TOPOLOGY"
          }
        },
        "additionalProperties" : false
      },
      "BuildingsOfInterest" : {
        "title" : "Part(s)",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: BuildingsOfInterest",
            "default" : "BUILDINGS_OF_INTEREST"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "NewRegionRefinementPacefishV38" : {
        "title" : "Region refinement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NewRegionRefinementPacefishV38",
            "default" : "REGION_PACEFISH_V38"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Region refinement"
          },
          "meshSizing" : {
            "$ref" : "#/components/schemas/OneOf_NewRegionRefinementPacefishV38MeshSizing"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "LOCAL_CARTESIAN_BOX", "LOCAL_SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "ManualRegionSizingPacefish" : {
        "title" : "Manual",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ManualRegionSizingPacefish",
            "default" : "MANUAL_REGION_PACEFISH"
          },
          "targetResolution" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "NewSurfaceRefinementPacefishV38" : {
        "title" : "Surface refinement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: NewSurfaceRefinementPacefishV38",
            "default" : "SURFACE_PACEFISH_V38"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Surface refinement"
          },
          "meshSizing" : {
            "$ref" : "#/components/schemas/OneOf_NewSurfaceRefinementPacefishV38MeshSizing"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "ManualSurfaceSizingPacefish" : {
        "title" : "Manual",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ManualSurfaceSizingPacefish",
            "default" : "MANUAL_SURFACE_PACEFISH"
          },
          "targetResolution" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "bufferCellsNoExtrude" : {
            "title" : "Buffer cells between refinement levels",
            "minimum" : 3,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "Specify the minimum number of buffer cells between regions of different refinements.",
            "default" : 4
          },
          "additionalDirectionalCells" : {
            "$ref" : "#/components/schemas/AdditionalDirectionalCells"
          }
        },
        "additionalProperties" : false
      },
      "PacefishAutomesh" : {
        "title" : "Automatic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>Choose between <i>Automatic</i> and <i>Manual</i> mesh settings. <a href='https://www.simscale.com/docs/analysis-types/incompressible-lbm/#mesh' target='_blank'>Learn more.</a></p><p><b>Note:</b> Mesh fineness impacts the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>\n\nSchema name: PacefishAutomesh",
            "default" : "PACEFISH_AUTOMESH"
          },
          "newFineness" : {
            "$ref" : "#/components/schemas/OneOf_PacefishAutomeshNewFineness"
          },
          "referenceLengthComputation" : {
            "$ref" : "#/components/schemas/OneOf_PacefishAutomeshReferenceLengthComputation"
          },
          "reynoldsScalingType" : {
            "$ref" : "#/components/schemas/OneOf_PacefishAutomeshReynoldsScalingType"
          },
          "primaryTopology" : {
            "$ref" : "#/components/schemas/OneOf_PacefishAutomeshPrimaryTopology"
          },
          "refinements" : {
            "title" : "Refinements",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_PacefishAutomeshRefinements"
            }
          }
        },
        "additionalProperties" : false,
        "description" : "<p>Choose between <i>Automatic</i> and <i>Manual</i> mesh settings. <a href='https://www.simscale.com/docs/analysis-types/incompressible-lbm/#mesh' target='_blank'>Learn more.</a></p><p><b>Note:</b> Mesh fineness impacts the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>"
      },
      "PacefishFinenessVeryCoarse" : {
        "title" : "Very coarse",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>\n\nSchema name: PacefishFinenessVeryCoarse",
            "default" : "VERY_COARSE"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>"
      },
      "PacefishFinenessCoarse" : {
        "title" : "Coarse",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>\n\nSchema name: PacefishFinenessCoarse",
            "default" : "COARSE"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>"
      },
      "PacefishFinenessModerate" : {
        "title" : "Moderate",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>\n\nSchema name: PacefishFinenessModerate",
            "default" : "MODERATE"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>"
      },
      "PacefishFinenessFine" : {
        "title" : "Fine",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>\n\nSchema name: PacefishFinenessFine",
            "default" : "FINE"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>"
      },
      "PacefishFinenessVeryFine" : {
        "title" : "Very fine",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>\n\nSchema name: PacefishFinenessVeryFine",
            "default" : "VERY_FINE"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>"
      },
      "PacefishFinenessTargetSize" : {
        "title" : "Target size",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>\n\nSchema name: PacefishFinenessTargetSize",
            "default" : "TARGET_SIZE"
          },
          "minimumCellSize" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>"
      },
      "AutomaticReferenceLength" : {
        "title" : "Automatic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AutomaticReferenceLength",
            "default" : "AUTOMATIC_REFERENCE_LENGTH"
          }
        },
        "additionalProperties" : false
      },
      "ManualReferenceLength" : {
        "title" : "Manual",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ManualReferenceLength",
            "default" : "MANUAL_REFERENCE_LENGTH"
          },
          "value" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "AutomaticReynoldsScaling" : {
        "title" : "Automatic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AutomaticReynoldsScaling",
            "default" : "AUTOMATIC_REYNOLDS_SCALING"
          }
        },
        "additionalProperties" : false
      },
      "Region" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: Region",
            "default" : "REGION"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "LOCAL_CARTESIAN_BOX", "CYLINDER", "LOCAL_SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "SimericsAnalysis" : {
        "title" : "Subsonic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SimericsAnalysis",
            "default" : "SIMERICS_ANALYSIS"
          },
          "model" : {
            "$ref" : "#/components/schemas/FluidModel"
          },
          "materials" : {
            "$ref" : "#/components/schemas/SimericsFluidMaterials"
          },
          "isCompressible" : {
            "title" : "Compressible",
            "type" : "boolean",
            "default" : false
          },
          "cavitationModel" : {
            "title" : "Cavitation model",
            "type" : "string",
            "default" : "NONE",
            "enum" : [ "CONSTANT_GAS_MASS_FRACTION", "NONE" ],
            "x-showWhen" : [ "1/isCompressible == false" ]
          },
          "turbulenceModel" : {
            "title" : "Turbulence model",
            "type" : "string",
            "description" : "Choose a turbulence model for your CFD analysis:<ul><li><strong>No turbulence</strong>: Laminar</li><li><strong>RANS</strong>: <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-epsilon/' target='_blank'>k-epsilon</a></ul><p><p><a href='https://www.simscale.com/blog/2017/12/turbulence-cfd-analysis/' target='_blank'>Learn more</a>.</p>",
            "default" : "KEPSILON",
            "enum" : [ "NONE", "KEPSILON" ]
          },
          "timeDependency" : {
            "$ref" : "#/components/schemas/OneOf_SimericsAnalysisTimeDependency"
          },
          "boundaryConditions" : {
            "title" : "Boundary conditions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_SimericsAnalysisBoundaryConditions"
            }
          },
          "advancedConcepts" : {
            "$ref" : "#/components/schemas/AdvancedConcepts"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/FluidSimulationControl"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/FluidResultControls"
          },
          "meshSettings" : {
            "$ref" : "#/components/schemas/OneOf_SimericsAnalysisMeshSettings"
          }
        },
        "additionalProperties" : false
      },
      "SimericsFluidMaterials" : {
        "type" : "object",
        "properties" : {
          "fluids" : {
            "title" : "Materials",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_SimericsFluidMaterialsFluids"
            }
          }
        },
        "additionalProperties" : false
      },
      "FluidCompressibleMaterial" : {
        "title" : "Fluid compressible material",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FluidCompressibleMaterial",
            "default" : "COMPRESSIBLE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "specie" : {
            "$ref" : "#/components/schemas/SpecieDefault"
          },
          "transport" : {
            "$ref" : "#/components/schemas/OneOf_FluidCompressibleMaterialTransport"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-showWhen" : [ "type == EMBEDDED_BOUNDARY && isInternalFlow == false" ],
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX" ]
            }
          },
          "builtInMaterial" : {
            "type" : "string"
          },
          "materialLibraryReference" : {
            "$ref" : "#/components/schemas/MaterialLibraryReference"
          }
        },
        "additionalProperties" : false
      },
      "SpecieDefault" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p><b>Specie:</b> defines the molecular composition of the fluid material. Currently a single specie is available.</p>\n\nSchema name: SpecieDefault",
            "default" : "SPECIE"
          },
          "amountOfSubstance" : {
            "$ref" : "#/components/schemas/Dimensional_AmountOfSubstance"
          },
          "molarWeight" : {
            "$ref" : "#/components/schemas/Dimensional_MolarMass"
          }
        },
        "additionalProperties" : false,
        "description" : "<p><b>Specie:</b> defines the molecular composition of the fluid material. Currently a single specie is available.</p>"
      },
      "Dimensional_AmountOfSubstance" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "title" : "Value",
            "type" : "number"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "mol" ]
          }
        },
        "additionalProperties" : false
      },
      "ConstTransport" : {
        "title" : "Const",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ConstTransport",
            "default" : "CONST"
          },
          "dynamicViscosity" : {
            "$ref" : "#/components/schemas/Dimensional_DynamicViscosity"
          },
          "dynamicViscosityFunction" : {
            "$ref" : "#/components/schemas/DimensionalFunction_DynamicViscosity"
          },
          "prandtlNumber" : {
            "title" : "(Pr) Prandtl number",
            "minimum" : 0,
            "exclusiveMinimum" : true,
            "type" : "number",
            "description" : "Prandtl number (<i>Pr</i>) is the ratio of momentum transport to thermal tranport. Fluids with low <i>Pr</i> are free flowing and good for heat conduction."
          },
          "turbulentPrandtlNumber" : {
            "title" : "(Pr<t>) Turb. Prandtl number",
            "minimum" : 0,
            "exclusiveMinimum" : true,
            "type" : "number",
            "description" : "Turbulent Prandtl number is used to calculate the heat transfer due to turbulent effects in the domain.",
            "x-showWhen" : [ "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY,SIMERICS_ANALYSIS]" ]
          },
          "thermo" : {
            "$ref" : "#/components/schemas/OneOf_ConstTransportThermo"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalFunction_DynamicViscosity" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/OneOf_DimensionalFunction_DynamicViscosityValue"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "kg/(sm)", "lbfs/in" ]
          }
        },
        "additionalProperties" : false
      },
      "EConstThermo" : {
        "title" : "eConst",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<br><p>The <b>Thermo models</b> are used to calculate the specific heat at constant pressure (<i>Cp</i>) for the fluid. The available models are:</p><p><b>hConst:</b> This model assumes a constant value for specific heat at fixed pressure (<i>Cp</i>). </p><p><b>eConst:</b> This model assumes a constant value for the specific heat at fixed volume (<i>Cv</i>). </p>\n\nSchema name: EConstThermo",
            "default" : "ECONST"
          },
          "specificHeat" : {
            "$ref" : "#/components/schemas/Dimensional_SpecificHeat"
          },
          "equationOfState" : {
            "$ref" : "#/components/schemas/PerfectGasEquationOfState"
          }
        },
        "additionalProperties" : false,
        "description" : "<br><p>The <b>Thermo models</b> are used to calculate the specific heat at constant pressure (<i>Cp</i>) for the fluid. The available models are:</p><p><b>hConst:</b> This model assumes a constant value for specific heat at fixed pressure (<i>Cp</i>). </p><p><b>eConst:</b> This model assumes a constant value for the specific heat at fixed volume (<i>Cv</i>). </p>"
      },
      "PerfectGasEquationOfState" : {
        "title" : "Perfect gas",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<br><p>The <b>Equation of state</b> describes the relation between density of a fluid and the fluid pressure and temperature. The available options are:</p><p><b>Rho const:</b> Fluid density is assumed constant.</p><p><b>Incompressibel perfect gas:</b> The fluid is assumed to be an 'Ideal Gas' that is incompressible by pressure. But, fluid density can change due to temperature.</p><p><b>Perfect gas:</b> Fluid is assumed to be an 'Ideal Gas' and obeys the 'Ideal Gas Law'.</p><p><b>Perfect fluid:</b> Fluid density can change due to pressure and temperature with respect to a base value.</p><p><b>Adiabatic perfect fluid:</b> The fluid is a perfect fluid which is adiabatic in nature.</p> <a href='https://www.simscale.com/docs/simulation-setup/materials/thermophysical-fluid-models/#equation-of-state' target='_blank'>Learn more</a>.\n\nSchema name: PerfectGasEquationOfState",
            "default" : "PERFECT_GAS"
          },
          "energy" : {
            "title" : "Energy",
            "type" : "string",
            "description" : "<p><b>Energy</b> provides the methods for the form of energy to be used. The options are:</p><p><b>Sensible enthalpy:</b> The enthalpy form of equation is used without the heat of formation. In most cases this is the recommended choice.</p><p><b>Sensible internal Energy:</b> The internal energy form of equation is used without the heat of formation but also incorporates energy change due to reactions.</p>",
            "x-showWhen" : [ "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER]" ],
            "x-conditionalEnum" : [ {
              "value" : "SENSIBLE_ENTHALPY",
              "when" : [ "type == COMPRESSIBLE && 2/type == HCONST", "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER]" ]
            }, {
              "value" : "SENSIBLE_INTERNAL_ENERGY",
              "when" : [ "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER]" ]
            } ],
            "x-conditionalDefaults" : [ {
              "when" : [ "type == COMPRESSIBLE && 2/type == HCONST", "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER]" ],
              "default" : "SENSIBLE_ENTHALPY"
            }, {
              "when" : [ "type == COMPRESSIBLE && 2/type == ECONST" ],
              "default" : "SENSIBLE_INTERNAL_ENERGY"
            } ]
          }
        },
        "additionalProperties" : false,
        "description" : "<br><p>The <b>Equation of state</b> describes the relation between density of a fluid and the fluid pressure and temperature. The available options are:</p><p><b>Rho const:</b> Fluid density is assumed constant.</p><p><b>Incompressibel perfect gas:</b> The fluid is assumed to be an 'Ideal Gas' that is incompressible by pressure. But, fluid density can change due to temperature.</p><p><b>Perfect gas:</b> Fluid is assumed to be an 'Ideal Gas' and obeys the 'Ideal Gas Law'.</p><p><b>Perfect fluid:</b> Fluid density can change due to pressure and temperature with respect to a base value.</p><p><b>Adiabatic perfect fluid:</b> The fluid is a perfect fluid which is adiabatic in nature.</p> <a href='https://www.simscale.com/docs/simulation-setup/materials/thermophysical-fluid-models/#equation-of-state' target='_blank'>Learn more</a>."
      },
      "HConstThermo" : {
        "title" : "hConst",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<br><p>The <b>Thermo models</b> are used to calculate the specific heat at constant pressure (<i>Cp</i>) for the fluid. The available models are:</p><p><b>hConst:</b> This model assumes a constant value for specific heat at fixed pressure (<i>Cp</i>). </p><p><b>eConst:</b> This model assumes a constant value for the specific heat at fixed volume (<i>Cv</i>). </p>\n\nSchema name: HConstThermo",
            "default" : "HCONST"
          },
          "specificHeat" : {
            "$ref" : "#/components/schemas/Dimensional_SpecificHeat"
          },
          "equationOfState" : {
            "$ref" : "#/components/schemas/OneOf_HConstThermoEquationOfState"
          }
        },
        "additionalProperties" : false,
        "description" : "<br><p>The <b>Thermo models</b> are used to calculate the specific heat at constant pressure (<i>Cp</i>) for the fluid. The available models are:</p><p><b>hConst:</b> This model assumes a constant value for specific heat at fixed pressure (<i>Cp</i>). </p><p><b>eConst:</b> This model assumes a constant value for the specific heat at fixed volume (<i>Cv</i>). </p>"
      },
      "RhoConstEquationOfState" : {
        "title" : "Rho const.",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<br><p>The <b>Equation of state</b> describes the relation between density of a fluid and the fluid pressure and temperature. The available options are:</p><p><b>Rho const:</b> Fluid density is assumed constant.</p><p><b>Incompressibel perfect gas:</b> The fluid is assumed to be an 'Ideal Gas' that is incompressible by pressure. But, fluid density can change due to temperature.</p><p><b>Perfect gas:</b> Fluid is assumed to be an 'Ideal Gas' and obeys the 'Ideal Gas Law'.</p><p><b>Perfect fluid:</b> Fluid density can change due to pressure and temperature with respect to a base value.</p><p><b>Adiabatic perfect fluid:</b> The fluid is a perfect fluid which is adiabatic in nature.</p> <a href='https://www.simscale.com/docs/simulation-setup/materials/thermophysical-fluid-models/#equation-of-state' target='_blank'>Learn more</a>.\n\nSchema name: RhoConstEquationOfState",
            "default" : "RHO_CONST"
          },
          "density" : {
            "$ref" : "#/components/schemas/Dimensional_Density"
          },
          "energy" : {
            "title" : "Energy",
            "type" : "string",
            "description" : "<p><b>Energy</b> provides the methods for the form of energy to be used. The options are:</p><p><b>Sensible enthalpy:</b> The enthalpy form of equation is used without the heat of formation. In most cases this is the recommended choice.</p><p><b>Sensible internal Energy:</b> The internal energy form of equation is used without the heat of formation but also incorporates energy change due to reactions.</p>",
            "default" : "SENSIBLE_ENTHALPY",
            "x-showWhen" : [ "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER]" ],
            "x-conditionalEnum" : [ {
              "value" : "SENSIBLE_ENTHALPY",
              "when" : [ "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER]" ]
            }, {
              "value" : "SENSIBLE_INTERNAL_ENERGY",
              "when" : [ "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER]", "type == CONJUGATE_HEAT_TRANSFER && 3/type in [CONST,SUTHERLAND]" ]
            } ]
          }
        },
        "additionalProperties" : false,
        "description" : "<br><p>The <b>Equation of state</b> describes the relation between density of a fluid and the fluid pressure and temperature. The available options are:</p><p><b>Rho const:</b> Fluid density is assumed constant.</p><p><b>Incompressibel perfect gas:</b> The fluid is assumed to be an 'Ideal Gas' that is incompressible by pressure. But, fluid density can change due to temperature.</p><p><b>Perfect gas:</b> Fluid is assumed to be an 'Ideal Gas' and obeys the 'Ideal Gas Law'.</p><p><b>Perfect fluid:</b> Fluid density can change due to pressure and temperature with respect to a base value.</p><p><b>Adiabatic perfect fluid:</b> The fluid is a perfect fluid which is adiabatic in nature.</p> <a href='https://www.simscale.com/docs/simulation-setup/materials/thermophysical-fluid-models/#equation-of-state' target='_blank'>Learn more</a>."
      },
      "PerfectFluidEquationOfState" : {
        "title" : "Perfect fluid",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<br><p>The <b>Equation of state</b> describes the relation between density of a fluid and the fluid pressure and temperature. The available options are:</p><p><b>Rho const:</b> Fluid density is assumed constant.</p><p><b>Incompressibel perfect gas:</b> The fluid is assumed to be an 'Ideal Gas' that is incompressible by pressure. But, fluid density can change due to temperature.</p><p><b>Perfect gas:</b> Fluid is assumed to be an 'Ideal Gas' and obeys the 'Ideal Gas Law'.</p><p><b>Perfect fluid:</b> Fluid density can change due to pressure and temperature with respect to a base value.</p><p><b>Adiabatic perfect fluid:</b> The fluid is a perfect fluid which is adiabatic in nature.</p> <a href='https://www.simscale.com/docs/simulation-setup/materials/thermophysical-fluid-models/#equation-of-state' target='_blank'>Learn more</a>.\n\nSchema name: PerfectFluidEquationOfState",
            "default" : "PERFECT_FLUID"
          },
          "fluidConstant" : {
            "$ref" : "#/components/schemas/Dimensional_SpecificHeat"
          },
          "referenceDensity" : {
            "$ref" : "#/components/schemas/Dimensional_Density"
          },
          "energy" : {
            "title" : "Energy",
            "type" : "string",
            "description" : "<p><b>Energy</b> provides the methods for the form of energy to be used. The options are:</p><p><b>Sensible enthalpy:</b> The enthalpy form of equation is used without the heat of formation. In most cases this is the recommended choice.</p><p><b>Sensible internal Energy:</b> The internal energy form of equation is used without the heat of formation but also incorporates energy change due to reactions.</p>",
            "default" : "SENSIBLE_ENTHALPY",
            "enum" : [ "SENSIBLE_ENTHALPY", "SENSIBLE_INTERNAL_ENERGY" ]
          }
        },
        "additionalProperties" : false,
        "description" : "<br><p>The <b>Equation of state</b> describes the relation between density of a fluid and the fluid pressure and temperature. The available options are:</p><p><b>Rho const:</b> Fluid density is assumed constant.</p><p><b>Incompressibel perfect gas:</b> The fluid is assumed to be an 'Ideal Gas' that is incompressible by pressure. But, fluid density can change due to temperature.</p><p><b>Perfect gas:</b> Fluid is assumed to be an 'Ideal Gas' and obeys the 'Ideal Gas Law'.</p><p><b>Perfect fluid:</b> Fluid density can change due to pressure and temperature with respect to a base value.</p><p><b>Adiabatic perfect fluid:</b> The fluid is a perfect fluid which is adiabatic in nature.</p> <a href='https://www.simscale.com/docs/simulation-setup/materials/thermophysical-fluid-models/#equation-of-state' target='_blank'>Learn more</a>."
      },
      "IncompressiblePerfectGasEquationOfState" : {
        "title" : "Incompressible perfect gas",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<br><p>The <b>Equation of state</b> describes the relation between density of a fluid and the fluid pressure and temperature. The available options are:</p><p><b>Rho const:</b> Fluid density is assumed constant.</p><p><b>Incompressibel perfect gas:</b> The fluid is assumed to be an 'Ideal Gas' that is incompressible by pressure. But, fluid density can change due to temperature.</p><p><b>Perfect gas:</b> Fluid is assumed to be an 'Ideal Gas' and obeys the 'Ideal Gas Law'.</p><p><b>Perfect fluid:</b> Fluid density can change due to pressure and temperature with respect to a base value.</p><p><b>Adiabatic perfect fluid:</b> The fluid is a perfect fluid which is adiabatic in nature.</p> <a href='https://www.simscale.com/docs/simulation-setup/materials/thermophysical-fluid-models/#equation-of-state' target='_blank'>Learn more</a>.\n\nSchema name: IncompressiblePerfectGasEquationOfState",
            "default" : "INCOMPRESSIBLE_PERFECT_GAS"
          },
          "referencePressure" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "energy" : {
            "title" : "Energy",
            "type" : "string",
            "description" : "<p><b>Energy</b> provides the methods for the form of energy to be used. The options are:</p><p><b>Sensible enthalpy:</b> The enthalpy form of equation is used without the heat of formation. In most cases this is the recommended choice.</p><p><b>Sensible internal Energy:</b> The internal energy form of equation is used without the heat of formation but also incorporates energy change due to reactions.</p>",
            "default" : "SENSIBLE_ENTHALPY",
            "enum" : [ "SENSIBLE_ENTHALPY", "SENSIBLE_INTERNAL_ENERGY" ]
          }
        },
        "additionalProperties" : false,
        "description" : "<br><p>The <b>Equation of state</b> describes the relation between density of a fluid and the fluid pressure and temperature. The available options are:</p><p><b>Rho const:</b> Fluid density is assumed constant.</p><p><b>Incompressibel perfect gas:</b> The fluid is assumed to be an 'Ideal Gas' that is incompressible by pressure. But, fluid density can change due to temperature.</p><p><b>Perfect gas:</b> Fluid is assumed to be an 'Ideal Gas' and obeys the 'Ideal Gas Law'.</p><p><b>Perfect fluid:</b> Fluid density can change due to pressure and temperature with respect to a base value.</p><p><b>Adiabatic perfect fluid:</b> The fluid is a perfect fluid which is adiabatic in nature.</p> <a href='https://www.simscale.com/docs/simulation-setup/materials/thermophysical-fluid-models/#equation-of-state' target='_blank'>Learn more</a>."
      },
      "AdiabaticPerfectFluidEquationOfState" : {
        "title" : "Adiabatic perfect fluid",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<br><p>The <b>Equation of state</b> describes the relation between density of a fluid and the fluid pressure and temperature. The available options are:</p><p><b>Rho const:</b> Fluid density is assumed constant.</p><p><b>Incompressibel perfect gas:</b> The fluid is assumed to be an 'Ideal Gas' that is incompressible by pressure. But, fluid density can change due to temperature.</p><p><b>Perfect gas:</b> Fluid is assumed to be an 'Ideal Gas' and obeys the 'Ideal Gas Law'.</p><p><b>Perfect fluid:</b> Fluid density can change due to pressure and temperature with respect to a base value.</p><p><b>Adiabatic perfect fluid:</b> The fluid is a perfect fluid which is adiabatic in nature.</p> <a href='https://www.simscale.com/docs/simulation-setup/materials/thermophysical-fluid-models/#equation-of-state' target='_blank'>Learn more</a>.\n\nSchema name: AdiabaticPerfectFluidEquationOfState",
            "default" : "ADIABATIC_PERFECT_FLUID"
          },
          "referencePressure" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "referenceDensity" : {
            "$ref" : "#/components/schemas/Dimensional_Density"
          },
          "isentropicExponent" : {
            "title" : "Isentropic exponent",
            "type" : "number",
            "description" : "Specify the isentropic exponent. This parameter characterizes changes in density due to pressure. A Larger isentropic exponent results in less sensitivity of the density to reference pressure."
          },
          "pressureOffset" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "energy" : {
            "title" : "Energy",
            "type" : "string",
            "description" : "<p><b>Energy</b> provides the methods for the form of energy to be used. The options are:</p><p><b>Sensible enthalpy:</b> The enthalpy form of equation is used without the heat of formation. In most cases this is the recommended choice.</p><p><b>Sensible internal Energy:</b> The internal energy form of equation is used without the heat of formation but also incorporates energy change due to reactions.</p>",
            "default" : "SENSIBLE_ENTHALPY",
            "enum" : [ "SENSIBLE_ENTHALPY", "SENSIBLE_INTERNAL_ENERGY" ]
          }
        },
        "additionalProperties" : false,
        "description" : "<br><p>The <b>Equation of state</b> describes the relation between density of a fluid and the fluid pressure and temperature. The available options are:</p><p><b>Rho const:</b> Fluid density is assumed constant.</p><p><b>Incompressibel perfect gas:</b> The fluid is assumed to be an 'Ideal Gas' that is incompressible by pressure. But, fluid density can change due to temperature.</p><p><b>Perfect gas:</b> Fluid is assumed to be an 'Ideal Gas' and obeys the 'Ideal Gas Law'.</p><p><b>Perfect fluid:</b> Fluid density can change due to pressure and temperature with respect to a base value.</p><p><b>Adiabatic perfect fluid:</b> The fluid is a perfect fluid which is adiabatic in nature.</p> <a href='https://www.simscale.com/docs/simulation-setup/materials/thermophysical-fluid-models/#equation-of-state' target='_blank'>Learn more</a>."
      },
      "PengRobinsonGasEquationOfState" : {
        "title" : "Peng-Robinson",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<br><p>The <b>Equation of state</b> describes the relation between density of a fluid and the fluid pressure and temperature. The available options are:</p><p><b>Rho const:</b> Fluid density is assumed constant.</p><p><b>Incompressibel perfect gas:</b> The fluid is assumed to be an 'Ideal Gas' that is incompressible by pressure. But, fluid density can change due to temperature.</p><p><b>Perfect gas:</b> Fluid is assumed to be an 'Ideal Gas' and obeys the 'Ideal Gas Law'.</p><p><b>Perfect fluid:</b> Fluid density can change due to pressure and temperature with respect to a base value.</p><p><b>Adiabatic perfect fluid:</b> The fluid is a perfect fluid which is adiabatic in nature.</p> <a href='https://www.simscale.com/docs/simulation-setup/materials/thermophysical-fluid-models/#equation-of-state' target='_blank'>Learn more</a>.\n\nSchema name: PengRobinsonGasEquationOfState",
            "default" : "PENG_ROBINSON_GAS"
          },
          "criticalTemperature" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          },
          "criticalVolume" : {
            "$ref" : "#/components/schemas/Dimensional_MolarMass"
          },
          "criticalPressure" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          },
          "acentricFactor" : {
            "title" : "Acentric factor",
            "type" : "number",
            "description" : "Specify the acentric factor. It is a property of the material that characterized the changes in thermodynamic properties of the fluid due to non-spherical molecules."
          },
          "energy" : {
            "title" : "Energy",
            "type" : "string",
            "description" : "<p><b>Energy</b> provides the methods for the form of energy to be used. The options are:</p><p><b>Sensible enthalpy:</b> The enthalpy form of equation is used without the heat of formation. In most cases this is the recommended choice.</p><p><b>Sensible internal Energy:</b> The internal energy form of equation is used without the heat of formation but also incorporates energy change due to reactions.</p>",
            "default" : "SENSIBLE_ENTHALPY",
            "enum" : [ "SENSIBLE_ENTHALPY", "SENSIBLE_INTERNAL_ENERGY" ]
          }
        },
        "additionalProperties" : false,
        "description" : "<br><p>The <b>Equation of state</b> describes the relation between density of a fluid and the fluid pressure and temperature. The available options are:</p><p><b>Rho const:</b> Fluid density is assumed constant.</p><p><b>Incompressibel perfect gas:</b> The fluid is assumed to be an 'Ideal Gas' that is incompressible by pressure. But, fluid density can change due to temperature.</p><p><b>Perfect gas:</b> Fluid is assumed to be an 'Ideal Gas' and obeys the 'Ideal Gas Law'.</p><p><b>Perfect fluid:</b> Fluid density can change due to pressure and temperature with respect to a base value.</p><p><b>Adiabatic perfect fluid:</b> The fluid is a perfect fluid which is adiabatic in nature.</p> <a href='https://www.simscale.com/docs/simulation-setup/materials/thermophysical-fluid-models/#equation-of-state' target='_blank'>Learn more</a>."
      },
      "SutherlandTransport" : {
        "title" : "Sutherland",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SutherlandTransport",
            "default" : "SUTHERLAND"
          },
          "referenceViscosity" : {
            "$ref" : "#/components/schemas/Dimensional_DynamicViscosity"
          },
          "referenceTemperature" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          },
          "ts" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          },
          "thermo" : {
            "$ref" : "#/components/schemas/OneOf_SutherlandTransportThermo"
          }
        },
        "additionalProperties" : false
      },
      "AutomaticSimericsMeshSettings" : {
        "title" : "Automatic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AutomaticSimericsMeshSettings",
            "default" : "AUTOMATIC_SETTINGS"
          },
          "refinements" : {
            "title" : "Refinements",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RegionRefinementSimerics"
            }
          },
          "fineness" : {
            "title" : "Fineness",
            "maximum" : 10,
            "exclusiveMaximum" : false,
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "<p>Adjust the overall mesh sizing from coarse (value: 0) to fine (10).</p>",
            "default" : 1,
            "x-divisibleBy" : 0.1
          }
        },
        "additionalProperties" : false
      },
      "RegionRefinementSimerics" : {
        "title" : "Region refinement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: RegionRefinementSimerics",
            "default" : "REGION_REFINEMENT_SIMERICS"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Region refinement"
          },
          "refinementCellSize" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "CARTESIAN_BOX", "CYLINDER" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "ManualSimericsMeshSettings" : {
        "title" : "Manual",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ManualSimericsMeshSettings",
            "default" : "MANUAL_SETTINGS"
          },
          "refinements" : {
            "title" : "Refinements",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RegionRefinementSimerics"
            }
          },
          "minimumCellSize" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "maximumCellSize" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "cellSizeOnSurfaces" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "enableGrowthRate" : {
            "type" : "boolean",
            "description" : "<p><b>Specify growth rate</b>: Define the cell size growth rate between interior cells and surface cells.</p>",
            "default" : false
          },
          "growthRate" : {
            "maximum" : 8,
            "exclusiveMaximum" : false,
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "The <i>Growth rate</i> defines the cell size ratio between interior cell size and surface cell size. It needs to be <b>a whole number</b> always greater than 1 and smaller or equal to 8, such that the cell size increases towards the interior of the mesh.",
            "default" : 2,
            "x-showWhen" : [ "1/enableGrowthRate == true" ]
          }
        },
        "additionalProperties" : false
      },
      "WindComfort" : {
        "title" : "Pedestrian Wind Comfort",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WindComfort",
            "default" : "WIND_COMFORT"
          },
          "regionOfInterest" : {
            "$ref" : "#/components/schemas/RegionOfInterest"
          },
          "windConditions" : {
            "$ref" : "#/components/schemas/WindConditions"
          },
          "pedestrianComfortMap" : {
            "title" : "Pedestrian comfort map",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/PedestrianComfortSurface"
            }
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/WindComfortSimulationControl"
          },
          "advancedModelling" : {
            "$ref" : "#/components/schemas/AdvancedModelling"
          },
          "additionalResultExport" : {
            "$ref" : "#/components/schemas/FluidResultControls"
          },
          "meshSettings" : {
            "$ref" : "#/components/schemas/WindComfortMesh"
          }
        },
        "additionalProperties" : false
      },
      "RegionOfInterest" : {
        "type" : "object",
        "properties" : {
          "discRadius" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "centerPoint" : {
            "$ref" : "#/components/schemas/DimensionalVector2d_Length"
          },
          "groundHeight" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "northAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "advancedSettings" : {
            "$ref" : "#/components/schemas/AdvancedROISettings"
          }
        },
        "additionalProperties" : false
      },
      "DimensionalVector2d_Length" : {
        "required" : [ "unit" ],
        "type" : "object",
        "properties" : {
          "value" : {
            "$ref" : "#/components/schemas/DecimalVector2d"
          },
          "unit" : {
            "title" : "Unit",
            "type" : "string",
            "enum" : [ "m", "in" ]
          }
        },
        "additionalProperties" : false
      },
      "DecimalVector2d" : {
        "type" : "object",
        "properties" : {
          "x" : {
            "title" : "X",
            "type" : "number"
          },
          "y" : {
            "title" : "Y",
            "type" : "number"
          }
        },
        "additionalProperties" : false
      },
      "AdvancedROISettings" : {
        "type" : "object",
        "properties" : {
          "windTunnelSize" : {
            "$ref" : "#/components/schemas/OneOf_AdvancedROISettingsWindTunnelSize"
          }
        },
        "additionalProperties" : false
      },
      "WindTunnelSizeModerate" : {
        "title" : "Moderate",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WindTunnelSizeModerate",
            "default" : "WIND_TUNNEL_SIZE_MODERATE"
          }
        },
        "additionalProperties" : false
      },
      "WindTunnelSizeLarge" : {
        "title" : "Large",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WindTunnelSizeLarge",
            "default" : "WIND_TUNNEL_SIZE_LARGE"
          }
        },
        "additionalProperties" : false
      },
      "WindTunnelSizeCustom" : {
        "title" : "Custom",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: WindTunnelSizeCustom",
            "default" : "WIND_TUNNEL_SIZE_CUSTOM"
          },
          "heightExtension" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "sideExtension" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "inflowExtension" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "outflowExtension" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "WindConditions" : {
        "type" : "object",
        "properties" : {
          "geographicalLocation" : {
            "$ref" : "#/components/schemas/GeographicalLocation"
          },
          "windRose" : {
            "$ref" : "#/components/schemas/WindRose"
          }
        },
        "additionalProperties" : false
      },
      "GeographicalLocation" : {
        "type" : "object",
        "properties" : {
          "latitude" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "longitude" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          }
        },
        "additionalProperties" : false
      },
      "WindRose" : {
        "required" : [ "velocityUnit" ],
        "type" : "object",
        "properties" : {
          "numDirections" : {
            "title" : "Num directions",
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 16
          },
          "velocityBuckets" : {
            "title" : "Velocity buckets",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/WindRoseVelocityBucket"
            }
          },
          "velocityUnit" : {
            "title" : "Velocity unit",
            "type" : "string",
            "default" : "m/s"
          },
          "exposureCategories" : {
            "title" : "Exposure categories",
            "type" : "array",
            "items" : {
              "type" : "string",
              "enum" : [ "EC1", "EC2", "EC3", "EC4", "EC5", "EC6" ]
            }
          },
          "windEngineeringStandard" : {
            "title" : "Wind engineering standard",
            "type" : "string",
            "default" : "EU",
            "enum" : [ "EU", "AS_NZS", "NEN8100", "LONDON" ]
          },
          "windDataSource" : {
            "type" : "string",
            "enum" : [ "METEOBLUE", "USER_UPLOAD" ]
          },
          "addSurfaceRoughness" : {
            "type" : "boolean",
            "default" : true
          }
        },
        "additionalProperties" : false
      },
      "WindRoseVelocityBucket" : {
        "type" : "object",
        "properties" : {
          "from" : {
            "title" : "From",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number"
          },
          "to" : {
            "title" : "To",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number"
          },
          "fractions" : {
            "title" : "Fractions",
            "type" : "array",
            "items" : {
              "type" : "number"
            }
          }
        },
        "additionalProperties" : false
      },
      "PedestrianComfortSurface" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "heightAboveGround" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          },
          "ground" : {
            "$ref" : "#/components/schemas/OneOf_PedestrianComfortSurfaceGround"
          }
        },
        "additionalProperties" : false
      },
      "GroundAbsolute" : {
        "title" : "Ground absolute",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GroundAbsolute",
            "default" : "GROUND_ABSOLUTE"
          }
        },
        "additionalProperties" : false
      },
      "GroundRelative" : {
        "title" : "Ground relative",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: GroundRelative",
            "default" : "GROUND_RELATIVE"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "WindComfortSimulationControl" : {
        "type" : "object",
        "properties" : {
          "maxDirectionRunTime" : {
            "$ref" : "#/components/schemas/Dimensional_Time"
          },
          "numberOfFluidPasses" : {
            "title" : "Number of fluid passes",
            "maximum" : 10,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : true,
            "type" : "number",
            "description" : "<p>Set how many times the fluid (air) passes over the domain during the simulation.</p><p> <b>Warning</b>: Values below 2.0 might produce invalid results while higher numbers will require more simulation time and consequently more GPU hours. Recommended value is 3.0. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/simulation-control/' target='_blank'>Learn more</a>.</p>",
            "default" : 3
          }
        },
        "additionalProperties" : false
      },
      "WindComfortMesh" : {
        "type" : "object",
        "properties" : {
          "windComfortFineness" : {
            "$ref" : "#/components/schemas/OneOf_WindComfortMeshWindComfortFineness"
          },
          "reynoldsScalingType" : {
            "$ref" : "#/components/schemas/OneOf_WindComfortMeshReynoldsScalingType"
          },
          "refinements" : {
            "title" : "Refinements",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_WindComfortMeshRefinements"
            }
          }
        },
        "additionalProperties" : false
      },
      "SurfaceRefinementWindComfort" : {
        "title" : "Surface refinement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SurfaceRefinementWindComfort",
            "default" : "SURFACE_REFINEMENT_WIND_COMFORT"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Surface refinement"
          },
          "newFineness" : {
            "$ref" : "#/components/schemas/OneOf_SurfaceRefinementWindComfortNewFineness"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false
      },
      "RegionRefinementWindComfort" : {
        "title" : "Region refinement",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: RegionRefinementWindComfort",
            "default" : "REGION_REFINEMENT_WIND_COMFORT"
          },
          "name" : {
            "title" : "Name",
            "type" : "string",
            "default" : "Region refinement"
          },
          "newFineness" : {
            "$ref" : "#/components/schemas/OneOf_RegionRefinementWindComfortNewFineness"
          },
          "geometryPrimitiveUuids" : {
            "title" : "Geometry primitives",
            "type" : "array",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            },
            "x-geometryPrimitiveOptions" : {
              "allowMultiple" : true,
              "allowedGeometryPrimitiveTypes" : [ "LOCAL_CARTESIAN_BOX", "LOCAL_SPHERE" ]
            }
          }
        },
        "additionalProperties" : false
      },
      "Compressible" : {
        "title" : "Compressible",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: Compressible",
            "default" : "COMPRESSIBLE"
          },
          "turbulenceModel" : {
            "title" : "Turbulence model",
            "type" : "string",
            "description" : "Choose a turbulence model for your CFD analysis:<ul><li><strong>No turbulence</strong>: Laminar</li><li><strong>RANS</strong>: <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-epsilon/' target='_blank'>k-epsilon</a>, <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-omega-sst/' target='_blank'>k-omega and k-omega SST</a></li><li><strong>LES</strong>: Smagorinsky, Spalart-Allmaras</li></ul><p><p><a href='https://www.simscale.com/blog/2017/12/turbulence-cfd-analysis/' target='_blank'>Learn more</a>.</p>",
            "default" : "KOMEGASST",
            "enum" : [ "SMAGORINSKY", "SPALARTALLMARAS", "NONE", "KEPSILON", "KOMEGASST" ]
          },
          "timeDependency" : {
            "$ref" : "#/components/schemas/OneOf_CompressibleTimeDependency"
          },
          "model" : {
            "$ref" : "#/components/schemas/FluidModel"
          },
          "materials" : {
            "$ref" : "#/components/schemas/CompressibleFluidMaterials"
          },
          "initialConditions" : {
            "$ref" : "#/components/schemas/FluidInitialConditions"
          },
          "boundaryConditions" : {
            "title" : "Boundary conditions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_CompressibleBoundaryConditions"
            }
          },
          "advancedConcepts" : {
            "$ref" : "#/components/schemas/AdvancedConcepts"
          },
          "numerics" : {
            "$ref" : "#/components/schemas/FluidNumerics"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/FluidSimulationControl"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/FluidResultControls"
          }
        },
        "additionalProperties" : false
      },
      "CompressibleFluidMaterials" : {
        "type" : "object",
        "properties" : {
          "fluids" : {
            "title" : "Materials",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/FluidCompressibleMaterial"
            }
          }
        },
        "additionalProperties" : false
      },
      "ConvectiveHeatTransfer" : {
        "title" : "Convective Heat Transfer",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ConvectiveHeatTransfer",
            "default" : "CONVECTIVE_HEAT_TRANSFER"
          },
          "isCompressible" : {
            "title" : "Compressible",
            "type" : "boolean",
            "description" : "<ul><li>Toggle off <em>Compressible</em> for small temperature variations within the domain, for example, in natural convection simulations (Boussinesq approximation). Use Gauge pressure (0 Pa). </li><li>Toggle on <em>Compressible</em> to calculate resulting density variations within the domain based on pressure and temperature. Use Absolute pressure (for example, 101325 Pa at sea level)</li></ul>",
            "default" : false
          },
          "turbulenceModel" : {
            "title" : "Turbulence model",
            "type" : "string",
            "description" : "Choose a turbulence model for your CFD analysis:<ul><li><strong>No turbulence</strong>: Laminar</li><li><strong>RANS</strong>: <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-epsilon/' target='_blank'>k-epsilon</a>, <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-omega-sst/' target='_blank'>k-omega and k-omega SST</a></li><li><strong>LES</strong>: Smagorinsky, Spalart-Allmaras</li></ul><p><p><a href='https://www.simscale.com/blog/2017/12/turbulence-cfd-analysis/' target='_blank'>Learn more</a>.</p>",
            "default" : "KOMEGASST",
            "enum" : [ "SMAGORINSKY", "SPALARTALLMARAS", "NONE", "KEPSILON", "KOMEGASST" ]
          },
          "timeDependency" : {
            "$ref" : "#/components/schemas/OneOf_ConvectiveHeatTransferTimeDependency"
          },
          "enableRadiation" : {
            "title" : "Radiation",
            "type" : "boolean",
            "description" : "Heat transfer through radiation takes place in the form of electromagnetic waves and it can be calculated in the simulation. This phenomenon becomes more important when the temperatures involved in the simulation are large. <a href='https://www.simscale.com/docs/analysis-types/convective-heat-transfer-analysis/radiation/' target='_blank'>Learn more</a>.",
            "default" : false,
            "x-showWhen" : [ "timeDependency.type == STATIONARY" ]
          },
          "numOfPassiveSpecies" : {
            "title" : "Passive species",
            "maximum" : 10,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "Select the number of passive species involved in the simulation. Passive species allow you to simulate the transport of a scalar quantity within a fluid flow without affecting it. <a href='https://www.simscale.com/docs/simulation-setup/global-settings/#passive-species' target='_blank'>Learn more</a>.",
            "format" : "int64",
            "default" : 0,
            "enum" : [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
          },
          "model" : {
            "$ref" : "#/components/schemas/FluidModel"
          },
          "materials" : {
            "$ref" : "#/components/schemas/ConvectiveHeatTransferMaterials"
          },
          "initialConditions" : {
            "$ref" : "#/components/schemas/FluidInitialConditions"
          },
          "boundaryConditions" : {
            "title" : "Boundary conditions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_ConvectiveHeatTransferBoundaryConditions"
            }
          },
          "advancedConcepts" : {
            "$ref" : "#/components/schemas/AdvancedConcepts"
          },
          "numerics" : {
            "$ref" : "#/components/schemas/FluidNumerics"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/FluidSimulationControl"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/FluidResultControls"
          }
        },
        "additionalProperties" : false
      },
      "ConvectiveHeatTransferMaterials" : {
        "type" : "object",
        "properties" : {
          "fluids" : {
            "title" : "Materials",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_ConvectiveHeatTransferMaterialsFluids"
            }
          }
        },
        "additionalProperties" : false
      },
      "NaturalConvectionInletOutletBC" : {
        "title" : "Natural convection inlet/outlet",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>This boundary condition is suitable for an <b>open boundary</b> where the air can enter or exit freely from or to the <b>atmosphere<b>. <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/natural-convection-inlet-outlet/' target='_blank'>Learn more</a>.</P>\n\nSchema name: NaturalConvectionInletOutletBC",
            "default" : "NATURAL_CONVECTION_INLET_OUTLET"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "pressureRgh" : {
            "$ref" : "#/components/schemas/AmbientPBC"
          },
          "temperature" : {
            "$ref" : "#/components/schemas/AmbientTBC"
          },
          "netRadiativeHeatFlux" : {
            "$ref" : "#/components/schemas/OneOf_NaturalConvectionInletOutletBCNetRadiativeHeatFlux"
          },
          "radiativeIntensityRay" : {
            "$ref" : "#/components/schemas/OpenBoundaryRayBC"
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>This boundary condition is suitable for an <b>open boundary</b> where the air can enter or exit freely from or to the <b>atmosphere<b>. <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/natural-convection-inlet-outlet/' target='_blank'>Learn more</a>.</P>"
      },
      "AmbientPBC" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AmbientPBC",
            "default" : "AMBIENT_PRESSURE"
          },
          "ambientPressure" : {
            "$ref" : "#/components/schemas/Dimensional_Pressure"
          }
        },
        "additionalProperties" : false
      },
      "AmbientTBC" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AmbientTBC",
            "default" : "AMBIENT_TEMPERATURE"
          },
          "ambientTemperature" : {
            "$ref" : "#/components/schemas/Dimensional_Temperature"
          }
        },
        "additionalProperties" : false
      },
      "ConjugateHeatTransfer" : {
        "title" : "Conjugate Heat Transfer",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ConjugateHeatTransfer",
            "default" : "CONJUGATE_HEAT_TRANSFER"
          },
          "turbulenceModel" : {
            "title" : "Turbulence model",
            "type" : "string",
            "description" : "Choose a turbulence model for your CFD analysis:<ul><li><strong>No turbulence</strong>: Laminar</li><li><strong>RANS</strong>: <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-epsilon/' target='_blank'>k-epsilon</a>, <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-omega-sst/' target='_blank'>k-omega and k-omega SST</a></li><li><strong>LES</strong>: Smagorinsky, Spalart-Allmaras</li></ul><p><p><a href='https://www.simscale.com/blog/2017/12/turbulence-cfd-analysis/' target='_blank'>Learn more</a>.</p>",
            "default" : "KOMEGASST",
            "enum" : [ "SMAGORINSKY", "NONE", "KEPSILON", "KOMEGASST" ]
          },
          "timeDependency" : {
            "$ref" : "#/components/schemas/OneOf_ConjugateHeatTransferTimeDependency"
          },
          "enableRadiation" : {
            "title" : "Radiation",
            "type" : "boolean",
            "description" : "Heat transfer through radiation takes place in the form of electromagnetic waves and it can be calculated in the simulation. This phenomenon becomes more important when the temperatures involved in the simulation are large. <a href='https://www.simscale.com/docs/analysis-types/convective-heat-transfer-analysis/radiation/' target='_blank'>Learn more</a>.",
            "default" : false,
            "x-showWhen" : [ "timeDependency.type == STATIONARY" ]
          },
          "connectionGroups" : {
            "title" : "Connection groups",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/FluidInterface"
            }
          },
          "model" : {
            "$ref" : "#/components/schemas/FluidModel"
          },
          "materials" : {
            "$ref" : "#/components/schemas/ConjugateHeatTransferMaterials"
          },
          "initialConditions" : {
            "$ref" : "#/components/schemas/FluidInitialConditions"
          },
          "boundaryConditions" : {
            "title" : "Boundary conditions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_ConjugateHeatTransferBoundaryConditions"
            }
          },
          "advancedConcepts" : {
            "$ref" : "#/components/schemas/AdvancedConcepts"
          },
          "numerics" : {
            "$ref" : "#/components/schemas/FluidNumerics"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/FluidSimulationControl"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/FluidResultControls"
          },
          "contactHandlingMode" : {
            "title" : "Contact handling mode",
            "type" : "string",
            "default" : "MANUAL",
            "enum" : [ "MANUAL", "AUTO" ]
          }
        },
        "additionalProperties" : false
      },
      "FluidInterface" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FluidInterface",
            "default" : "FLUID_INTERFACE"
          },
          "connections" : {
            "title" : "Contacts",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RegionInterface"
            }
          }
        },
        "additionalProperties" : false
      },
      "RegionInterface" : {
        "title" : "Standard interface",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: RegionInterface",
            "default" : "REGION_INTERFACE"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "interfaceThermal" : {
            "$ref" : "#/components/schemas/OneOf_RegionInterfaceInterfaceThermal"
          },
          "masterTopologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "slaveTopologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "isPartial" : {
            "title" : "Is partial",
            "type" : "boolean",
            "default" : false
          },
          "customModified" : {
            "title" : "Custom modified",
            "type" : "boolean",
            "default" : false
          }
        },
        "additionalProperties" : false
      },
      "CoupledInterfaceThermal" : {
        "title" : "Coupled interface",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CoupledInterfaceThermal",
            "default" : "COUPLED"
          }
        },
        "additionalProperties" : false
      },
      "AdiabaticInterfaceThermal" : {
        "title" : "Adiabatic interface",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: AdiabaticInterfaceThermal",
            "default" : "ADIABATIC"
          }
        },
        "additionalProperties" : false
      },
      "TotalResistanceInterfaceThermal" : {
        "title" : "Total resistance interface",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TotalResistanceInterfaceThermal",
            "default" : "TOTAL_RESISTANCE"
          },
          "contactResistance" : {
            "$ref" : "#/components/schemas/Dimensional_ContactResistance"
          }
        },
        "additionalProperties" : false
      },
      "SpecificConductanceInterfaceThermal" : {
        "title" : "Specific conductance interface",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: SpecificConductanceInterfaceThermal",
            "default" : "SPECIFIC_CONDUCTANCE"
          },
          "contactConductance" : {
            "$ref" : "#/components/schemas/Dimensional_ThermalTransmittance"
          }
        },
        "additionalProperties" : false
      },
      "ContactInterfaceMaterialInterfaceThermal" : {
        "title" : "Thin layer resistance interface",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: ContactInterfaceMaterialInterfaceThermal",
            "default" : "CONTACT_INTERFACE_MATERIAL"
          },
          "conductivityThicknessPairs" : {
            "title" : "Conductivity thickness pairs",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ConductivityThicknessPair"
            }
          }
        },
        "additionalProperties" : false
      },
      "ConjugateHeatTransferMaterials" : {
        "type" : "object",
        "properties" : {
          "fluids" : {
            "title" : "Fluids",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/FluidCompressibleMaterial"
            }
          },
          "solids" : {
            "title" : "Solids",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SolidCompressibleMaterial"
            }
          }
        },
        "additionalProperties" : false
      },
      "SolidCompressibleMaterial" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "specie" : {
            "$ref" : "#/components/schemas/SpecieDefault"
          },
          "transport" : {
            "$ref" : "#/components/schemas/OneOf_SolidCompressibleMaterialTransport"
          },
          "emissivity" : {
            "title" : "Emissivity",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.9,
            "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER && enableRadiation == true", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableRadiation == true" ]
          },
          "topologicalReference" : {
            "$ref" : "#/components/schemas/TopologicalReference"
          },
          "builtInMaterial" : {
            "type" : "string"
          },
          "materialLibraryReference" : {
            "$ref" : "#/components/schemas/MaterialLibraryReference"
          }
        },
        "additionalProperties" : false
      },
      "ConstIsoTransport" : {
        "title" : "Isotropic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>The thermal conductivity of a material is a measure of its ability to conduct heat.<ul><li><strong>Isotropic</strong>: the thermal conductivity &kappa; is the same in all directions.</li><li><strong>Orthotropic</strong>: the thermal conductivity is unique and independent in three orthogonal directions. It is defined by &kappa;<sub>x</sub>, &kappa;<sub>y</sub>, and &kappa;<sub>z</sub>.</li><li><strong>Cross-plane orthotropic</strong>: it is defined by an <em>in-plane</em> conductivity, which is an isotropic conductivity on a given plane, and a <em>cross-plane<strong>&nbsp;</strong></em>conductivity, which acts in the direction normal to the aforementioned plane.</li></ul></p>\n\nSchema name: ConstIsoTransport",
            "default" : "CONST_ISO"
          },
          "conductivity" : {
            "$ref" : "#/components/schemas/IsotropicConductivity"
          },
          "thermo" : {
            "$ref" : "#/components/schemas/HConstThermo"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>The thermal conductivity of a material is a measure of its ability to conduct heat.<ul><li><strong>Isotropic</strong>: the thermal conductivity &kappa; is the same in all directions.</li><li><strong>Orthotropic</strong>: the thermal conductivity is unique and independent in three orthogonal directions. It is defined by &kappa;<sub>x</sub>, &kappa;<sub>y</sub>, and &kappa;<sub>z</sub>.</li><li><strong>Cross-plane orthotropic</strong>: it is defined by an <em>in-plane</em> conductivity, which is an isotropic conductivity on a given plane, and a <em>cross-plane<strong>&nbsp;</strong></em>conductivity, which acts in the direction normal to the aforementioned plane.</li></ul></p>"
      },
      "ConstAnIsoTransport" : {
        "title" : "Orthotropic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>The thermal conductivity of a material is a measure of its ability to conduct heat.<ul><li><strong>Isotropic</strong>: the thermal conductivity &kappa; is the same in all directions.</li><li><strong>Orthotropic</strong>: the thermal conductivity is unique and independent in three orthogonal directions. It is defined by &kappa;<sub>x</sub>, &kappa;<sub>y</sub>, and &kappa;<sub>z</sub>.</li><li><strong>Cross-plane orthotropic</strong>: it is defined by an <em>in-plane</em> conductivity, which is an isotropic conductivity on a given plane, and a <em>cross-plane<strong>&nbsp;</strong></em>conductivity, which acts in the direction normal to the aforementioned plane.</li></ul></p>\n\nSchema name: ConstAnIsoTransport",
            "default" : "CONST_AN_ISO"
          },
          "conductivity" : {
            "$ref" : "#/components/schemas/OrthotropicConductivity"
          },
          "orientation" : {
            "$ref" : "#/components/schemas/OneOf_ConstAnIsoTransportOrientation"
          },
          "thermo" : {
            "$ref" : "#/components/schemas/HConstThermo"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>The thermal conductivity of a material is a measure of its ability to conduct heat.<ul><li><strong>Isotropic</strong>: the thermal conductivity &kappa; is the same in all directions.</li><li><strong>Orthotropic</strong>: the thermal conductivity is unique and independent in three orthogonal directions. It is defined by &kappa;<sub>x</sub>, &kappa;<sub>y</sub>, and &kappa;<sub>z</sub>.</li><li><strong>Cross-plane orthotropic</strong>: it is defined by an <em>in-plane</em> conductivity, which is an isotropic conductivity on a given plane, and a <em>cross-plane<strong>&nbsp;</strong></em>conductivity, which acts in the direction normal to the aforementioned plane.</li></ul></p>"
      },
      "ConstCrossPlaneOrthotropicTransport" : {
        "title" : "Cross-plane orthotropic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p>The thermal conductivity of a material is a measure of its ability to conduct heat.<ul><li><strong>Isotropic</strong>: the thermal conductivity &kappa; is the same in all directions.</li><li><strong>Orthotropic</strong>: the thermal conductivity is unique and independent in three orthogonal directions. It is defined by &kappa;<sub>x</sub>, &kappa;<sub>y</sub>, and &kappa;<sub>z</sub>.</li><li><strong>Cross-plane orthotropic</strong>: it is defined by an <em>in-plane</em> conductivity, which is an isotropic conductivity on a given plane, and a <em>cross-plane<strong>&nbsp;</strong></em>conductivity, which acts in the direction normal to the aforementioned plane.</li></ul></p>\n\nSchema name: ConstCrossPlaneOrthotropicTransport",
            "default" : "CONST_CROSS_PLANE_ORTHO"
          },
          "conductivity" : {
            "$ref" : "#/components/schemas/CrossPlaneOrthotropicConductivity"
          },
          "orientation" : {
            "$ref" : "#/components/schemas/OneOf_ConstCrossPlaneOrthotropicTransportOrientation"
          },
          "thermo" : {
            "$ref" : "#/components/schemas/HConstThermo"
          }
        },
        "additionalProperties" : false,
        "description" : "<p>The thermal conductivity of a material is a measure of its ability to conduct heat.<ul><li><strong>Isotropic</strong>: the thermal conductivity &kappa; is the same in all directions.</li><li><strong>Orthotropic</strong>: the thermal conductivity is unique and independent in three orthogonal directions. It is defined by &kappa;<sub>x</sub>, &kappa;<sub>y</sub>, and &kappa;<sub>z</sub>.</li><li><strong>Cross-plane orthotropic</strong>: it is defined by an <em>in-plane</em> conductivity, which is an isotropic conductivity on a given plane, and a <em>cross-plane<strong>&nbsp;</strong></em>conductivity, which acts in the direction normal to the aforementioned plane.</li></ul></p>"
      },
      "CrossPlaneOrthotropicConductivity" : {
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CrossPlaneOrthotropicConductivity",
            "default" : "CROSS_PLANE_ORTHOTROPIC"
          },
          "inPlaneConductivity" : {
            "$ref" : "#/components/schemas/DimensionalFunction_ThermalConductivity"
          },
          "crossPlaneConductivity" : {
            "$ref" : "#/components/schemas/DimensionalFunction_ThermalConductivity"
          }
        },
        "additionalProperties" : false
      },
      "CrossPlaneCustomOrientation" : {
        "title" : "Custom",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CrossPlaneCustomOrientation",
            "default" : "CROSS_PLANE"
          },
          "crossPlaneOrientation" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          }
        },
        "additionalProperties" : false
      },
      "CoupledConjugateHeatTransfer" : {
        "title" : "Conjugate Heat Transfer v2.0",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CoupledConjugateHeatTransfer",
            "default" : "COUPLED_CONJUGATE_HEAT_TRANSFER"
          },
          "isCompressible" : {
            "title" : "Compressible",
            "type" : "boolean",
            "description" : "<ul><li>Toggle off <em>Compressible</em> for small temperature variations within the domain, for example, in natural convection simulations (Boussinesq approximation). Use Gauge pressure (0 Pa). </li><li>Toggle on <em>Compressible</em> to calculate resulting density variations within the domain based on pressure and temperature. Use Absolute pressure (for example, 101325 Pa at sea level)</li></ul>",
            "default" : false
          },
          "enableRadiation" : {
            "title" : "Radiation",
            "type" : "boolean",
            "description" : "Heat transfer through radiation takes place in the form of electromagnetic waves and it can be calculated in the simulation. This phenomenon becomes more important when the temperatures involved in the simulation are large. <a href='https://www.simscale.com/docs/analysis-types/convective-heat-transfer-analysis/radiation/' target='_blank'>Learn more</a>.",
            "default" : false
          },
          "enableSolarLoad" : {
            "title" : "Solar Load",
            "type" : "boolean",
            "description" : "<b>Solar load</b> on boundary patches. It heats boundaries externally or, if solar rays enter the domain through transparent or semi-transparent boundaries, it heats boundaries also internally. Sun direction and solar load model are defined in the <b>Solar calculator</b>. <ul><li>It can also be combined with surface to surface radiation.</li><li>It can only be used with convective heat transfer.</li><li>Reflecting rays are not taken into account.</li></ul> <a href='https://www.simscale.com/docs/analysis-types/conjugate-heat-transfer-analysis/solar-load/' target='_blank'>Learn more</a>.",
            "default" : false
          },
          "turbulenceModel" : {
            "title" : "Turbulence model",
            "type" : "string",
            "description" : "Choose a turbulence model for your CFD analysis:<ul><li><strong>No turbulence</strong>: Laminar</li><li><strong>RANS</strong>: <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-epsilon/' target='_blank'>k-epsilon</a>, <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-omega-sst/' target='_blank'>k-omega and k-omega SST</a></li><li><strong>LES</strong>: Smagorinsky, Spalart-Allmaras</li></ul><p><p><a href='https://www.simscale.com/blog/2017/12/turbulence-cfd-analysis/' target='_blank'>Learn more</a>.</p>",
            "default" : "KOMEGASST",
            "enum" : [ "NONE", "KOMEGASST" ]
          },
          "numOfPassiveSpecies" : {
            "title" : "Passive species",
            "maximum" : 9,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "Select the number of passive species involved in the simulation. Passive species allow you to simulate the transport of a scalar quantity within a fluid flow without affecting it. <a href='https://www.simscale.com/docs/simulation-setup/global-settings/#passive-species' target='_blank'>Learn more</a>.",
            "format" : "int64",
            "default" : 0,
            "enum" : [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
          },
          "connectionGroups" : {
            "title" : "Connection groups",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/FluidInterface"
            }
          },
          "model" : {
            "$ref" : "#/components/schemas/FluidModel"
          },
          "solarCalculator" : {
            "$ref" : "#/components/schemas/SolarCalculator"
          },
          "materials" : {
            "$ref" : "#/components/schemas/CoupledConjugateHeatTransferMaterials"
          },
          "initialConditions" : {
            "$ref" : "#/components/schemas/FluidInitialConditions"
          },
          "boundaryConditions" : {
            "title" : "Boundary conditions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_CoupledConjugateHeatTransferBoundaryConditions"
            }
          },
          "advancedConcepts" : {
            "$ref" : "#/components/schemas/AdvancedConcepts"
          },
          "numerics" : {
            "$ref" : "#/components/schemas/FluidNumerics"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/FluidSimulationControl"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/FluidResultControls"
          },
          "contactHandlingMode" : {
            "title" : "Contact handling mode",
            "type" : "string",
            "default" : "MANUAL",
            "enum" : [ "MANUAL", "AUTO" ]
          }
        },
        "additionalProperties" : false
      },
      "SolarCalculator" : {
        "type" : "object",
        "properties" : {
          "sunDirection" : {
            "$ref" : "#/components/schemas/OneOf_SolarCalculatorSunDirection"
          },
          "solarLoad" : {
            "$ref" : "#/components/schemas/OneOf_SolarCalculatorSolarLoad"
          }
        },
        "additionalProperties" : false
      },
      "TimeAndPlaceSunDirection" : {
        "title" : "Time and place",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: TimeAndPlaceSunDirection",
            "default" : "TIME_AND_PLACE"
          },
          "northAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          },
          "geographicalLocation" : {
            "$ref" : "#/components/schemas/GeographicalLocation"
          },
          "localDateTime" : {
            "title" : "Date and time",
            "type" : "string",
            "format" : "datetime-local"
          }
        },
        "additionalProperties" : false
      },
      "CustomSunDirection" : {
        "title" : "Custom",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CustomSunDirection",
            "default" : "CUSTOM_SOLAR_DIRECTION"
          },
          "sunDirectionVector" : {
            "$ref" : "#/components/schemas/DimensionalVector_Length"
          }
        },
        "additionalProperties" : false
      },
      "CustomSolarLoad" : {
        "title" : "Custom",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: CustomSolarLoad",
            "default" : "CUSTOM_SOLAR_LOAD"
          },
          "directSolarLoad" : {
            "$ref" : "#/components/schemas/Dimensional_HeatFlux"
          },
          "diffuseSolarLoad" : {
            "$ref" : "#/components/schemas/Dimensional_HeatFlux"
          }
        },
        "additionalProperties" : false
      },
      "FairWeatherConditions" : {
        "title" : "Fair Weather Conditions",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FairWeatherConditions",
            "default" : "FAIR_WEATHER_CONDITIONS"
          },
          "skyCloudCoverFraction" : {
            "title" : "Sky cloud cover fraction",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0
          },
          "groundReflectivity" : {
            "title" : "Ground reflectivity",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "default" : 0.2
          },
          "apparentSolarIrradiation" : {
            "$ref" : "#/components/schemas/Dimensional_HeatFlux"
          },
          "atmosphericExtinctionCoefficient" : {
            "title" : "Atmospheric extinction",
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "Atmospheric extinction coefficient (B)",
            "default" : 0.142
          },
          "diffuseRadiationFactor" : {
            "title" : "Diffuse radiation factor",
            "maximum" : 1,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "Diffuse radiation factor (C)",
            "default" : 0.058
          }
        },
        "additionalProperties" : false
      },
      "CoupledConjugateHeatTransferMaterials" : {
        "type" : "object",
        "properties" : {
          "fluids" : {
            "title" : "Fluid",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_CoupledConjugateHeatTransferMaterialsFluids"
            }
          },
          "solids" : {
            "title" : "Solids",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SolidCompressibleMaterial"
            }
          }
        },
        "additionalProperties" : false
      },
      "EmbeddedBoundary" : {
        "title" : "Immersed Boundary",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: EmbeddedBoundary",
            "default" : "EMBEDDED_BOUNDARY"
          },
          "isInternalFlow" : {
            "title" : "Internal flow",
            "type" : "boolean",
            "description" : "If active it indicates that the fluid region is contained within the uploaded geometry.",
            "default" : false
          },
          "model" : {
            "$ref" : "#/components/schemas/FluidModel"
          },
          "materials" : {
            "$ref" : "#/components/schemas/CoupledConjugateHeatTransferMaterials"
          },
          "initialConditions" : {
            "$ref" : "#/components/schemas/FluidInitialConditions"
          },
          "boundaryConditions" : {
            "title" : "Boundary conditions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_EmbeddedBoundaryBoundaryConditions"
            },
            "x-showWhen" : [ "isInternalFlow == true" ]
          },
          "advancedConcepts" : {
            "$ref" : "#/components/schemas/AdvancedConcepts"
          },
          "numerics" : {
            "$ref" : "#/components/schemas/FluidNumerics"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/FluidSimulationControl"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/FluidResultControls"
          },
          "meshSettings" : {
            "$ref" : "#/components/schemas/BasicEmbeddedBoundaryMeshing"
          },
          "isCompressible" : {
            "title" : "Compressible",
            "type" : "boolean",
            "description" : "<ul><li>Toggle off <em>Compressible</em> for small temperature variations within the domain, for example, in natural convection simulations (Boussinesq approximation). Use Gauge pressure (0 Pa). </li><li>Toggle on <em>Compressible</em> to calculate resulting density variations within the domain based on pressure and temperature. Use Absolute pressure (for example, 101325 Pa at sea level)</li></ul>",
            "default" : false
          },
          "enableRadiation" : {
            "title" : "Radiation",
            "type" : "boolean",
            "description" : "Heat transfer through radiation takes place in the form of electromagnetic waves and it can be calculated in the simulation. This phenomenon becomes more important when the temperatures involved in the simulation are large. <a href='https://www.simscale.com/docs/analysis-types/convective-heat-transfer-analysis/radiation/' target='_blank'>Learn more</a>.",
            "default" : false
          },
          "turbulenceModel" : {
            "title" : "Turbulence model",
            "type" : "string",
            "description" : "Choose a turbulence model for your CFD analysis:<ul><li><strong>No turbulence</strong>: Laminar</li><li><strong>RANS</strong>: <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-epsilon/' target='_blank'>k-epsilon</a>, <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-omega-sst/' target='_blank'>k-omega and k-omega SST</a></li><li><strong>LES</strong>: Smagorinsky, Spalart-Allmaras</li></ul><p><p><a href='https://www.simscale.com/blog/2017/12/turbulence-cfd-analysis/' target='_blank'>Learn more</a>.</p>",
            "default" : "KOMEGASST",
            "enum" : [ "NONE", "KOMEGASST" ]
          }
        },
        "additionalProperties" : false
      },
      "BasicEmbeddedBoundaryMeshing" : {
        "title" : "Basic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: BasicEmbeddedBoundaryMeshing",
            "default" : "BASIC_MESH_SETTINGS"
          },
          "numCellsPerDirection" : {
            "$ref" : "#/components/schemas/NumberOfCellsPerDirection"
          },
          "refinementStrategy" : {
            "$ref" : "#/components/schemas/OneOf_BasicEmbeddedBoundaryMeshingRefinementStrategy"
          },
          "numRefinementLevels" : {
            "title" : "Number of refinement levels",
            "maximum" : 10,
            "exclusiveMaximum" : false,
            "minimum" : 0,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "Number of refinement levels to refine in the vicinity of all CAD surfaces.",
            "default" : 2
          }
        },
        "additionalProperties" : false
      },
      "NumberOfCellsPerDirection" : {
        "title" : "Number of cells",
        "type" : "object",
        "properties" : {
          "x" : {
            "title" : "X",
            "maximum" : 600,
            "exclusiveMaximum" : false,
            "minimum" : 10,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 40
          },
          "y" : {
            "title" : "Y",
            "maximum" : 600,
            "exclusiveMaximum" : false,
            "minimum" : 10,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 40
          },
          "z" : {
            "title" : "Z",
            "maximum" : 600,
            "exclusiveMaximum" : false,
            "minimum" : 10,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "default" : 40
          }
        },
        "additionalProperties" : false
      },
      "EmbeddedNumberOfCellsRefinement" : {
        "title" : "Refinement propagation layers",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: EmbeddedNumberOfCellsRefinement",
            "default" : "LAYER_REFINEMENT"
          },
          "refinementControl" : {
            "title" : "Refinement control",
            "maximum" : 10,
            "exclusiveMaximum" : false,
            "minimum" : 1,
            "exclusiveMinimum" : false,
            "type" : "integer",
            "description" : "Number of cell layers up to which the mesh refinement propagates.",
            "default" : 1
          }
        },
        "additionalProperties" : false
      },
      "EmbeddedDistanceRefinement" : {
        "title" : "Distance from surface",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: EmbeddedDistanceRefinement",
            "default" : "DISTANCE_REFINEMENT"
          },
          "refinementControl" : {
            "$ref" : "#/components/schemas/Dimensional_Length"
          }
        },
        "additionalProperties" : false
      },
      "Multiphase" : {
        "title" : "Multiphase",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: Multiphase",
            "default" : "MULTIPHASE"
          },
          "useLocalTimeStepping" : {
            "title" : "Use local time stepping",
            "type" : "boolean",
            "description" : "With the <i>Local time stepping</i> option enabled, its possible to accelerate the simulation towards a steady-state. As a result, faster computing times and smaller result data size. Commonly used in ship hull resistance analysis.",
            "default" : false
          },
          "turbulenceModel" : {
            "title" : "Turbulence model",
            "type" : "string",
            "description" : "Choose a turbulence model for your CFD analysis:<ul><li><strong>No turbulence</strong>: Laminar</li><li><strong>RANS</strong>: <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-epsilon/' target='_blank'>k-epsilon</a>, <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-omega-sst/' target='_blank'>k-omega and k-omega SST</a></li><li><strong>LES</strong>: Smagorinsky, Spalart-Allmaras</li></ul><p><p><a href='https://www.simscale.com/blog/2017/12/turbulence-cfd-analysis/' target='_blank'>Learn more</a>.</p>",
            "default" : "KOMEGASST",
            "enum" : [ "SMAGORINSKY", "SPALARTALLMARAS", "NONE", "KEPSILON", "KOMEGA", "KOMEGASST" ]
          },
          "model" : {
            "$ref" : "#/components/schemas/FluidModel"
          },
          "materials" : {
            "$ref" : "#/components/schemas/IncompressibleFluidMaterials"
          },
          "initialConditions" : {
            "$ref" : "#/components/schemas/FluidInitialConditions"
          },
          "boundaryConditions" : {
            "title" : "Boundary conditions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_MultiphaseBoundaryConditions"
            }
          },
          "advancedConcepts" : {
            "$ref" : "#/components/schemas/AdvancedConcepts"
          },
          "numerics" : {
            "$ref" : "#/components/schemas/FluidNumerics"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/FluidSimulationControl"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/FluidResultControls"
          }
        },
        "additionalProperties" : false
      },
      "HarmonicAnalysis" : {
        "title" : "Harmonic",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: HarmonicAnalysis",
            "default" : "HARMONIC_ANALYSIS"
          },
          "connectionGroups" : {
            "title" : "Connection groups",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/Contact"
            }
          },
          "elementTechnology" : {
            "$ref" : "#/components/schemas/SolidElementTechnology"
          },
          "model" : {
            "$ref" : "#/components/schemas/SolidModel"
          },
          "materials" : {
            "title" : "Materials",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SolidMaterial"
            }
          },
          "initialConditions" : {
            "$ref" : "#/components/schemas/SolidInitialConditions"
          },
          "boundaryConditions" : {
            "title" : "Boundary conditions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_HarmonicAnalysisBoundaryConditions"
            }
          },
          "numerics" : {
            "$ref" : "#/components/schemas/SolidNumerics"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/SolidSimulationControl"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/SolidResultControl"
          },
          "meshOrder" : {
            "title" : "Mesh order",
            "type" : "string",
            "default" : "NONE",
            "enum" : [ "FIRST", "SECOND", "NONE" ]
          }
        },
        "additionalProperties" : false
      },
      "BaseExcitationBC" : {
        "title" : "Base excitation",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "<p><b>Base excitation</b> boundary condition applies a uniform acceleration to all fixed surfaces in the model (zero displacement), e.g. faces assigned to the <i>Fixed support</i> boundary condition. Specify the direction vector, the acceleration magnitude and the delay in terms of a harmonic phase angle, from the load to the reference harmonic excitation.<a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/base-excitation/' target='_blank'>Learn more</a></p>\n\nSchema name: BaseExcitationBC",
            "default" : "BASE_EXCITATION"
          },
          "name" : {
            "title" : "Name",
            "type" : "string"
          },
          "direction" : {
            "$ref" : "#/components/schemas/DimensionalVector_Dimensionless"
          },
          "acceleration" : {
            "$ref" : "#/components/schemas/DimensionalFunction_Acceleration"
          },
          "phaseAngle" : {
            "$ref" : "#/components/schemas/Dimensional_Angle"
          }
        },
        "additionalProperties" : false,
        "description" : "<p><b>Base excitation</b> boundary condition applies a uniform acceleration to all fixed surfaces in the model (zero displacement), e.g. faces assigned to the <i>Fixed support</i> boundary condition. Specify the direction vector, the acceleration magnitude and the delay in terms of a harmonic phase angle, from the load to the reference harmonic excitation.<a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/base-excitation/' target='_blank'>Learn more</a></p>"
      },
      "FrequencyAnalysis" : {
        "title" : "Frequency Analysis",
        "required" : [ "type" ],
        "type" : "object",
        "properties" : {
          "type" : {
            "title" : "Type",
            "type" : "string",
            "description" : "Schema name: FrequencyAnalysis",
            "default" : "FREQUENCY_ANALYSIS"
          },
          "connectionGroups" : {
            "title" : "Connection groups",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/Contact"
            }
          },
          "elementTechnology" : {
            "$ref" : "#/components/schemas/SolidElementTechnology"
          },
          "model" : {
            "$ref" : "#/components/schemas/SolidModel"
          },
          "materials" : {
            "title" : "Materials",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SolidMaterial"
            }
          },
          "initialConditions" : {
            "$ref" : "#/components/schemas/SolidInitialConditions"
          },
          "boundaryConditions" : {
            "title" : "Boundary conditions",
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OneOf_FrequencyAnalysisBoundaryConditions"
            }
          },
          "numerics" : {
            "$ref" : "#/components/schemas/SolidNumerics"
          },
          "simulationControl" : {
            "$ref" : "#/components/schemas/SolidSimulationControl"
          },
          "resultControl" : {
            "$ref" : "#/components/schemas/SolidResultControl"
          },
          "meshOrder" : {
            "title" : "Mesh order",
            "type" : "string",
            "default" : "FIRST",
            "enum" : [ "FIRST", "SECOND", "NONE" ]
          }
        },
        "additionalProperties" : false
      },
      "OneOf_GeneralDarcyForchheimerPacefishDarcyForchheimerType" : {
        "title" : "Permeability type",
        "description" : "The type of Darcy-Forchheimer porous object defines its directional behaviour.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ISOTROPIC" : "#/components/schemas/IsotropicDarcyForchheimer",
            "RECTIFYING" : "#/components/schemas/RectifyingDarcyForchheimer"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/IsotropicDarcyForchheimer"
        }, {
          "$ref" : "#/components/schemas/RectifyingDarcyForchheimer"
        } ]
      },
      "OneOf_DimensionalFunction_PressureValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_DimensionalFunction_VolumetricPowerValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_TrueSemiImplicitSolver" : {
        "title" : "Solver",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ]
      },
      "OneOf_DimensionalFunction_ThermalExpansionRateValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_DimensionalFunction_SpecificTurbulenceDissipationRateValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_AdvancedConceptsRotatingZones" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ARBITRARY_MESH_INTERFACE" : "#/components/schemas/AMIRotatingZone",
            "MULTI_REFERENCE_FRAME" : "#/components/schemas/MRFRotatingZone"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AMIRotatingZone"
        }, {
          "$ref" : "#/components/schemas/MRFRotatingZone"
        } ]
      },
      "OneOf_AdvancedConceptsPorousMediums" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "DARCY_FORCHHEIMER" : "#/components/schemas/DarcyForchheimerMedium",
            "FIXED_COEFFICIENTS" : "#/components/schemas/FixedCoeffMedium",
            "POWER_LAW" : "#/components/schemas/PowerLawMedium",
            "PRESSURE_LOSS_CURVE" : "#/components/schemas/PressureLossCurve",
            "PERFORATED_PLATE" : "#/components/schemas/PerforatedPlate"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/DarcyForchheimerMedium"
        }, {
          "$ref" : "#/components/schemas/FixedCoeffMedium"
        }, {
          "$ref" : "#/components/schemas/PowerLawMedium"
        }, {
          "$ref" : "#/components/schemas/PressureLossCurve"
        }, {
          "$ref" : "#/components/schemas/PerforatedPlate"
        } ]
      },
      "OneOf_AdvancedConceptsSolidBodyMotions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "LINEAR_MOTION" : "#/components/schemas/LinearSBM",
            "OSCILLATING_ROTATING_MOTION" : "#/components/schemas/OscillatingRotatingSBM",
            "OSCILLATING_LINEAR_MOTION" : "#/components/schemas/OscillatingLinearSBM",
            "ROTATING_MOTION" : "#/components/schemas/RotatingSBM",
            "SHIP_DESIGN_ANALYSIS" : "#/components/schemas/ShipDesignAnalysisSBM"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/LinearSBM"
        }, {
          "$ref" : "#/components/schemas/OscillatingRotatingSBM"
        }, {
          "$ref" : "#/components/schemas/OscillatingLinearSBM"
        }, {
          "$ref" : "#/components/schemas/RotatingSBM"
        }, {
          "$ref" : "#/components/schemas/ShipDesignAnalysisSBM"
        } ]
      },
      "OneOf_AdvancedConceptsPowerSources" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ABSOLUTE_V23" : "#/components/schemas/AbsolutePowerSource",
            "SPECIFIC_V23" : "#/components/schemas/SpecificPowerSource"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AbsolutePowerSource"
        }, {
          "$ref" : "#/components/schemas/SpecificPowerSource"
        } ]
      },
      "OneOf_AdvancedConceptsMomentumSources" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AVERAGE_VELOCITY" : "#/components/schemas/AverageVelocityMomentumSource",
            "FAN_PRESSURE_DROP" : "#/components/schemas/FanPressureDropMomentumSource"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AverageVelocityMomentumSource"
        }, {
          "$ref" : "#/components/schemas/FanPressureDropMomentumSource"
        } ]
      },
      "OneOf_AdvancedConceptsPassiveScalarSources" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ABSOLUTE" : "#/components/schemas/AbsolutePassiveScalarSource",
            "SPECIFIC" : "#/components/schemas/SpecificPassiveScalarSource"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AbsolutePassiveScalarSource"
        }, {
          "$ref" : "#/components/schemas/SpecificPassiveScalarSource"
        } ]
      },
      "OneOf_AdvancedConceptsThermalResistanceNetworks" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "STAR_NETWORK" : "#/components/schemas/StarThermalResistanceNetwork",
            "TWO_RESISTOR_NETWORK" : "#/components/schemas/TwoResistorNetwork"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/StarThermalResistanceNetwork"
        }, {
          "$ref" : "#/components/schemas/TwoResistorNetwork"
        } ]
      },
      "OneOf_EmbeddedBoundaryBoundaryConditions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VELOCITY_INLET_V3" : "#/components/schemas/VelocityInletBC",
            "PRESSURE_OUTLET_V30" : "#/components/schemas/PressureOutletBC",
            "WALL_V34" : "#/components/schemas/WallBC",
            "FAN" : "#/components/schemas/FanBC",
            "NATURAL_CONVECTION_INLET_OUTLET" : "#/components/schemas/NaturalConvectionInletOutletBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/VelocityInletBC"
        }, {
          "$ref" : "#/components/schemas/PressureOutletBC"
        }, {
          "$ref" : "#/components/schemas/WallBC"
        }, {
          "$ref" : "#/components/schemas/FanBC"
        }, {
          "$ref" : "#/components/schemas/NaturalConvectionInletOutletBC"
        } ]
      },
      "OneOf_SutherlandTransportThermo" : {
        "title" : "Thermo",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ECONST" : "#/components/schemas/EConstThermo",
            "HCONST" : "#/components/schemas/HConstThermo"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/EConstThermo"
        }, {
          "$ref" : "#/components/schemas/HConstThermo"
        } ]
      },
      "OneOf_SurfaceNormalGradientSchemesForDefault" : {
        "title" : "Default",
        "description" : "<p>A surface normal gradient is the component, normal to the face, of the gradient of values at the centres of the 2 cells connected through that face. Choose your desired scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CORRECTED" : "#/components/schemas/CorrectedSurfaceNormalGradientScheme",
            "UNCORRECTED" : "#/components/schemas/UncorrectedSurfaceNormalGradientScheme",
            "LIMITED" : "#/components/schemas/LimitedSurfaceNormalGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CorrectedSurfaceNormalGradientScheme"
        }, {
          "$ref" : "#/components/schemas/UncorrectedSurfaceNormalGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LimitedSurfaceNormalGradientScheme"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE]" ]
      },
      "OneOf_SurfaceNormalGradientSchemesSurfaceNormalGradient_rho" : {
        "title" : "snGrad(rho)",
        "description" : "<p>A surface normal gradient is the component, normal to the face, of the gradient of values at the centres of the 2 cells connected through that face. Choose your desired scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CORRECTED" : "#/components/schemas/CorrectedSurfaceNormalGradientScheme",
            "UNCORRECTED" : "#/components/schemas/UncorrectedSurfaceNormalGradientScheme",
            "LIMITED" : "#/components/schemas/LimitedSurfaceNormalGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CorrectedSurfaceNormalGradientScheme"
        }, {
          "$ref" : "#/components/schemas/UncorrectedSurfaceNormalGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LimitedSurfaceNormalGradientScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_SurfaceNormalGradientSchemesSurfaceNormalGradient_pressureRgh" : {
        "title" : "snGrad(p_rgh)",
        "description" : "<p>A surface normal gradient is the component, normal to the face, of the gradient of values at the centres of the 2 cells connected through that face. Choose your desired scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CORRECTED" : "#/components/schemas/CorrectedSurfaceNormalGradientScheme",
            "UNCORRECTED" : "#/components/schemas/UncorrectedSurfaceNormalGradientScheme",
            "LIMITED" : "#/components/schemas/LimitedSurfaceNormalGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CorrectedSurfaceNormalGradientScheme"
        }, {
          "$ref" : "#/components/schemas/UncorrectedSurfaceNormalGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LimitedSurfaceNormalGradientScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS,NONE,KEPSILON,KOMEGASST] && isCompressible == false" ]
      },
      "OneOf_SurfaceNormalGradientSchemesSurfaceNormalGradient_rhok" : {
        "title" : "snGrad(rhok)",
        "description" : "<p>A surface normal gradient is the component, normal to the face, of the gradient of values at the centres of the 2 cells connected through that face. Choose your desired scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CORRECTED" : "#/components/schemas/CorrectedSurfaceNormalGradientScheme",
            "UNCORRECTED" : "#/components/schemas/UncorrectedSurfaceNormalGradientScheme",
            "LIMITED" : "#/components/schemas/LimitedSurfaceNormalGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CorrectedSurfaceNormalGradientScheme"
        }, {
          "$ref" : "#/components/schemas/UncorrectedSurfaceNormalGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LimitedSurfaceNormalGradientScheme"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS,NONE,KEPSILON,KOMEGASST] && isCompressible == false" ]
      },
      "OneOf_ErrorRetimingEventTimestepCalculationType" : {
        "title" : "Time step calculation",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NEWTON_ITERATION" : "#/components/schemas/NewtonIterationTimestepCalculationType",
            "MANUAL" : "#/components/schemas/ManualTimestepCalculationType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NewtonIterationTimestepCalculationType"
        }, {
          "$ref" : "#/components/schemas/ManualTimestepCalculationType"
        } ]
      },
      "OneOf_RestrictedDimensionalFunction_TimeValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "RESTRICTED_TABLE_DEFINED" : "#/components/schemas/RestrictedTableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/RestrictedTableDefinedFunction"
        } ]
      },
      "OneOf_SurfaceRefinementWindComfortNewFineness" : {
        "title" : "Fineness",
        "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VERY_COARSE" : "#/components/schemas/PacefishFinenessVeryCoarse",
            "COARSE" : "#/components/schemas/PacefishFinenessCoarse",
            "MODERATE" : "#/components/schemas/PacefishFinenessModerate",
            "FINE" : "#/components/schemas/PacefishFinenessFine",
            "VERY_FINE" : "#/components/schemas/PacefishFinenessVeryFine",
            "TARGET_SIZE" : "#/components/schemas/PacefishFinenessTargetSize"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PacefishFinenessVeryCoarse"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessCoarse"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessModerate"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessFine"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessVeryFine"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessTargetSize"
        } ]
      },
      "OneOf_AverageFieldsCalculationResultControlItemFieldSelection" : {
        "title" : "Field selection",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "DISPLACEMENT" : "#/components/schemas/DisplacementFieldSelection",
            "FORCE" : "#/components/schemas/ForceFieldSelection",
            "STRAIN" : "#/components/schemas/StrainFieldSelection",
            "STRESS" : "#/components/schemas/StressFieldSelection",
            "VELOCITY" : "#/components/schemas/VelocityFieldSelection",
            "ACCELERATION" : "#/components/schemas/AccelerationFieldSelection",
            "TEMPERATURE" : "#/components/schemas/TemperatureFieldSelection",
            "HEAT_FLUX" : "#/components/schemas/HeatFluxFieldSelection"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/DisplacementFieldSelection"
        }, {
          "$ref" : "#/components/schemas/ForceFieldSelection"
        }, {
          "$ref" : "#/components/schemas/StrainFieldSelection"
        }, {
          "$ref" : "#/components/schemas/StressFieldSelection"
        }, {
          "$ref" : "#/components/schemas/VelocityFieldSelection"
        }, {
          "$ref" : "#/components/schemas/AccelerationFieldSelection"
        }, {
          "$ref" : "#/components/schemas/TemperatureFieldSelection"
        }, {
          "$ref" : "#/components/schemas/HeatFluxFieldSelection"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL]" ]
      },
      "OneOf_BondedContactPositionTolerance" : {
        "title" : "Position tolerance",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SET_VALUE" : "#/components/schemas/SetValuePositionTolerance",
            "OFF" : "#/components/schemas/OffPositionTolerance"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SetValuePositionTolerance"
        }, {
          "$ref" : "#/components/schemas/OffPositionTolerance"
        } ]
      },
      "OneOf_ConjugateHeatTransferTimeDependency" : {
        "title" : "Time dependency",
        "description" : "<p><strong>Steady-state</strong>: Steady-state simulations are time-independent, that is, the equations solved do not include time derivatives. If you are only interested in the converged solution, consider a steady-state simulation.</p><p><strong>Transient</strong>: Transient simulations account for time-dependent effects, that is, the associated flow variables vary with respect to time.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TRANSIENT" : "#/components/schemas/TransientTimeDependency",
            "STATIONARY" : "#/components/schemas/StationaryTimeDependency"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TransientTimeDependency"
        }, {
          "$ref" : "#/components/schemas/StationaryTimeDependency"
        } ]
      },
      "OneOf_ConjugateHeatTransferBoundaryConditions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VELOCITY_INLET_V3" : "#/components/schemas/VelocityInletBC",
            "VELOCITY_OUTLET_V7" : "#/components/schemas/VelocityOutletBC",
            "PRESSURE_INLET_V31" : "#/components/schemas/PressureInletBC",
            "PRESSURE_OUTLET_V30" : "#/components/schemas/PressureOutletBC",
            "WALL_V34" : "#/components/schemas/WallBC",
            "FAN" : "#/components/schemas/FanBC",
            "SYMMETRY" : "#/components/schemas/SymmetryBC",
            "WEDGE" : "#/components/schemas/WedgeBC",
            "CUSTOM_V37" : "#/components/schemas/CustomFluidBC",
            "EMPTY_2D" : "#/components/schemas/Empty2DBC",
            "NATURAL_CONVECTION_INLET_OUTLET" : "#/components/schemas/NaturalConvectionInletOutletBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/VelocityInletBC"
        }, {
          "$ref" : "#/components/schemas/VelocityOutletBC"
        }, {
          "$ref" : "#/components/schemas/PressureInletBC"
        }, {
          "$ref" : "#/components/schemas/PressureOutletBC"
        }, {
          "$ref" : "#/components/schemas/WallBC"
        }, {
          "$ref" : "#/components/schemas/FanBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryBC"
        }, {
          "$ref" : "#/components/schemas/WedgeBC"
        }, {
          "$ref" : "#/components/schemas/CustomFluidBC"
        }, {
          "$ref" : "#/components/schemas/Empty2DBC"
        }, {
          "$ref" : "#/components/schemas/NaturalConvectionInletOutletBC"
        } ]
      },
      "OneOf_IncompressiblePacefishMeshSettingsNew" : {
        "title" : "Mesh settings",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PACEFISH_MESH_LEGACY" : "#/components/schemas/PacefishMeshLegacy",
            "PACEFISH_MESH_V38" : "#/components/schemas/PacefishMeshV38",
            "PACEFISH_AUTOMESH" : "#/components/schemas/PacefishAutomesh"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PacefishMeshLegacy"
        }, {
          "$ref" : "#/components/schemas/PacefishMeshV38"
        }, {
          "$ref" : "#/components/schemas/PacefishAutomesh"
        } ]
      },
      "OneOf_PressureOutletBCPressure" : {
        "title" : "Pressure type",
        "description" : "Please choose a boundary condition for pressure (p). <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/pressure-inlet-and-pressure-outlet/' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FIXED_VALUE" : "#/components/schemas/FixedValuePBC",
            "FIXED_MEAN" : "#/components/schemas/MeanValuePBC",
            "TOTAL_PRESSURE" : "#/components/schemas/TotalPBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FixedValuePBC"
        }, {
          "$ref" : "#/components/schemas/MeanValuePBC"
        }, {
          "$ref" : "#/components/schemas/TotalPBC"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE", "type == SIMERICS_ANALYSIS && isCompressible == true" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type == COMPRESSIBLE" ],
          "default" : {
            "type" : "FIXED_VALUE"
          }
        }, {
          "when" : [ "type == SIMERICS_ANALYSIS" ],
          "default" : {
            "type" : "TOTAL_PRESSURE"
          }
        } ]
      },
      "OneOf_PressureOutletBCPressureRgh" : {
        "title" : "Pressure type",
        "description" : "Please choose a boundary condition for modified pressure (p_rgh). <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/pressure-inlet-and-pressure-outlet/' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FIXED_VALUE" : "#/components/schemas/FixedValuePBC",
            "FIXED_MEAN" : "#/components/schemas/MeanValuePBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FixedValuePBC"
        }, {
          "$ref" : "#/components/schemas/MeanValuePBC"
        } ],
        "x-showWhen" : [ "type in [CONJUGATE_HEAT_TRANSFER,MULTIPHASE]", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == true", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && isCompressible == true", "type == EMBEDDED_BOUNDARY && isCompressible == true" ]
      },
      "OneOf_PressureOutletBCGaugePressure" : {
        "title" : "Pressure type",
        "description" : "Please choose a boundary condition for gauge pressure (p). <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/pressure-inlet-and-pressure-outlet/' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FIXED_VALUE" : "#/components/schemas/FixedValuePBC",
            "FIXED_MEAN" : "#/components/schemas/MeanValuePBC",
            "TOTAL_PRESSURE" : "#/components/schemas/TotalPBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FixedValuePBC"
        }, {
          "$ref" : "#/components/schemas/MeanValuePBC"
        }, {
          "$ref" : "#/components/schemas/TotalPBC"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE", "type == SIMERICS_ANALYSIS && isCompressible == false" ]
      },
      "OneOf_PressureOutletBCGaugePressureRgh" : {
        "title" : "Pressure type",
        "description" : "Please choose a boundary condition for modified gauge pressure (p_rgh). <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/pressure-inlet-and-pressure-outlet/' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FIXED_VALUE" : "#/components/schemas/FixedValuePBC",
            "FIXED_MEAN" : "#/components/schemas/MeanValuePBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FixedValuePBC"
        }, {
          "$ref" : "#/components/schemas/MeanValuePBC"
        } ],
        "x-showWhen" : [ "type == COUPLED_CONJUGATE_HEAT_TRANSFER && isCompressible == false", "type == EMBEDDED_BOUNDARY && isCompressible == false", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false" ]
      },
      "OneOf_PressureOutletBCNetRadiativeHeatFlux" : {
        "title" : "Radiative behaviour",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GREYBODY_DIFFUSIVE" : "#/components/schemas/GreybodyDiffusiveRSBC",
            "OPEN_WINDOW" : "#/components/schemas/OpenWindowRSBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GreybodyDiffusiveRSBC"
        }, {
          "$ref" : "#/components/schemas/OpenWindowRSBC"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && enableRadiation == true", "type == CONJUGATE_HEAT_TRANSFER && enableRadiation == true" ]
      },
      "OneOf_PressureOutletBCRadiativeIntensityRay" : {
        "title" : "Radiative behaviour",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GREYBODY_DIFFUSIVE_RAY" : "#/components/schemas/GreybodyDiffusiveRayBC",
            "OPEN_BOUNDARY_RAY" : "#/components/schemas/OpenBoundaryRayBC",
            "SEMI_OPEN_BOUNDARY_RAY" : "#/components/schemas/SemiOpenBoundaryRayBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GreybodyDiffusiveRayBC"
        }, {
          "$ref" : "#/components/schemas/OpenBoundaryRayBC"
        }, {
          "$ref" : "#/components/schemas/SemiOpenBoundaryRayBC"
        } ],
        "x-showWhen" : [ "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableRadiation == true", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableSolarLoad == true" ]
      },
      "OneOf_ExternalWallHeatFluxTBCHeatFlux" : {
        "title" : "Heat flux",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "DERIVED" : "#/components/schemas/DerivedHeatFlux",
            "FIXED" : "#/components/schemas/FixedHeatFlux",
            "FIXED_POWER" : "#/components/schemas/FixedPowerHeatFlux"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/DerivedHeatFlux"
        }, {
          "$ref" : "#/components/schemas/FixedHeatFlux"
        }, {
          "$ref" : "#/components/schemas/FixedPowerHeatFlux"
        } ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ],
          "default" : {
            "type" : "FIXED"
          }
        }, {
          "when" : [ "type in [CONJUGATE_HEAT_TRANSFER,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER]" ],
          "default" : {
            "type" : "DERIVED"
          }
        } ]
      },
      "OneOf_DimensionalFunction_MassFlowRateValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_TurbulentHeatFluxTBCHeatSource" : {
        "title" : "Heat source",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FLUX" : "#/components/schemas/FluxHeatSource",
            "POWER" : "#/components/schemas/PowerHeatSource"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FluxHeatSource"
        }, {
          "$ref" : "#/components/schemas/PowerHeatSource"
        } ]
      },
      "OneOf_ImplicitTimeIntegrationTypeScheme" : {
        "title" : "Scheme",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "HHT" : "#/components/schemas/HhtTimeIntegrationScheme",
            "NEWMARK" : "#/components/schemas/NewmarkTimeIntegrationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/HhtTimeIntegrationScheme"
        }, {
          "$ref" : "#/components/schemas/NewmarkTimeIntegrationScheme"
        } ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type == THERMAL_MECHANICAL" ],
          "default" : {
            "type" : "NEWMARK"
          }
        }, {
          "when" : [ "type == DYNAMIC_ANALYSIS" ],
          "default" : {
            "type" : "HHT"
          }
        } ]
      },
      "OneOf_TangentJacobianMatrixChangeJacobianMatrix" : {
        "title" : "Change jacobian matrix",
        "description" : "<p>Choose if the Jacobian matrix should automatically change from tangent stiffnes matrix to elastic matrix if the time increment is falling below a given threshold. On the assumption that below a given time increment value the nonlinearities are not evolving within the time step one can strongly save computation time by switching to the elastic matrix.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TRUE" : "#/components/schemas/TrueChangeJacobianMatrix",
            "FALSE" : "#/components/schemas/FalseChangeJacobianMatrix"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TrueChangeJacobianMatrix"
        }, {
          "$ref" : "#/components/schemas/FalseChangeJacobianMatrix"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS]", "type == THERMAL_MECHANICAL && 2# == mechanicalResolutionType" ]
      },
      "OneOf_DynamicAnalysisConnectionGroups" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONTACT" : "#/components/schemas/Contact",
            "PHYSICAL_CONTACT_V36" : "#/components/schemas/PhysicalContact"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/Contact"
        }, {
          "$ref" : "#/components/schemas/PhysicalContact"
        } ]
      },
      "OneOf_DynamicAnalysisBoundaryConditions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "BOLT_PRELOAD" : "#/components/schemas/BoltPreloadBC",
            "ELASTIC_SUPPORT" : "#/components/schemas/ElasticSupportBC",
            "FIXED_SUPPORT" : "#/components/schemas/FixedSupportBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueBC",
            "POINT_MASS" : "#/components/schemas/PointMassBC",
            "REMOTE_DISPLACEMENT_LOAD" : "#/components/schemas/RemoteDisplacementLoadBC",
            "ROTATING_MOTION" : "#/components/schemas/RotatingMotionBC",
            "SYMMETRY_PLANE" : "#/components/schemas/SymmetryPlaneBC",
            "CENTRIFUGAL_FORCE" : "#/components/schemas/CentrifugalForceBC",
            "FOLLOWER_PRESSURE" : "#/components/schemas/FollowerPressureBC",
            "FORCE_LOAD" : "#/components/schemas/ForceLoadBC",
            "NODAL_LOAD" : "#/components/schemas/NodalLoadBC",
            "PRESSURE" : "#/components/schemas/PressureBC",
            "REMOTE_FORCE_LOAD" : "#/components/schemas/RemoteForceLoadBC",
            "SURFACE_LOAD" : "#/components/schemas/SurfaceLoadBC",
            "VOLUME_LOAD" : "#/components/schemas/VolumeLoadBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/BoltPreloadBC"
        }, {
          "$ref" : "#/components/schemas/ElasticSupportBC"
        }, {
          "$ref" : "#/components/schemas/FixedSupportBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueBC"
        }, {
          "$ref" : "#/components/schemas/PointMassBC"
        }, {
          "$ref" : "#/components/schemas/RemoteDisplacementLoadBC"
        }, {
          "$ref" : "#/components/schemas/RotatingMotionBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryPlaneBC"
        }, {
          "$ref" : "#/components/schemas/CentrifugalForceBC"
        }, {
          "$ref" : "#/components/schemas/FollowerPressureBC"
        }, {
          "$ref" : "#/components/schemas/ForceLoadBC"
        }, {
          "$ref" : "#/components/schemas/NodalLoadBC"
        }, {
          "$ref" : "#/components/schemas/PressureBC"
        }, {
          "$ref" : "#/components/schemas/RemoteForceLoadBC"
        }, {
          "$ref" : "#/components/schemas/SurfaceLoadBC"
        }, {
          "$ref" : "#/components/schemas/VolumeLoadBC"
        } ]
      },
      "OneOf_DimensionalVectorFunction_TorqueValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "COMPONENT" : "#/components/schemas/ComponentVectorFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedVectorFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ComponentVectorFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedVectorFunction"
        } ]
      },
      "OneOf_InterpolationSchemesForDefault" : {
        "title" : "Default",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE]" ]
      },
      "OneOf_InterpolationSchemesInterpolate_HbyA" : {
        "title" : "interpolate(HbyA)",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && turbulenceModel == NONE && algorithm == ICO", "type == INCOMPRESSIBLE && turbulenceModel in [KOMEGA,KOMEGASST] && algorithm in [PISO,SIMPLE]", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS,NONE,KEPSILON,KOMEGASST] && isCompressible == false" ]
      },
      "OneOf_InterpolationSchemesInterpolate_velocity" : {
        "title" : "interpolate U",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS,NONE,KEPSILON] && algorithm in [PIMPLE,PISO,SIMPLE]", "type == INCOMPRESSIBLE && turbulenceModel in [KOMEGA,KOMEGASST] && algorithm == PIMPLE" ]
      },
      "OneOf_InterpolationSchemesInterpolate_kappa" : {
        "title" : "interpolate(kappa)",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_InterpolationSchemesInterpolate_rho" : {
        "title" : "interpolate(rho)",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_InterpolationSchemesInterpolate_thermo_rho_Cp" : {
        "title" : "interpolate(thermo:rho*Cp)",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_InterpolationSchemesInterpolate_map_Kappa" : {
        "title" : "interpolate(mag(Kappa))",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_InterpolationSchemesInterpolate_rho_Hbya" : {
        "title" : "interpolate(rho*HbyA)",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_InterpolationSchemesInterpolate_rho_0_velocity0" : {
        "title" : "interpolate(rho_0*U_0)",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_InterpolationSchemesInterpolate_grad_enthalpy" : {
        "title" : "interpolate(grad(h))",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_InterpolationSchemesInterpolate_rho_rAU" : {
        "title" : "interpolate(rho*rAU)",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_InterpolationSchemesInterpolate_rAU" : {
        "title" : "interpolate rAU",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS,NONE,KEPSILON,KOMEGASST] && isCompressible == false" ]
      },
      "OneOf_InterpolationSchemesInterpolate_velocity0" : {
        "title" : "interpolate(U_0)",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS,NONE,KEPSILON,KOMEGASST] && timeDependency.type == TRANSIENT && isCompressible == false" ]
      },
      "OneOf_InterpolationSchemesReconstruct_velocity" : {
        "title" : "reconstruct(U)",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_InterpolationSchemesReconstruct_temperature" : {
        "title" : "reconstruct(T)",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_InterpolationSchemesReconstruct_rho" : {
        "title" : "reconstruct(rho)",
        "description" : "<p>With this option you can choose your desired interpolation scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUBIC" : "#/components/schemas/CubicInterpolationScheme",
            "LINEAR" : "#/components/schemas/LinearInterpolationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CubicInterpolationScheme"
        }, {
          "$ref" : "#/components/schemas/LinearInterpolationScheme"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_CoupledConjugateHeatTransferMaterialsFluids" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "INCOMPRESSIBLE" : "#/components/schemas/IncompressibleMaterial",
            "COMPRESSIBLE" : "#/components/schemas/FluidCompressibleMaterial"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/IncompressibleMaterial"
        }, {
          "$ref" : "#/components/schemas/FluidCompressibleMaterial"
        } ]
      },
      "OneOf_FieldCalculationsTurbulenceResultControlResultType" : {
        "title" : "Result type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "DIMENSIONLESS_WALL_DISTANCE_YPLUS" : "#/components/schemas/YPlusRASResultType",
            "REYNOLDS_STRESS_TENSOR" : "#/components/schemas/ReynoldsStressResultType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/YPlusRASResultType"
        }, {
          "$ref" : "#/components/schemas/ReynoldsStressResultType"
        } ]
      },
      "OneOf_FluidModelDeltaCoefficient" : {
        "title" : "Delta coefficient",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PRANDTL" : "#/components/schemas/PrandtlLesDelta",
            "SMOOTH" : "#/components/schemas/SmoothLesDelta",
            "CUBE_ROOT_VOL" : "#/components/schemas/CubeRootVolLesDelta"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PrandtlLesDelta"
        }, {
          "$ref" : "#/components/schemas/SmoothLesDelta"
        }, {
          "$ref" : "#/components/schemas/CubeRootVolLesDelta"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE] && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS]" ]
      },
      "OneOf_DimensionalFunction_DensityValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_NewtonKrylovResolutionTypeConvergenceCriteria" : {
        "title" : "Convergence criteria",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "RELATIVE" : "#/components/schemas/RelativeConvergenceCriteria",
            "ABSOLUTE" : "#/components/schemas/AbsoluteConvergenceCriteria"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/RelativeConvergenceCriteria"
        }, {
          "$ref" : "#/components/schemas/AbsoluteConvergenceCriteria"
        } ]
      },
      "OneOf_NewtonKrylovResolutionTypeJacobianMatrix" : {
        "title" : "Jacobian matrix",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TANGENT" : "#/components/schemas/TangentJacobianMatrix",
            "ELASTIC" : "#/components/schemas/ElasticJacobianMatrix"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TangentJacobianMatrix"
        }, {
          "$ref" : "#/components/schemas/ElasticJacobianMatrix"
        } ]
      },
      "OneOf_AreaIntegralResultControlWriteControl" : {
        "title" : "Write control",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TIME_STEP" : "#/components/schemas/TimeStepWriteControl",
            "OUTPUT_TIME" : "#/components/schemas/SynchronizeWithFieldOutputWriteControl"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TimeStepWriteControl"
        }, {
          "$ref" : "#/components/schemas/SynchronizeWithFieldOutputWriteControl"
        } ]
      },
      "OneOf_DimensionalFunction_TurbulenceKineticEnergyValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_SlidingContactPositionTolerance" : {
        "title" : "Position tolerance",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SET_VALUE" : "#/components/schemas/SetValuePositionTolerance",
            "OFF" : "#/components/schemas/OffPositionTolerance"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SetValuePositionTolerance"
        }, {
          "$ref" : "#/components/schemas/OffPositionTolerance"
        } ]
      },
      "OneOf_MULESSolverSemiImplicit" : {
        "title" : "Semi-implicit MULES",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FALSE_SEMI_IMPLICIT" : "#/components/schemas/FalseSemiImplicit",
            "TRUE_SEMI_IMPLICIT" : "#/components/schemas/TrueSemiImplicit"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FalseSemiImplicit"
        }, {
          "$ref" : "#/components/schemas/TrueSemiImplicit"
        } ]
      },
      "OneOf_StrainResultControlItemStrainType" : {
        "title" : "() Strain type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TOTAL_NONLINEAR" : "#/components/schemas/GlobalTotalNonlinearStrainType",
            "TOTAL_EQUI_PLASTIC" : "#/components/schemas/GlobalTotalEquivalentPlasticStrainType",
            "UNELASTIC" : "#/components/schemas/GlobalUnelasticStrainType",
            "TOTAL" : "#/components/schemas/GlobalTotalStrainType",
            "PRINCIPAL" : "#/components/schemas/GlobalPrincipalStrainType",
            "PRINCIPAL_GREEN_LAGRANGE" : "#/components/schemas/GlobalPrincipalGreenLagrangeStrainType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GlobalTotalNonlinearStrainType"
        }, {
          "$ref" : "#/components/schemas/GlobalTotalEquivalentPlasticStrainType"
        }, {
          "$ref" : "#/components/schemas/GlobalUnelasticStrainType"
        }, {
          "$ref" : "#/components/schemas/GlobalTotalStrainType"
        }, {
          "$ref" : "#/components/schemas/GlobalPrincipalStrainType"
        }, {
          "$ref" : "#/components/schemas/GlobalPrincipalGreenLagrangeStrainType"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HARMONIC_ANALYSIS,THERMAL_MECHANICAL]" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type in [DYNAMIC_ANALYSIS,HARMONIC_ANALYSIS]" ],
          "default" : {
            "type" : "TOTAL_NONLINEAR"
          }
        }, {
          "when" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true" ],
          "default" : {
            "type" : "TOTAL_NONLINEAR"
          }
        }, {
          "when" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == false", "type == THERMAL_MECHANICAL && nonLinearAnalysis == false" ],
          "default" : {
            "type" : "TOTAL"
          }
        } ]
      },
      "OneOf_FlowDomainBoundariesXMIN" : {
        "title" : "External Domain Face A",
        "description" : "This shows the face of the external flow domain to which this boundary condition is assigned. The name of the face reflects its alignment with respect to the orientation cube seen in the viewer.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VELOCITY_INLET_V3" : "#/components/schemas/VelocityInletBC",
            "PRESSURE_OUTLET_V30" : "#/components/schemas/PressureOutletBC",
            "WALL_V34" : "#/components/schemas/WallBC",
            "PERIODIC" : "#/components/schemas/PeriodicBC",
            "ATMOSPHERIC_BOUNDARY_LAYER_INLET" : "#/components/schemas/AtmosphericBoundaryLayerInletBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/VelocityInletBC"
        }, {
          "$ref" : "#/components/schemas/PressureOutletBC"
        }, {
          "$ref" : "#/components/schemas/WallBC"
        }, {
          "$ref" : "#/components/schemas/PeriodicBC"
        }, {
          "$ref" : "#/components/schemas/AtmosphericBoundaryLayerInletBC"
        } ]
      },
      "OneOf_FlowDomainBoundariesXMAX" : {
        "title" : "External Domain Face B",
        "description" : "This shows the face of the external flow domain to which this boundary condition is assigned. The name of the face reflects its alignment with respect to the orientation cube seen in the viewer.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VELOCITY_INLET_V3" : "#/components/schemas/VelocityInletBC",
            "PRESSURE_OUTLET_V30" : "#/components/schemas/PressureOutletBC",
            "WALL_V34" : "#/components/schemas/WallBC",
            "PERIODIC" : "#/components/schemas/PeriodicBC",
            "ATMOSPHERIC_BOUNDARY_LAYER_INLET" : "#/components/schemas/AtmosphericBoundaryLayerInletBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/VelocityInletBC"
        }, {
          "$ref" : "#/components/schemas/PressureOutletBC"
        }, {
          "$ref" : "#/components/schemas/WallBC"
        }, {
          "$ref" : "#/components/schemas/PeriodicBC"
        }, {
          "$ref" : "#/components/schemas/AtmosphericBoundaryLayerInletBC"
        } ]
      },
      "OneOf_FlowDomainBoundariesYMIN" : {
        "title" : "External Domain Face C",
        "description" : "This shows the face of the external flow domain to which this boundary condition is assigned. The name of the face reflects its alignment with respect to the orientation cube seen in the viewer.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VELOCITY_INLET_V3" : "#/components/schemas/VelocityInletBC",
            "PRESSURE_OUTLET_V30" : "#/components/schemas/PressureOutletBC",
            "WALL_V34" : "#/components/schemas/WallBC",
            "PERIODIC" : "#/components/schemas/PeriodicBC",
            "ATMOSPHERIC_BOUNDARY_LAYER_INLET" : "#/components/schemas/AtmosphericBoundaryLayerInletBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/VelocityInletBC"
        }, {
          "$ref" : "#/components/schemas/PressureOutletBC"
        }, {
          "$ref" : "#/components/schemas/WallBC"
        }, {
          "$ref" : "#/components/schemas/PeriodicBC"
        }, {
          "$ref" : "#/components/schemas/AtmosphericBoundaryLayerInletBC"
        } ]
      },
      "OneOf_FlowDomainBoundariesYMAX" : {
        "title" : "External Domain Face D",
        "description" : "This shows the face of the external flow domain to which this boundary condition is assigned. The name of the face reflects its alignment with respect to the orientation cube seen in the viewer.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VELOCITY_INLET_V3" : "#/components/schemas/VelocityInletBC",
            "PRESSURE_OUTLET_V30" : "#/components/schemas/PressureOutletBC",
            "WALL_V34" : "#/components/schemas/WallBC",
            "PERIODIC" : "#/components/schemas/PeriodicBC",
            "ATMOSPHERIC_BOUNDARY_LAYER_INLET" : "#/components/schemas/AtmosphericBoundaryLayerInletBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/VelocityInletBC"
        }, {
          "$ref" : "#/components/schemas/PressureOutletBC"
        }, {
          "$ref" : "#/components/schemas/WallBC"
        }, {
          "$ref" : "#/components/schemas/PeriodicBC"
        }, {
          "$ref" : "#/components/schemas/AtmosphericBoundaryLayerInletBC"
        } ]
      },
      "OneOf_FlowDomainBoundariesZMIN" : {
        "title" : "External Domain Face E",
        "description" : "This shows the face of the external flow domain to which this boundary condition is assigned. The name of the face reflects its alignment with respect to the orientation cube seen in the viewer.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VELOCITY_INLET_V3" : "#/components/schemas/VelocityInletBC",
            "PRESSURE_OUTLET_V30" : "#/components/schemas/PressureOutletBC",
            "WALL_V34" : "#/components/schemas/WallBC",
            "PERIODIC" : "#/components/schemas/PeriodicBC",
            "ATMOSPHERIC_BOUNDARY_LAYER_INLET" : "#/components/schemas/AtmosphericBoundaryLayerInletBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/VelocityInletBC"
        }, {
          "$ref" : "#/components/schemas/PressureOutletBC"
        }, {
          "$ref" : "#/components/schemas/WallBC"
        }, {
          "$ref" : "#/components/schemas/PeriodicBC"
        }, {
          "$ref" : "#/components/schemas/AtmosphericBoundaryLayerInletBC"
        } ]
      },
      "OneOf_FlowDomainBoundariesZMAX" : {
        "title" : "External Domain Face F",
        "description" : "This shows the face of the external flow domain to which this boundary condition is assigned. The name of the face reflects its alignment with respect to the orientation cube seen in the viewer.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VELOCITY_INLET_V3" : "#/components/schemas/VelocityInletBC",
            "PRESSURE_OUTLET_V30" : "#/components/schemas/PressureOutletBC",
            "WALL_V34" : "#/components/schemas/WallBC",
            "PERIODIC" : "#/components/schemas/PeriodicBC",
            "ATMOSPHERIC_BOUNDARY_LAYER_INLET" : "#/components/schemas/AtmosphericBoundaryLayerInletBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/VelocityInletBC"
        }, {
          "$ref" : "#/components/schemas/PressureOutletBC"
        }, {
          "$ref" : "#/components/schemas/WallBC"
        }, {
          "$ref" : "#/components/schemas/PeriodicBC"
        }, {
          "$ref" : "#/components/schemas/AtmosphericBoundaryLayerInletBC"
        } ]
      },
      "OneOf_ExplicitTimeIntegrationTypeScheme" : {
        "title" : "Scheme",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CENTRAL_DIFF" : "#/components/schemas/CentralDiffTimeIntegrationScheme",
            "TCHAMWA" : "#/components/schemas/TchamwaTimeIntegrationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CentralDiffTimeIntegrationScheme"
        }, {
          "$ref" : "#/components/schemas/TchamwaTimeIntegrationScheme"
        } ]
      },
      "OneOf_FlowRateOutletVBCFlowRate" : {
        "title" : "Flow rate type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "MASS" : "#/components/schemas/MassFlow",
            "VOLUMETRIC" : "#/components/schemas/VolumetricFlow"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/MassFlow"
        }, {
          "$ref" : "#/components/schemas/VolumetricFlow"
        } ]
      },
      "OneOf_FlowRateMeanInletVBCFlowRate" : {
        "title" : "Mean flow rate type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "MASS" : "#/components/schemas/MassFlow",
            "VOLUMETRIC" : "#/components/schemas/VolumetricFlow"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/MassFlow"
        }, {
          "$ref" : "#/components/schemas/VolumetricFlow"
        } ]
      },
      "OneOf_DarcyForchheimerMediumOrientation" : {
        "title" : "Orientation",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CARTESIAN" : "#/components/schemas/CartesianOrientation",
            "CUSTOM" : "#/components/schemas/CustomOrientation"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CartesianOrientation"
        }, {
          "$ref" : "#/components/schemas/CustomOrientation"
        } ]
      },
      "OneOf_ForceResultControlItemForceType" : {
        "title" : "Force type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "REACTION" : "#/components/schemas/GlobalReactionForceType",
            "NODAL" : "#/components/schemas/GlobalNodalForceType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GlobalReactionForceType"
        }, {
          "$ref" : "#/components/schemas/GlobalNodalForceType"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HARMONIC_ANALYSIS,THERMAL_MECHANICAL]" ]
      },
      "OneOf_AMIRotatingZoneMotionType" : {
        "title" : "Motion type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "OSCILLATING_ROTATING_MOTION" : "#/components/schemas/OscillatingRotatingMotionType",
            "ROTATING_MOTION" : "#/components/schemas/RotatingMotionType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/OscillatingRotatingMotionType"
        }, {
          "$ref" : "#/components/schemas/RotatingMotionType"
        } ]
      },
      "OneOf_PacefishAutomeshNewFineness" : {
        "title" : "Fineness",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VERY_COARSE" : "#/components/schemas/PacefishFinenessVeryCoarse",
            "COARSE" : "#/components/schemas/PacefishFinenessCoarse",
            "MODERATE" : "#/components/schemas/PacefishFinenessModerate",
            "FINE" : "#/components/schemas/PacefishFinenessFine",
            "VERY_FINE" : "#/components/schemas/PacefishFinenessVeryFine",
            "TARGET_SIZE" : "#/components/schemas/PacefishFinenessTargetSize"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PacefishFinenessVeryCoarse"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessCoarse"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessModerate"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessFine"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessVeryFine"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessTargetSize"
        } ]
      },
      "OneOf_PacefishAutomeshReferenceLengthComputation" : {
        "title" : "Reference length computation",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC_REFERENCE_LENGTH" : "#/components/schemas/AutomaticReferenceLength",
            "MANUAL_REFERENCE_LENGTH" : "#/components/schemas/ManualReferenceLength"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutomaticReferenceLength"
        }, {
          "$ref" : "#/components/schemas/ManualReferenceLength"
        } ]
      },
      "OneOf_PacefishAutomeshReynoldsScalingType" : {
        "title" : "Reynolds scaling",
        "description" : "Use this factor to scale the Reynolds number of your simulation. For example, to change the Reynolds number from 10<sup>8</sup> to 10<sup>6</sup>, set this factor to 0.01. <a href= https://www.simscale.com/docs/incompressible-lbm-lattice-boltzmann-advanced/#reynolds-scaling-factor' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC_REYNOLDS_SCALING" : "#/components/schemas/AutomaticReynoldsScaling",
            "MANUAL_REYNOLDS_SCALING" : "#/components/schemas/ManualReynoldsScaling"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutomaticReynoldsScaling"
        }, {
          "$ref" : "#/components/schemas/ManualReynoldsScaling"
        } ]
      },
      "OneOf_PacefishAutomeshPrimaryTopology" : {
        "title" : "Region of interest",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "BUILDINGS_OF_INTEREST" : "#/components/schemas/BuildingsOfInterest",
            "REGION" : "#/components/schemas/Region"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/BuildingsOfInterest"
        }, {
          "$ref" : "#/components/schemas/Region"
        } ]
      },
      "OneOf_PacefishAutomeshRefinements" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "REGION_PACEFISH_V38" : "#/components/schemas/NewRegionRefinementPacefishV38",
            "SURFACE_PACEFISH_V38" : "#/components/schemas/NewSurfaceRefinementPacefishV38"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NewRegionRefinementPacefishV38"
        }, {
          "$ref" : "#/components/schemas/NewSurfaceRefinementPacefishV38"
        } ]
      },
      "OneOf_RestrictedDimensionalFunction_FrequencyValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "RESTRICTED_TABLE_DEFINED" : "#/components/schemas/RestrictedTableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/RestrictedTableDefinedFunction"
        } ]
      },
      "OneOf_DimensionalFunction_TemperatureGradientValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_DimensionalFunction_ThermalConductivityValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_ConnectionSettingsV36NonlinearityResolution" : {
        "title" : "Nonlinearity resolution",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NEWTON" : "#/components/schemas/NewtonNonLinearityResolution",
            "FIXED_POINT" : "#/components/schemas/FixedPointNonLinearityResolution"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NewtonNonLinearityResolution"
        }, {
          "$ref" : "#/components/schemas/FixedPointNonLinearityResolution"
        } ]
      },
      "OneOf_ConnectionSettingsV36Friction" : {
        "title" : "Friction",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NO_FRICTION" : "#/components/schemas/NoFriction",
            "COULOMB_FRICTION" : "#/components/schemas/CoulombFriction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NoFriction"
        }, {
          "$ref" : "#/components/schemas/CoulombFriction"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,THERMAL_MECHANICAL]" ]
      },
      "OneOf_ConnectionSettingsV36ContactNonLinearityResolution" : {
        "title" : "Contact nonlinearity resolution",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NEWTON" : "#/components/schemas/NewtonContactNonLinearityResolution",
            "FIXED_POINT" : "#/components/schemas/FixedPointContactNonLinearityResolution"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NewtonContactNonLinearityResolution"
        }, {
          "$ref" : "#/components/schemas/FixedPointContactNonLinearityResolution"
        } ]
      },
      "OneOf_NewSurfaceRefinementPacefishV38MeshSizing" : {
        "title" : "Sizing",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC" : "#/components/schemas/AutomaticMeshSizing",
            "MANUAL_SURFACE_PACEFISH" : "#/components/schemas/ManualSurfaceSizingPacefish"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutomaticMeshSizing"
        }, {
          "$ref" : "#/components/schemas/ManualSurfaceSizingPacefish"
        } ]
      },
      "OneOf_ScalarTransportResultControlWriteControl" : {
        "title" : "Write control",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TIME_STEP" : "#/components/schemas/TimeStepWriteControl",
            "OUTPUT_TIME" : "#/components/schemas/SynchronizeWithFieldOutputWriteControl"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TimeStepWriteControl"
        }, {
          "$ref" : "#/components/schemas/SynchronizeWithFieldOutputWriteControl"
        } ]
      },
      "OneOf_DimensionalFunction_TurbulentDissipationValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_DimensionalFunction_AngleValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_IsotropicPlasticHardeningPoissonsRatio" : {
        "title" : "() Poisson's ratio",
        "maximum" : 0.5,
        "exclusiveMaximum" : true,
        "minimum" : -1,
        "exclusiveMinimum" : true,
        "description" : "<p>Provide the <i>Poisson's ratio</i> value which describes the compression or elongation of a material transverse to axial strain. <i>Poisson's ratio</i> can have a value within range from -1 to 0.5. </p><br /><b>Important remarks:</b><br /> <ul><li>Value less than 0 means that material is auxetic.</li><li>Most of the metals such as steel and aluminum have value between 0.2 to 0.35 and are considered compressible.<li>Value of 0.5 means that the material is incompressible such as rubber and some types of foams. Please avoid giving this value since it leads to convergence problem. You can give 0.499 rather than 0.5.</li></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ],
        "x-showWhen" : [ "type == DYNAMIC_ANALYSIS", "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true" ]
      },
      "OneOf_HeatTransferTimeDependency" : {
        "title" : "Time dependency",
        "description" : "<p><strong>Steady-state</strong>: Steady-state simulations are time-independent, that is, the equations solved do not include time derivatives. If you are only interested in the converged solution, consider a steady-state simulation.</p><p><strong>Transient</strong>: Transient simulations account for time-dependent effects, that is, the associated flow variables vary with respect to time.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TRANSIENT" : "#/components/schemas/TransientTimeDependency",
            "STATIONARY" : "#/components/schemas/StationaryTimeDependency"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TransientTimeDependency"
        }, {
          "$ref" : "#/components/schemas/StationaryTimeDependency"
        } ]
      },
      "OneOf_HeatTransferBoundaryConditions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FIXED_TEMPERATURE_VALUE" : "#/components/schemas/FixedTemperatureValueBC",
            "SURFACE_HEAT_FLUX" : "#/components/schemas/SurfaceHeatFluxBC",
            "CONVECTIVE_HEAT_FLUX" : "#/components/schemas/ConvectiveHeatFluxBC",
            "VOLUME_HEAT_FLUX" : "#/components/schemas/VolumeHeatFluxBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FixedTemperatureValueBC"
        }, {
          "$ref" : "#/components/schemas/SurfaceHeatFluxBC"
        }, {
          "$ref" : "#/components/schemas/ConvectiveHeatFluxBC"
        }, {
          "$ref" : "#/components/schemas/VolumeHeatFluxBC"
        } ]
      },
      "OneOf_ConvectiveHeatTransferMaterialsFluids" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "INCOMPRESSIBLE" : "#/components/schemas/IncompressibleMaterial",
            "COMPRESSIBLE" : "#/components/schemas/FluidCompressibleMaterial"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/IncompressibleMaterial"
        }, {
          "$ref" : "#/components/schemas/FluidCompressibleMaterial"
        } ]
      },
      "OneOf_IsotropicDirectionalDependencyPoissonsRatio" : {
        "title" : "() Poisson's ratio",
        "maximum" : 0.5,
        "exclusiveMaximum" : true,
        "minimum" : -1,
        "exclusiveMinimum" : true,
        "description" : "<p>Provide the <i>Poisson's ratio</i> value which describes the compression or elongation of a material transverse to axial strain. <i>Poisson's ratio</i> can have a value within range from -1 to 0.5. </p><br /><b>Important remarks:</b><br /> <ul><li>Value less than 0 means that material is auxetic.</li><li>Most of the metals such as steel and aluminum have value between 0.2 to 0.35 and are considered compressible.<li>Value of 0.5 means that the material is incompressible such as rubber and some types of foams. Please avoid giving this value since it leads to convergence problem. You can give 0.499 rather than 0.5.</li></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HARMONIC_ANALYSIS,FREQUENCY_ANALYSIS,THERMAL_MECHANICAL]" ]
      },
      "OneOf_OrthotropicSpringStiffnessStiffnessDefinition" : {
        "title" : "Stiffness definition",
        "description" : "<p>The resulting stiffness of the elastic support can be defined either via the <b>total stiffness</b> expressed as force per length or the <b>distributed stiffness</b> expressed as force per length per area.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TOTAL_ORTHOTROPIC" : "#/components/schemas/TotalOrthotropicStiffnessDefinition",
            "DISTRIBUTED_ORTHOTROPIC" : "#/components/schemas/DistributedOrthotropicStiffnessDefinition"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TotalOrthotropicStiffnessDefinition"
        }, {
          "$ref" : "#/components/schemas/DistributedOrthotropicStiffnessDefinition"
        } ]
      },
      "OneOf_DivergenceSchemesForDefault" : {
        "title" : "Default",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWINDV_UNLIMITED" : "#/components/schemas/GaussLinearUpwindVUnlimitedDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindVUnlimitedDivergenceScheme"
        } ],
        "x-showWhen" : [ "type in [INCOMPRESSIBLE,MULTIPHASE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER]", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_DivergenceSchemesDiv_Phi_velocity" : {
        "title" : "div(phi,U)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWINDV_UNLIMITED" : "#/components/schemas/GaussLinearUpwindVUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "GAUSS_LIMITEDLINEARV_1" : "#/components/schemas/GaussLimitedLinearV1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme",
            "GAUSS_LINEARUPWINDV_GRAD_U_" : "#/components/schemas/GaussLinearUpwindVGradUDivergenceScheme",
            "GAUSS_INTERFACECOMPRESSION" : "#/components/schemas/GaussInterfaceCompressionDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindVUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinearV1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindVGradUDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussInterfaceCompressionDivergenceScheme"
        } ],
        "x-showWhen" : [ "type in [INCOMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER]", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type == INCOMPRESSIBLE && timeDependency.type == STATIONARY && numOfPassiveSpecies == 0" ],
          "default" : {
            "type" : "GAUSS_LINEARUPWINDV_GRAD_U_"
          }
        } ]
      },
      "OneOf_DivergenceSchemesDiv_Phi_kineticEnergy" : {
        "title" : "div(phi,K)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == true" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type == COMPRESSIBLE" ],
          "default" : {
            "type" : "GAUSS_LINEAR"
          }
        } ]
      },
      "OneOf_DivergenceSchemesDiv_Phi_enthalpy" : {
        "title" : "div(phi,h)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == true" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type == COMPRESSIBLE" ],
          "default" : {
            "type" : "GAUSS_UPWIND"
          }
        } ]
      },
      "OneOf_DivergenceSchemesDiv_Phi_internalEnergy" : {
        "title" : "div(phi,e)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == true" ]
      },
      "OneOf_DivergenceSchemesDiv_Phiv_pressure" : {
        "title" : "div(phiv,p)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_DivergenceSchemesDiv_Phi_turbulentKineticEnergy" : {
        "title" : "div(phi,k)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        } ],
        "x-showWhen" : [ "type in [INCOMPRESSIBLE,MULTIPHASE] && turbulenceModel in [KEPSILON,KOMEGA,KOMEGASST]", "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER] && turbulenceModel in [KEPSILON,KOMEGASST]", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [KEPSILON,KOMEGASST] && timeDependency.type == STATIONARY", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [KEPSILON,KOMEGASST] && timeDependency.type == TRANSIENT && isCompressible == false" ]
      },
      "OneOf_DivergenceSchemesDiv_Phi_omegaDissipationRate" : {
        "title" : "div(phi,omega)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        } ],
        "x-showWhen" : [ "type in [INCOMPRESSIBLE,MULTIPHASE] && turbulenceModel in [KOMEGA,KOMEGASST]", "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER] && turbulenceModel == KOMEGASST", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel == KOMEGASST && timeDependency.type == STATIONARY", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel == KOMEGASST && timeDependency.type == TRANSIENT && isCompressible == false" ]
      },
      "OneOf_DivergenceSchemesDiv_Phi_epsilonDissipationRate" : {
        "title" : "div(phi,epsilon)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        } ],
        "x-showWhen" : [ "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,MULTIPHASE] && turbulenceModel == KEPSILON", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel == KEPSILON && timeDependency.type == STATIONARY", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel == KEPSILON && timeDependency.type == TRANSIENT && isCompressible == false" ]
      },
      "OneOf_DivergenceSchemesDiv_R" : {
        "title" : "div(R)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWINDV_UNLIMITED" : "#/components/schemas/GaussLinearUpwindVUnlimitedDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindVUnlimitedDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS,NONE,KEPSILON] && algorithm in [PISO,SIMPLE]" ]
      },
      "OneOf_DivergenceSchemesDiv_Phi_R" : {
        "title" : "div(phi,R)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS,NONE,KEPSILON] && algorithm in [PISO,SIMPLE]" ]
      },
      "OneOf_DivergenceSchemesDiv_Phi_nuTilda" : {
        "title" : "div(phi,nuTilda)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && turbulenceModel == SPALARTALLMARAS", "type == INCOMPRESSIBLE && turbulenceModel in [SMAGORINSKY,NONE,KEPSILON] && algorithm in [PISO,SIMPLE]", "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE] && turbulenceModel == SPALARTALLMARAS" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 0" ],
          "default" : {
            "type" : "GAUSS_UPWIND"
          }
        }, {
          "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies == 0 && algorithm != PIMPLE && turbulenceModel != SPALARTALLMARAS" ],
          "default" : {
            "type" : "BOUNDED_GAUSS_UPWIND"
          }
        }, {
          "when" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies == 0 && algorithm == PIMPLE && turbulenceModel == SPALARTALLMARAS" ],
          "default" : {
            "type" : "GAUSS_LINEAR"
          }
        }, {
          "when" : [ "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE]" ],
          "default" : {
            "type" : "GAUSS_LINEAR"
          }
        } ]
      },
      "OneOf_DivergenceSchemesDiv_Phi_temperature" : {
        "title" : "div(phi,T)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false" ]
      },
      "OneOf_DivergenceSchemesDiv_Phi_passiveScalar" : {
        "title" : "div(phi,T*)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 0", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 0" ]
      },
      "OneOf_DivergenceSchemesDiv_tauMC" : {
        "title" : "div(tauMC)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWINDV_UNLIMITED" : "#/components/schemas/GaussLinearUpwindVUnlimitedDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindVUnlimitedDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel == NONE" ]
      },
      "OneOf_DivergenceSchemesDiv_phid_pressure" : {
        "title" : "div(phid,p)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_DivergenceSchemesDiv_velocity" : {
        "title" : "div(U)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWINDV_UNLIMITED" : "#/components/schemas/GaussLinearUpwindVUnlimitedDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindVUnlimitedDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_DivergenceSchemesDiv_phi_Ekp" : {
        "title" : "div(phi,Ekp)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == true" ]
      },
      "OneOf_DivergenceSchemesDiv_phirb_alpha" : {
        "title" : "div(phirb,alpha)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme",
            "GAUSS_INTERFACECOMPRESSION" : "#/components/schemas/GaussInterfaceCompressionDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussInterfaceCompressionDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == MULTIPHASE" ]
      },
      "OneOf_DivergenceSchemesDiv_phi_alpha" : {
        "title" : "div(phi,alpha)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme",
            "GAUSS_INTERFACECOMPRESSION" : "#/components/schemas/GaussInterfaceCompressionDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussInterfaceCompressionDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == MULTIPHASE" ]
      },
      "OneOf_DivergenceSchemesDiv_rhoPhi_velocity" : {
        "title" : "div(rhoPhi,U)",
        "description" : "<p>With this option, you can choose your desired divergence scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearDivergenceScheme",
            "GAUSS_LINEARUPWIND_UNLIMITED" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme",
            "GAUSS_LINEARUPWIND_LIMITEDGRAD" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme",
            "GAUSS_LIMITEDLINEAR_1" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme",
            "GAUSS_LIMITEDLINEARV_1" : "#/components/schemas/GaussLimitedLinearV1DivergenceScheme",
            "BOUNDED_GAUSS_UPWIND" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme",
            "GAUSS_UPWIND" : "#/components/schemas/GaussUpwindDivergenceScheme",
            "GAUSS_VANLEER" : "#/components/schemas/GaussVanleerDivergenceScheme",
            "GAUSS_LINEARUPWINDV_GRAD_U_" : "#/components/schemas/GaussLinearUpwindVGradUDivergenceScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindUnlimitedDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindLimitedGradDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinear1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLimitedLinearV1DivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/BoundedGaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussUpwindDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussVanleerDivergenceScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUpwindVGradUDivergenceScheme"
        } ],
        "x-showWhen" : [ "type == MULTIPHASE" ]
      },
      "OneOf_SolidNumericsSolver" : {
        "title" : "Solver",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "LDLT_V33" : "#/components/schemas/LDLTSolverV33",
            "MUMPS" : "#/components/schemas/MUMPSSolver",
            "MULTIFRONT" : "#/components/schemas/MultifrontalSolver",
            "PETSC" : "#/components/schemas/PETSCSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/LDLTSolverV33"
        }, {
          "$ref" : "#/components/schemas/MUMPSSolver"
        }, {
          "$ref" : "#/components/schemas/MultifrontalSolver"
        }, {
          "$ref" : "#/components/schemas/PETSCSolver"
        } ]
      },
      "OneOf_SolidNumericsEigenSolver" : {
        "title" : "Eigensolver Method",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SORENSEN" : "#/components/schemas/IRAMSorensen",
            "TRI_DIAG" : "#/components/schemas/Lanczos",
            "JACOBI" : "#/components/schemas/BatheWilson",
            "QZ" : "#/components/schemas/QZ"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/IRAMSorensen"
        }, {
          "$ref" : "#/components/schemas/Lanczos"
        }, {
          "$ref" : "#/components/schemas/BatheWilson"
        }, {
          "$ref" : "#/components/schemas/QZ"
        } ],
        "x-showWhen" : [ "type == FREQUENCY_ANALYSIS" ]
      },
      "OneOf_SolidNumericsMechanicalTimeIntegrationType" : {
        "title" : "Time integration type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "IMPLICIT" : "#/components/schemas/ImplicitTimeIntegrationType",
            "EXPLICIT" : "#/components/schemas/ExplicitTimeIntegrationType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ImplicitTimeIntegrationType"
        }, {
          "$ref" : "#/components/schemas/ExplicitTimeIntegrationType"
        } ],
        "x-showWhen" : [ "type == DYNAMIC_ANALYSIS", "type == THERMAL_MECHANICAL && inertiaEffect == DYNAMIC" ]
      },
      "OneOf_SolidNumericsMechanicalResolutionType" : {
        "title" : "Nonlinear resolution type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NEWTON" : "#/components/schemas/NewtonResolutionType",
            "NEWTON_KRYLOV" : "#/components/schemas/NewtonKrylovResolutionType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NewtonResolutionType"
        }, {
          "$ref" : "#/components/schemas/NewtonKrylovResolutionType"
        } ],
        "x-showWhen" : [ "type == DYNAMIC_ANALYSIS", "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true" ]
      },
      "OneOf_SolidNumericsMechanicalLineSearch" : {
        "title" : "Mechanical line search",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FALSE" : "#/components/schemas/FalseLineSearch",
            "TRUE" : "#/components/schemas/TrueLineSearch"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FalseLineSearch"
        }, {
          "$ref" : "#/components/schemas/TrueLineSearch"
        } ],
        "x-showWhen" : [ "type == DYNAMIC_ANALYSIS", "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true" ]
      },
      "OneOf_SolidNumericsThermalResolutionType" : {
        "title" : "Thermal Nonlinear resolution",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NEWTON" : "#/components/schemas/NewtonResolutionType",
            "NEWTON_KRYLOV" : "#/components/schemas/NewtonKrylovResolutionType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NewtonResolutionType"
        }, {
          "$ref" : "#/components/schemas/NewtonKrylovResolutionType"
        } ],
        "x-showWhen" : [ "type == HEAT_TRANSFER && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true" ]
      },
      "OneOf_SolidNumericsThermalLineSearch" : {
        "title" : "Thermal line search",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FALSE" : "#/components/schemas/FalseLineSearch",
            "TRUE" : "#/components/schemas/TrueLineSearch"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FalseLineSearch"
        }, {
          "$ref" : "#/components/schemas/TrueLineSearch"
        } ],
        "x-showWhen" : [ "type == HEAT_TRANSFER && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true" ]
      },
      "OneOf_StressResultControlItemStressType" : {
        "title" : "Stress type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TRESCA" : "#/components/schemas/GlobalTrescaStressType",
            "CAUCHY" : "#/components/schemas/GlobalCauchyStressType",
            "PRINCIPAL" : "#/components/schemas/GlobalPrincipalStressType",
            "VON_MISES" : "#/components/schemas/GlobalVonMisesStressType",
            "SIGNED_VON_MISES" : "#/components/schemas/GlobalSignedVonMisesStressType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GlobalTrescaStressType"
        }, {
          "$ref" : "#/components/schemas/GlobalCauchyStressType"
        }, {
          "$ref" : "#/components/schemas/GlobalPrincipalStressType"
        }, {
          "$ref" : "#/components/schemas/GlobalVonMisesStressType"
        }, {
          "$ref" : "#/components/schemas/GlobalSignedVonMisesStressType"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HARMONIC_ANALYSIS,THERMAL_MECHANICAL]" ]
      },
      "OneOf_SumFieldsCalculationResultControlItemFieldSelection" : {
        "title" : "Field selection",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "DISPLACEMENT" : "#/components/schemas/DisplacementFieldSelection",
            "FORCE" : "#/components/schemas/ForceFieldSelection",
            "MOMENT" : "#/components/schemas/MomentFieldSelection",
            "STRAIN" : "#/components/schemas/StrainFieldSelection",
            "STRESS" : "#/components/schemas/StressFieldSelection",
            "VELOCITY" : "#/components/schemas/VelocityFieldSelection",
            "ACCELERATION" : "#/components/schemas/AccelerationFieldSelection",
            "TEMPERATURE" : "#/components/schemas/TemperatureFieldSelection",
            "HEAT_FLUX" : "#/components/schemas/HeatFluxFieldSelection"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/DisplacementFieldSelection"
        }, {
          "$ref" : "#/components/schemas/ForceFieldSelection"
        }, {
          "$ref" : "#/components/schemas/MomentFieldSelection"
        }, {
          "$ref" : "#/components/schemas/StrainFieldSelection"
        }, {
          "$ref" : "#/components/schemas/StressFieldSelection"
        }, {
          "$ref" : "#/components/schemas/VelocityFieldSelection"
        }, {
          "$ref" : "#/components/schemas/AccelerationFieldSelection"
        }, {
          "$ref" : "#/components/schemas/TemperatureFieldSelection"
        }, {
          "$ref" : "#/components/schemas/HeatFluxFieldSelection"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL]" ]
      },
      "OneOf_MultiphaseBoundaryConditions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VELOCITY_INLET_V3" : "#/components/schemas/VelocityInletBC",
            "VELOCITY_OUTLET_V7" : "#/components/schemas/VelocityOutletBC",
            "PRESSURE_INLET_V31" : "#/components/schemas/PressureInletBC",
            "PRESSURE_OUTLET_V30" : "#/components/schemas/PressureOutletBC",
            "WALL_V34" : "#/components/schemas/WallBC",
            "SYMMETRY" : "#/components/schemas/SymmetryBC",
            "PERIODIC" : "#/components/schemas/PeriodicBC",
            "WEDGE" : "#/components/schemas/WedgeBC",
            "CUSTOM_V37" : "#/components/schemas/CustomFluidBC",
            "EMPTY_2D" : "#/components/schemas/Empty2DBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/VelocityInletBC"
        }, {
          "$ref" : "#/components/schemas/VelocityOutletBC"
        }, {
          "$ref" : "#/components/schemas/PressureInletBC"
        }, {
          "$ref" : "#/components/schemas/PressureOutletBC"
        }, {
          "$ref" : "#/components/schemas/WallBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryBC"
        }, {
          "$ref" : "#/components/schemas/PeriodicBC"
        }, {
          "$ref" : "#/components/schemas/WedgeBC"
        }, {
          "$ref" : "#/components/schemas/CustomFluidBC"
        }, {
          "$ref" : "#/components/schemas/Empty2DBC"
        } ]
      },
      "OneOf_DimensionalFunction_AccelerationValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_CompressibleTimeDependency" : {
        "title" : "Time dependency",
        "description" : "<p><strong>Steady-state</strong>: Steady-state simulations are time-independent, that is, the equations solved do not include time derivatives. If you are only interested in the converged solution, consider a steady-state simulation.</p><p><strong>Transient</strong>: Transient simulations account for time-dependent effects, that is, the associated flow variables vary with respect to time.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TRANSIENT" : "#/components/schemas/TransientTimeDependency",
            "STATIONARY" : "#/components/schemas/StationaryTimeDependency"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TransientTimeDependency"
        }, {
          "$ref" : "#/components/schemas/StationaryTimeDependency"
        } ]
      },
      "OneOf_CompressibleBoundaryConditions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VELOCITY_INLET_V3" : "#/components/schemas/VelocityInletBC",
            "VELOCITY_OUTLET_V7" : "#/components/schemas/VelocityOutletBC",
            "PRESSURE_INLET_V31" : "#/components/schemas/PressureInletBC",
            "PRESSURE_OUTLET_V30" : "#/components/schemas/PressureOutletBC",
            "WALL_V34" : "#/components/schemas/WallBC",
            "FAN" : "#/components/schemas/FanBC",
            "SYMMETRY" : "#/components/schemas/SymmetryBC",
            "PERIODIC" : "#/components/schemas/PeriodicBC",
            "WEDGE" : "#/components/schemas/WedgeBC",
            "CUSTOM_V37" : "#/components/schemas/CustomFluidBC",
            "EMPTY_2D" : "#/components/schemas/Empty2DBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/VelocityInletBC"
        }, {
          "$ref" : "#/components/schemas/VelocityOutletBC"
        }, {
          "$ref" : "#/components/schemas/PressureInletBC"
        }, {
          "$ref" : "#/components/schemas/PressureOutletBC"
        }, {
          "$ref" : "#/components/schemas/WallBC"
        }, {
          "$ref" : "#/components/schemas/FanBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryBC"
        }, {
          "$ref" : "#/components/schemas/PeriodicBC"
        }, {
          "$ref" : "#/components/schemas/WedgeBC"
        }, {
          "$ref" : "#/components/schemas/CustomFluidBC"
        }, {
          "$ref" : "#/components/schemas/Empty2DBC"
        } ]
      },
      "OneOf_DimensionalFunction_TemperatureValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_MinMaxFieldsCalculationResultControlItemFieldSelection" : {
        "title" : "Field selection",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "DISPLACEMENT" : "#/components/schemas/DisplacementFieldSelection",
            "FORCE" : "#/components/schemas/ForceFieldSelection",
            "STRAIN" : "#/components/schemas/StrainFieldSelection",
            "STRESS" : "#/components/schemas/StressFieldSelection",
            "VELOCITY" : "#/components/schemas/VelocityFieldSelection",
            "ACCELERATION" : "#/components/schemas/AccelerationFieldSelection",
            "TEMPERATURE" : "#/components/schemas/TemperatureFieldSelection",
            "HEAT_FLUX" : "#/components/schemas/HeatFluxFieldSelection"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/DisplacementFieldSelection"
        }, {
          "$ref" : "#/components/schemas/ForceFieldSelection"
        }, {
          "$ref" : "#/components/schemas/StrainFieldSelection"
        }, {
          "$ref" : "#/components/schemas/StressFieldSelection"
        }, {
          "$ref" : "#/components/schemas/VelocityFieldSelection"
        }, {
          "$ref" : "#/components/schemas/AccelerationFieldSelection"
        }, {
          "$ref" : "#/components/schemas/TemperatureFieldSelection"
        }, {
          "$ref" : "#/components/schemas/HeatFluxFieldSelection"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL]" ]
      },
      "OneOf_DimensionalVectorFunction_PressureValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "COMPONENT" : "#/components/schemas/ComponentVectorFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedVectorFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ComponentVectorFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedVectorFunction"
        } ]
      },
      "OneOf_DimensionalFunction_RotationSpeedValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_DimensionalFunction_DynamicViscosityValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_FlowRateMeanOutletVBCFlowRate" : {
        "title" : "Mean flow rate type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "MASS" : "#/components/schemas/MassFlow",
            "VOLUMETRIC" : "#/components/schemas/VolumetricFlow"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/MassFlow"
        }, {
          "$ref" : "#/components/schemas/VolumetricFlow"
        } ]
      },
      "OneOf_HConstThermoEquationOfState" : {
        "title" : "Equation of state",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PERFECT_GAS" : "#/components/schemas/PerfectGasEquationOfState",
            "RHO_CONST" : "#/components/schemas/RhoConstEquationOfState",
            "PERFECT_FLUID" : "#/components/schemas/PerfectFluidEquationOfState",
            "INCOMPRESSIBLE_PERFECT_GAS" : "#/components/schemas/IncompressiblePerfectGasEquationOfState",
            "ADIABATIC_PERFECT_FLUID" : "#/components/schemas/AdiabaticPerfectFluidEquationOfState",
            "PENG_ROBINSON_GAS" : "#/components/schemas/PengRobinsonGasEquationOfState"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PerfectGasEquationOfState"
        }, {
          "$ref" : "#/components/schemas/RhoConstEquationOfState"
        }, {
          "$ref" : "#/components/schemas/PerfectFluidEquationOfState"
        }, {
          "$ref" : "#/components/schemas/IncompressiblePerfectGasEquationOfState"
        }, {
          "$ref" : "#/components/schemas/AdiabaticPerfectFluidEquationOfState"
        }, {
          "$ref" : "#/components/schemas/PengRobinsonGasEquationOfState"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER]", "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY,SIMERICS_ANALYSIS]" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,SIMERICS_ANALYSIS]", "type == CONJUGATE_HEAT_TRANSFER && 2/type in [CONST,SUTHERLAND]", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && 2/type == CONST", "type == EMBEDDED_BOUNDARY && 2/type == CONST" ],
          "default" : {
            "type" : "PERFECT_GAS"
          }
        }, {
          "when" : [ "type == COUPLED_CONJUGATE_HEAT_TRANSFER && 2/type in [CONST_ISO,CONST_AN_ISO,CONST_CROSS_PLANE_ORTHO]", "type == CONJUGATE_HEAT_TRANSFER && 2/type in [CONST_ISO,CONST_AN_ISO,CONST_CROSS_PLANE_ORTHO]", "type == EMBEDDED_BOUNDARY && 2/type in [CONST_ISO,CONST_AN_ISO,CONST_CROSS_PLANE_ORTHO]" ],
          "default" : {
            "type" : "RHO_CONST"
          }
        } ]
      },
      "OneOf_AreaAverageResultControlWriteControl" : {
        "title" : "Write control",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TIME_STEP" : "#/components/schemas/TimeStepWriteControl",
            "OUTPUT_TIME" : "#/components/schemas/SynchronizeWithFieldOutputWriteControl",
            "NUMBER_OF_ITERATIONS_STEADY_STATE" : "#/components/schemas/NumberIterationsWriteControl"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TimeStepWriteControl"
        }, {
          "$ref" : "#/components/schemas/SynchronizeWithFieldOutputWriteControl"
        }, {
          "$ref" : "#/components/schemas/NumberIterationsWriteControl"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER]", "type in [CONJUGATE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY,MULTIPHASE]" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type == SIMERICS_ANALYSIS" ],
          "default" : {
            "type" : "NUMBER_OF_ITERATIONS_STEADY_STATE"
          }
        }, {
          "when" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,MULTIPHASE,CONVECTIVE_HEAT_TRANSFER]", "type in [CONJUGATE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ],
          "default" : {
            "type" : "TIME_STEP"
          }
        } ]
      },
      "OneOf_PCGSolverPreconditioner" : {
        "title" : "Preconditioner",
        "description" : "<p>Choose a preconditioner for your solver. A preconditioner improves the convergence speed of your system. Therefore, it is generally recommended. The DIC preconditioner is a very common diagonal incomplete Cholesky preconditioner.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "DIC" : "#/components/schemas/DICPreconditioner",
            "GAMG" : "#/components/schemas/GAMGSolver",
            "ILUCP" : "#/components/schemas/ILUCpPreconditioner"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/DICPreconditioner"
        }, {
          "$ref" : "#/components/schemas/GAMGSolver"
        }, {
          "$ref" : "#/components/schemas/ILUCpPreconditioner"
        } ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type in [INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE]" ],
          "default" : {
            "type" : "DIC"
          }
        }, {
          "when" : [ "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ],
          "default" : {
            "type" : "ILUCP"
          }
        } ]
      },
      "OneOf_ThermalMechanicalTimeDependency" : {
        "title" : "Time dependency",
        "description" : "<p><strong>Steady-state</strong>: Steady-state simulations are time-independent, that is, the equations solved do not include time derivatives. If you are only interested in the converged solution, consider a steady-state simulation.</p><p><strong>Transient</strong>: Transient simulations account for time-dependent effects, that is, the associated flow variables vary with respect to time.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TRANSIENT" : "#/components/schemas/TransientTimeDependency",
            "STATIONARY" : "#/components/schemas/StationaryTimeDependency"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TransientTimeDependency"
        }, {
          "$ref" : "#/components/schemas/StationaryTimeDependency"
        } ]
      },
      "OneOf_ThermalMechanicalConnectionGroups" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONTACT" : "#/components/schemas/Contact",
            "PHYSICAL_CONTACT_V36" : "#/components/schemas/PhysicalContact"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/Contact"
        }, {
          "$ref" : "#/components/schemas/PhysicalContact"
        } ]
      },
      "OneOf_ThermalMechanicalBoundaryConditions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "BOLT_PRELOAD" : "#/components/schemas/BoltPreloadBC",
            "ELASTIC_SUPPORT" : "#/components/schemas/ElasticSupportBC",
            "FIXED_SUPPORT" : "#/components/schemas/FixedSupportBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueBC",
            "FIXED_TEMPERATURE_VALUE" : "#/components/schemas/FixedTemperatureValueBC",
            "POINT_MASS" : "#/components/schemas/PointMassBC",
            "REMOTE_DISPLACEMENT_LOAD" : "#/components/schemas/RemoteDisplacementLoadBC",
            "ROTATING_MOTION" : "#/components/schemas/RotatingMotionBC",
            "SYMMETRY_PLANE" : "#/components/schemas/SymmetryPlaneBC",
            "CENTRIFUGAL_FORCE" : "#/components/schemas/CentrifugalForceBC",
            "FOLLOWER_PRESSURE" : "#/components/schemas/FollowerPressureBC",
            "FORCE_LOAD" : "#/components/schemas/ForceLoadBC",
            "NODAL_LOAD" : "#/components/schemas/NodalLoadBC",
            "PRESSURE" : "#/components/schemas/PressureBC",
            "REMOTE_FORCE_LOAD" : "#/components/schemas/RemoteForceLoadBC",
            "SURFACE_LOAD" : "#/components/schemas/SurfaceLoadBC",
            "VOLUME_LOAD" : "#/components/schemas/VolumeLoadBC",
            "SURFACE_HEAT_FLUX" : "#/components/schemas/SurfaceHeatFluxBC",
            "CONVECTIVE_HEAT_FLUX" : "#/components/schemas/ConvectiveHeatFluxBC",
            "VOLUME_HEAT_FLUX" : "#/components/schemas/VolumeHeatFluxBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/BoltPreloadBC"
        }, {
          "$ref" : "#/components/schemas/ElasticSupportBC"
        }, {
          "$ref" : "#/components/schemas/FixedSupportBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueBC"
        }, {
          "$ref" : "#/components/schemas/FixedTemperatureValueBC"
        }, {
          "$ref" : "#/components/schemas/PointMassBC"
        }, {
          "$ref" : "#/components/schemas/RemoteDisplacementLoadBC"
        }, {
          "$ref" : "#/components/schemas/RotatingMotionBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryPlaneBC"
        }, {
          "$ref" : "#/components/schemas/CentrifugalForceBC"
        }, {
          "$ref" : "#/components/schemas/FollowerPressureBC"
        }, {
          "$ref" : "#/components/schemas/ForceLoadBC"
        }, {
          "$ref" : "#/components/schemas/NodalLoadBC"
        }, {
          "$ref" : "#/components/schemas/PressureBC"
        }, {
          "$ref" : "#/components/schemas/RemoteForceLoadBC"
        }, {
          "$ref" : "#/components/schemas/SurfaceLoadBC"
        }, {
          "$ref" : "#/components/schemas/VolumeLoadBC"
        }, {
          "$ref" : "#/components/schemas/SurfaceHeatFluxBC"
        }, {
          "$ref" : "#/components/schemas/ConvectiveHeatFluxBC"
        }, {
          "$ref" : "#/components/schemas/VolumeHeatFluxBC"
        } ]
      },
      "OneOf_DimensionalFunction_DimensionlessValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_DimensionalFunction_SpecificHeatValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_DimensionalVectorFunction_ForceValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "COMPONENT" : "#/components/schemas/ComponentVectorFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedVectorFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ComponentVectorFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedVectorFunction"
        } ]
      },
      "OneOf_GradientSchemesForDefault" : {
        "title" : "Default",
        "description" : "<p>With this option, you can choose your desired gradient scheme:</p><ul><li><p>If you are unsure, try <b>Gauss linear</b> first.</p><li><p>If you require a higher-order scheme you can use <b>leastSquares</b>.</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearGradientScheme",
            "CELLLIMITED_GAUSS_LINEAR" : "#/components/schemas/CelllimitedGaussLinearGradientScheme",
            "CELLLIMITED_LEASTSQUARES" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme",
            "FOURTH" : "#/components/schemas/FourthGradientScheme",
            "LEASTSQUARES" : "#/components/schemas/LeastsquaresGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedGaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme"
        }, {
          "$ref" : "#/components/schemas/FourthGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LeastsquaresGradientScheme"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE]" ]
      },
      "OneOf_GradientSchemesGrad_pressure" : {
        "title" : "grad(p)",
        "description" : "<p>With this option, you can choose your desired gradient scheme:</p><ul><li><p>If you are unsure, try <b>Gauss linear</b> first.</p><li><p>If you require a higher-order scheme you can use <b>leastSquares</b>.</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearGradientScheme",
            "CELLLIMITED_GAUSS_LINEAR" : "#/components/schemas/CelllimitedGaussLinearGradientScheme",
            "CELLLIMITED_LEASTSQUARES" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme",
            "FOURTH" : "#/components/schemas/FourthGradientScheme",
            "LEASTSQUARES" : "#/components/schemas/LeastsquaresGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedGaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme"
        }, {
          "$ref" : "#/components/schemas/FourthGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LeastsquaresGradientScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_GradientSchemesGrad_velocity" : {
        "title" : "grad(U)",
        "description" : "<p>With this option, you can choose your desired gradient scheme:</p><ul><li><p>If you are unsure, try <b>Gauss linear</b> first.</p><li><p>If you require a higher-order scheme you can use <b>leastSquares</b>.</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearGradientScheme",
            "CELLLIMITED_GAUSS_LINEAR" : "#/components/schemas/CelllimitedGaussLinearGradientScheme",
            "CELLLIMITED_LEASTSQUARES" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme",
            "FOURTH" : "#/components/schemas/FourthGradientScheme",
            "LEASTSQUARES" : "#/components/schemas/LeastsquaresGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedGaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme"
        }, {
          "$ref" : "#/components/schemas/FourthGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LeastsquaresGradientScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == INCOMPRESSIBLE && algorithm != ICO", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false" ]
      },
      "OneOf_GradientSchemesGrad_pressureRgh" : {
        "title" : "grad(p_rgh)",
        "description" : "<p>With this option, you can choose your desired gradient scheme:</p><ul><li><p>If you are unsure, try <b>Gauss linear</b> first.</p><li><p>If you require a higher-order scheme you can use <b>leastSquares</b>.</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearGradientScheme",
            "CELLLIMITED_GAUSS_LINEAR" : "#/components/schemas/CelllimitedGaussLinearGradientScheme",
            "CELLLIMITED_LEASTSQUARES" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme",
            "FOURTH" : "#/components/schemas/FourthGradientScheme",
            "LEASTSQUARES" : "#/components/schemas/LeastsquaresGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedGaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme"
        }, {
          "$ref" : "#/components/schemas/FourthGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LeastsquaresGradientScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false" ]
      },
      "OneOf_GradientSchemesGrad_density" : {
        "title" : "grad(rho)",
        "description" : "<p>With this option, you can choose your desired gradient scheme:</p><ul><li><p>If you are unsure, try <b>Gauss linear</b> first.</p><li><p>If you require a higher-order scheme you can use <b>leastSquares</b>.</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearGradientScheme",
            "CELLLIMITED_GAUSS_LINEAR" : "#/components/schemas/CelllimitedGaussLinearGradientScheme",
            "CELLLIMITED_LEASTSQUARES" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme",
            "FOURTH" : "#/components/schemas/FourthGradientScheme",
            "LEASTSQUARES" : "#/components/schemas/LeastsquaresGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedGaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme"
        }, {
          "$ref" : "#/components/schemas/FourthGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LeastsquaresGradientScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_GradientSchemesGrad_enthalpy" : {
        "title" : "grad(h)",
        "description" : "<p>With this option, you can choose your desired gradient scheme:</p><ul><li><p>If you are unsure, try <b>Gauss linear</b> first.</p><li><p>If you require a higher-order scheme you can use <b>leastSquares</b>.</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearGradientScheme",
            "CELLLIMITED_GAUSS_LINEAR" : "#/components/schemas/CelllimitedGaussLinearGradientScheme",
            "CELLLIMITED_LEASTSQUARES" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme",
            "FOURTH" : "#/components/schemas/FourthGradientScheme",
            "LEASTSQUARES" : "#/components/schemas/LeastsquaresGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedGaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme"
        }, {
          "$ref" : "#/components/schemas/FourthGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LeastsquaresGradientScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_GradientSchemesGrad_internalEnergy" : {
        "title" : "grad(e)",
        "description" : "<p>With this option, you can choose your desired gradient scheme:</p><ul><li><p>If you are unsure, try <b>Gauss linear</b> first.</p><li><p>If you require a higher-order scheme you can use <b>leastSquares</b>.</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearGradientScheme",
            "CELLLIMITED_GAUSS_LINEAR" : "#/components/schemas/CelllimitedGaussLinearGradientScheme",
            "CELLLIMITED_LEASTSQUARES" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme",
            "FOURTH" : "#/components/schemas/FourthGradientScheme",
            "LEASTSQUARES" : "#/components/schemas/LeastsquaresGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedGaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme"
        }, {
          "$ref" : "#/components/schemas/FourthGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LeastsquaresGradientScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_GradientSchemesGrad_turbulentKineticEnergy" : {
        "title" : "grad(k)",
        "description" : "<p>With this option, you can choose your desired gradient scheme:</p><ul><li><p>If you are unsure, try <b>Gauss linear</b> first.</p><li><p>If you require a higher-order scheme you can use <b>leastSquares</b>.</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearGradientScheme",
            "CELLLIMITED_GAUSS_LINEAR" : "#/components/schemas/CelllimitedGaussLinearGradientScheme",
            "CELLLIMITED_LEASTSQUARES" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme",
            "FOURTH" : "#/components/schemas/FourthGradientScheme",
            "LEASTSQUARES" : "#/components/schemas/LeastsquaresGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedGaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme"
        }, {
          "$ref" : "#/components/schemas/FourthGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LeastsquaresGradientScheme"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [KEPSILON,KOMEGASST] && isCompressible == false", "type == CONJUGATE_HEAT_TRANSFER && turbulenceModel in [KEPSILON,KOMEGASST]" ]
      },
      "OneOf_GradientSchemesGrad_epsilonDissipationRate" : {
        "title" : "grad(epsilon)",
        "description" : "<p>With this option, you can choose your desired gradient scheme:</p><ul><li><p>If you are unsure, try <b>Gauss linear</b> first.</p><li><p>If you require a higher-order scheme you can use <b>leastSquares</b>.</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearGradientScheme",
            "CELLLIMITED_GAUSS_LINEAR" : "#/components/schemas/CelllimitedGaussLinearGradientScheme",
            "CELLLIMITED_LEASTSQUARES" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme",
            "FOURTH" : "#/components/schemas/FourthGradientScheme",
            "LEASTSQUARES" : "#/components/schemas/LeastsquaresGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedGaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme"
        }, {
          "$ref" : "#/components/schemas/FourthGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LeastsquaresGradientScheme"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel == KEPSILON && isCompressible == false", "type == CONJUGATE_HEAT_TRANSFER && turbulenceModel == KEPSILON" ]
      },
      "OneOf_GradientSchemesGrad_omegaDissipationRate" : {
        "title" : "grad(omega)",
        "description" : "<p>With this option, you can choose your desired gradient scheme:</p><ul><li><p>If you are unsure, try <b>Gauss linear</b> first.</p><li><p>If you require a higher-order scheme you can use <b>leastSquares</b>.</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearGradientScheme",
            "CELLLIMITED_GAUSS_LINEAR" : "#/components/schemas/CelllimitedGaussLinearGradientScheme",
            "CELLLIMITED_LEASTSQUARES" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme",
            "FOURTH" : "#/components/schemas/FourthGradientScheme",
            "LEASTSQUARES" : "#/components/schemas/LeastsquaresGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedGaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme"
        }, {
          "$ref" : "#/components/schemas/FourthGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LeastsquaresGradientScheme"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel == KOMEGASST && isCompressible == false", "type == CONJUGATE_HEAT_TRANSFER && turbulenceModel == KOMEGASST" ]
      },
      "OneOf_GradientSchemesGrad_nuTilda" : {
        "title" : "grad(nuTilda)",
        "description" : "<p>With this option, you can choose your desired gradient scheme:</p><ul><li><p>If you are unsure, try <b>Gauss linear</b> first.</p><li><p>If you require a higher-order scheme you can use <b>leastSquares</b>.</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearGradientScheme",
            "CELLLIMITED_GAUSS_LINEAR" : "#/components/schemas/CelllimitedGaussLinearGradientScheme",
            "CELLLIMITED_LEASTSQUARES" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme",
            "FOURTH" : "#/components/schemas/FourthGradientScheme",
            "LEASTSQUARES" : "#/components/schemas/LeastsquaresGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedGaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme"
        }, {
          "$ref" : "#/components/schemas/FourthGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LeastsquaresGradientScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && turbulenceModel == SPALARTALLMARAS && algorithm == PIMPLE", "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE] && turbulenceModel == SPALARTALLMARAS" ]
      },
      "OneOf_GradientSchemesGrad_temperature" : {
        "title" : "grad(T)",
        "description" : "<p>With this option, you can choose your desired gradient scheme:</p><ul><li><p>If you are unsure, try <b>Gauss linear</b> first.</p><li><p>If you require a higher-order scheme you can use <b>leastSquares</b>.</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearGradientScheme",
            "CELLLIMITED_GAUSS_LINEAR" : "#/components/schemas/CelllimitedGaussLinearGradientScheme",
            "CELLLIMITED_LEASTSQUARES" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme",
            "FOURTH" : "#/components/schemas/FourthGradientScheme",
            "LEASTSQUARES" : "#/components/schemas/LeastsquaresGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedGaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme"
        }, {
          "$ref" : "#/components/schemas/FourthGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LeastsquaresGradientScheme"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false" ]
      },
      "OneOf_GradientSchemesGrad_rhok" : {
        "title" : "grad(rhok)",
        "description" : "<p>With this option, you can choose your desired gradient scheme:</p><ul><li><p>If you are unsure, try <b>Gauss linear</b> first.</p><li><p>If you require a higher-order scheme you can use <b>leastSquares</b>.</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR" : "#/components/schemas/GaussLinearGradientScheme",
            "CELLLIMITED_GAUSS_LINEAR" : "#/components/schemas/CelllimitedGaussLinearGradientScheme",
            "CELLLIMITED_LEASTSQUARES" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme",
            "FOURTH" : "#/components/schemas/FourthGradientScheme",
            "LEASTSQUARES" : "#/components/schemas/LeastsquaresGradientScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedGaussLinearGradientScheme"
        }, {
          "$ref" : "#/components/schemas/CelllimitedLeastSquaresGradientScheme"
        }, {
          "$ref" : "#/components/schemas/FourthGradientScheme"
        }, {
          "$ref" : "#/components/schemas/LeastsquaresGradientScheme"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false" ]
      },
      "OneOf_PhysicalContactConnections" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FRICTIONLESS_CONTACT" : "#/components/schemas/FrictionlessContact",
            "FRICTION_CONTACT" : "#/components/schemas/FrictionContact"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FrictionlessContact"
        }, {
          "$ref" : "#/components/schemas/FrictionContact"
        } ]
      },
      "OneOf_FluidSolversVelocitySolver" : {
        "title" : "(U) Velocity",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ],
          "default" : {
            "type" : "PBICG"
          }
        }, {
          "when" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE]" ],
          "default" : {
            "type" : "SMOOTH"
          }
        } ]
      },
      "OneOf_FluidSolversVelocityFinalSolver" : {
        "title" : "(U) Velocity final",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == MULTIPHASE", "type == INCOMPRESSIBLE && algorithm == PIMPLE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT", "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER] && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_FluidSolversDensitySolver" : {
        "title" : "() Density",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAMG" : "#/components/schemas/GAMGSolver",
            "PCG" : "#/components/schemas/PCGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GAMGSolver"
        }, {
          "$ref" : "#/components/schemas/PCGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && timeDependency.type == TRANSIENT && isCompressible == true" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type == COMPRESSIBLE" ],
          "default" : {
            "type" : "PCG"
          }
        }, {
          "when" : [ "type in [CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER]" ],
          "default" : {
            "type" : "GAMG"
          }
        } ]
      },
      "OneOf_FluidSolversDensityFinalSolver" : {
        "title" : "() Density final",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAMG" : "#/components/schemas/GAMGSolver",
            "PCG" : "#/components/schemas/PCGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GAMGSolver"
        }, {
          "$ref" : "#/components/schemas/PCGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER && timeDependency.type == TRANSIENT", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && timeDependency.type == TRANSIENT && isCompressible == true" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type == COMPRESSIBLE" ],
          "default" : {
            "type" : "PCG"
          }
        }, {
          "when" : [ "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER]" ],
          "default" : {
            "type" : "GAMG"
          }
        } ]
      },
      "OneOf_FluidSolversPressureSolver" : {
        "title" : "(P) Pressure",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAMG" : "#/components/schemas/GAMGSolver",
            "PCG" : "#/components/schemas/PCGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GAMGSolver"
        }, {
          "$ref" : "#/components/schemas/PCGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_FluidSolversPressureFinalSolver" : {
        "title" : "(P) Pressure final",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAMG" : "#/components/schemas/GAMGSolver",
            "PCG" : "#/components/schemas/PCGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GAMGSolver"
        }, {
          "$ref" : "#/components/schemas/PCGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && algorithm in [PIMPLE,PISO,ICO]", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_FluidSolversTemperatureSolver" : {
        "title" : "(T) Temperature",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false", "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ],
          "default" : {
            "type" : "PBICG"
          }
        }, {
          "when" : [ "type == CONVECTIVE_HEAT_TRANSFER" ],
          "default" : {
            "type" : "SMOOTH"
          }
        } ]
      },
      "OneOf_FluidSolversTemperatureFinalSolver" : {
        "title" : "(T) Temperature final",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_FluidSolversPressureRghSolver" : {
        "title" : "(P) Modified pressure",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAMG" : "#/components/schemas/GAMGSolver",
            "PCG" : "#/components/schemas/PCGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GAMGSolver"
        }, {
          "$ref" : "#/components/schemas/PCGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,MULTIPHASE,EMBEDDED_BOUNDARY]" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,MULTIPHASE]" ],
          "default" : {
            "type" : "GAMG"
          }
        }, {
          "when" : [ "type == EMBEDDED_BOUNDARY" ],
          "default" : {
            "type" : "PCG"
          }
        } ]
      },
      "OneOf_FluidSolversPressureRghFinalSolver" : {
        "title" : "(P) Modified pressure final",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAMG" : "#/components/schemas/GAMGSolver",
            "PCG" : "#/components/schemas/PCGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GAMGSolver"
        }, {
          "$ref" : "#/components/schemas/PCGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == MULTIPHASE", "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER] && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_FluidSolversSolidEnthalpySolver" : {
        "title" : "(h<s>) Solid enthalpy",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAMG" : "#/components/schemas/GAMGSolver",
            "PCG" : "#/components/schemas/PCGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GAMGSolver"
        }, {
          "$ref" : "#/components/schemas/PCGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_FluidSolversSolidEnthalpyFinalSolver" : {
        "title" : "(h<s>) Solid enthalpy final",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAMG" : "#/components/schemas/GAMGSolver",
            "PCG" : "#/components/schemas/PCGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GAMGSolver"
        }, {
          "$ref" : "#/components/schemas/PCGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_FluidSolversEnthalpySolver" : {
        "title" : "(h) Enthalpy",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER]", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == true" ]
      },
      "OneOf_FluidSolversEnthalpyFinalSolver" : {
        "title" : "(h) Enthalpy final",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && timeDependency.type == TRANSIENT && isCompressible == true", "type == CONJUGATE_HEAT_TRANSFER && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_FluidSolversInternalEnergySolver" : {
        "title" : "(e) Internal energy",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER]", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == true" ]
      },
      "OneOf_FluidSolversInternalEnergyFinalSolver" : {
        "title" : "(e) Internal energy final",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && timeDependency.type == TRANSIENT && isCompressible == true", "type == CONJUGATE_HEAT_TRANSFER && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_FluidSolversTurbulentKineticEnergySolver" : {
        "title" : "(k) Turb. kinetic energy",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type in [INCOMPRESSIBLE,MULTIPHASE] && turbulenceModel in [KEPSILON,KOMEGA,KOMEGASST]", "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY] && turbulenceModel in [KEPSILON,KOMEGASST]" ]
      },
      "OneOf_FluidSolversTurbulentKineticEnergyFinalSolver" : {
        "title" : "(k) Turb. kinetic energy final",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == MULTIPHASE && turbulenceModel in [KEPSILON,KOMEGA,KOMEGASST]", "type == INCOMPRESSIBLE && turbulenceModel in [KEPSILON,KOMEGA,KOMEGASST] && algorithm == PIMPLE", "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && turbulenceModel in [KEPSILON,KOMEGASST] && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_FluidSolversNuTildaSolver" : {
        "title" : "() nuTilda",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && algorithm in [PIMPLE,PISO] && turbulenceModel == SPALARTALLMARAS", "type in [COMPRESSIBLE,MULTIPHASE] && turbulenceModel == SPALARTALLMARAS", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel == SPALARTALLMARAS" ]
      },
      "OneOf_FluidSolversNuTildaFinalSolver" : {
        "title" : "() nuTilda final",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && turbulenceModel == SPALARTALLMARAS && algorithm == PIMPLE", "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE] && turbulenceModel == SPALARTALLMARAS" ]
      },
      "OneOf_FluidSolversOmegaDissipationRateSolver" : {
        "title" : "() Specific dissipation rate",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type in [INCOMPRESSIBLE,MULTIPHASE] && turbulenceModel in [KOMEGA,KOMEGASST]", "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY] && turbulenceModel == KOMEGASST" ]
      },
      "OneOf_FluidSolversOmegaDissipationRateFinalSolver" : {
        "title" : "() Specific dissipation rate final",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == MULTIPHASE && turbulenceModel in [KOMEGA,KOMEGASST]", "type == INCOMPRESSIBLE && turbulenceModel in [KOMEGA,KOMEGASST] && algorithm == PIMPLE", "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && turbulenceModel == KOMEGASST && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_FluidSolversEpsilonDissipationRateSolver" : {
        "title" : "() Dissipation rate",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER,MULTIPHASE] && turbulenceModel == KEPSILON" ]
      },
      "OneOf_FluidSolversEpsilonDissipationRateFinalSolver" : {
        "title" : "() Dissipation rate final",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == MULTIPHASE && turbulenceModel == KEPSILON", "type == INCOMPRESSIBLE && turbulenceModel == KEPSILON && algorithm == PIMPLE", "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && turbulenceModel == KEPSILON && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_FluidSolversPassiveScalarSolver" : {
        "title" : "Passive scalar solver",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 0", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 0", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && numOfPassiveSpecies > 0" ]
      },
      "OneOf_FluidSolversRadiativeIntensityRaySolver" : {
        "title" : "(I) Radiative intensity ray",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PBICG" : "#/components/schemas/PBICGSolver",
            "SMOOTH" : "#/components/schemas/SmoothSolver"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PBICGSolver"
        }, {
          "$ref" : "#/components/schemas/SmoothSolver"
        } ],
        "x-showWhen" : [ "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableRadiation == true", "type == EMBEDDED_BOUNDARY && enableRadiation == true" ]
      },
      "OneOf_TransientResultControlWriteControl" : {
        "title" : "Write control",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "HIGH_RESOLUTION" : "#/components/schemas/HighResolution",
            "MODERATE_RESOLUTION" : "#/components/schemas/ModerateResolution",
            "COARSE_RESOLUTION" : "#/components/schemas/CoarseResolution",
            "CUSTOM_RESOLUTION" : "#/components/schemas/CustomResolution"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/HighResolution"
        }, {
          "$ref" : "#/components/schemas/ModerateResolution"
        }, {
          "$ref" : "#/components/schemas/CoarseResolution"
        }, {
          "$ref" : "#/components/schemas/CustomResolution"
        } ]
      },
      "OneOf_RotatingSBMRotation" : {
        "title" : "Rotation",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ANGULAR_ROTATION" : "#/components/schemas/AngularRotation",
            "VECTOR_ROTATION" : "#/components/schemas/VectorRotation"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AngularRotation"
        }, {
          "$ref" : "#/components/schemas/VectorRotation"
        } ]
      },
      "OneOf_PlateDataHoleShape" : {
        "title" : "Hole shape",
        "description" : "Shape of holes in perforated plate.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GENERAL" : "#/components/schemas/GeneralHoleShape",
            "CIRCULAR" : "#/components/schemas/CircularHoleShape"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GeneralHoleShape"
        }, {
          "$ref" : "#/components/schemas/CircularHoleShape"
        } ]
      },
      "OneOf_VelocityInletBCVelocity" : {
        "title" : "Velocity type",
        "description" : "Please choose the type of velocity boundary condition. <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/velocity-inlet-and-velocity-outlet/' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FIXED_VALUE" : "#/components/schemas/FixedValueVBC",
            "FIXED_MEAN" : "#/components/schemas/MeanValueVBC",
            "FIXED_VALUE_NO_EXPRESSION" : "#/components/schemas/FixedMagnitudeVBC",
            "FLOW_RATE_INLET_VELOCITY" : "#/components/schemas/FlowRateInletVBC",
            "FLOW_RATE_MEAN_INLET_VELOCITY" : "#/components/schemas/FlowRateMeanInletVBC",
            "FREESTREAM" : "#/components/schemas/FreestreamVBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FixedValueVBC"
        }, {
          "$ref" : "#/components/schemas/MeanValueVBC"
        }, {
          "$ref" : "#/components/schemas/FixedMagnitudeVBC"
        }, {
          "$ref" : "#/components/schemas/FlowRateInletVBC"
        }, {
          "$ref" : "#/components/schemas/FlowRateMeanInletVBC"
        }, {
          "$ref" : "#/components/schemas/FreestreamVBC"
        } ]
      },
      "OneOf_VelocityInletBCTemperature" : {
        "title" : "(T) Temperature",
        "description" : "Please choose a boundary condition for temperature (T).",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FIXED_VALUE" : "#/components/schemas/FixedValueTBC",
            "TOTAL_TEMPERATURE" : "#/components/schemas/TotalTBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FixedValueTBC"
        }, {
          "$ref" : "#/components/schemas/TotalTBC"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]", "type == SIMERICS_ANALYSIS && isCompressible == true" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ],
          "default" : {
            "type" : "FIXED_VALUE"
          }
        }, {
          "when" : [ "type == SIMERICS_ANALYSIS" ],
          "default" : {
            "type" : "TOTAL_TEMPERATURE"
          }
        } ]
      },
      "OneOf_VelocityInletBCTurbulenceIntensity" : {
        "title" : "Turbulence type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FIXED_VALUE" : "#/components/schemas/TurbulenceIntensityTIBC",
            "TURBULENCE_KINETIC_ENERGY" : "#/components/schemas/TurbulenceKineticEnergyTIBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TurbulenceIntensityTIBC"
        }, {
          "$ref" : "#/components/schemas/TurbulenceKineticEnergyTIBC"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE_PACEFISH && turbulenceModel in [KOMEGASST,KOMEGASST_DDES,KOMEGASST_IDDES]" ]
      },
      "OneOf_VelocityInletBCDissipationType" : {
        "title" : "Dissipation type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC_DISSIPATION" : "#/components/schemas/AutomaticOmegaDissipation",
            "CUSTOM_DISSIPATION" : "#/components/schemas/CustomOmegaDissipation"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutomaticOmegaDissipation"
        }, {
          "$ref" : "#/components/schemas/CustomOmegaDissipation"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE_PACEFISH && turbulenceModel in [KOMEGASST,KOMEGASST_DDES,KOMEGASST_IDDES]" ]
      },
      "OneOf_VelocityInletBCNetRadiativeHeatFlux" : {
        "title" : "Radiative behaviour",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GREYBODY_DIFFUSIVE" : "#/components/schemas/GreybodyDiffusiveRSBC",
            "OPEN_WINDOW" : "#/components/schemas/OpenWindowRSBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GreybodyDiffusiveRSBC"
        }, {
          "$ref" : "#/components/schemas/OpenWindowRSBC"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && enableRadiation == true", "type == CONJUGATE_HEAT_TRANSFER && enableRadiation == true" ]
      },
      "OneOf_VelocityInletBCRadiativeIntensityRay" : {
        "title" : "Radiative behaviour",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GREYBODY_DIFFUSIVE_RAY" : "#/components/schemas/GreybodyDiffusiveRayBC",
            "OPEN_BOUNDARY_RAY" : "#/components/schemas/OpenBoundaryRayBC",
            "SEMI_OPEN_BOUNDARY_RAY" : "#/components/schemas/SemiOpenBoundaryRayBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GreybodyDiffusiveRayBC"
        }, {
          "$ref" : "#/components/schemas/OpenBoundaryRayBC"
        }, {
          "$ref" : "#/components/schemas/SemiOpenBoundaryRayBC"
        } ],
        "x-showWhen" : [ "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableRadiation == true", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableSolarLoad == true" ]
      },
      "OneOf_AdvancedROISettingsWindTunnelSize" : {
        "title" : "Wind tunnel size",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "WIND_TUNNEL_SIZE_MODERATE" : "#/components/schemas/WindTunnelSizeModerate",
            "WIND_TUNNEL_SIZE_LARGE" : "#/components/schemas/WindTunnelSizeLarge",
            "WIND_TUNNEL_SIZE_CUSTOM" : "#/components/schemas/WindTunnelSizeCustom"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/WindTunnelSizeModerate"
        }, {
          "$ref" : "#/components/schemas/WindTunnelSizeLarge"
        }, {
          "$ref" : "#/components/schemas/WindTunnelSizeCustom"
        } ]
      },
      "OneOf_StatisticalAveragingResultControlV2SamplingInterval" : {
        "title" : "Sampling interval",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "HIGH_RESOLUTION" : "#/components/schemas/HighResolution",
            "MODERATE_RESOLUTION" : "#/components/schemas/ModerateResolution",
            "COARSE_RESOLUTION" : "#/components/schemas/CoarseResolution",
            "CUSTOM_RESOLUTION" : "#/components/schemas/CustomResolution"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/HighResolution"
        }, {
          "$ref" : "#/components/schemas/ModerateResolution"
        }, {
          "$ref" : "#/components/schemas/CoarseResolution"
        }, {
          "$ref" : "#/components/schemas/CustomResolution"
        } ]
      },
      "OneOf_FieldCalculationsPressureResultControlPressureType" : {
        "title" : "Pressure type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TOTAL_PRESSURE" : "#/components/schemas/TotalPressurePressureType",
            "STATIC_PRESSURE" : "#/components/schemas/StaticPressurePressureType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TotalPressurePressureType"
        }, {
          "$ref" : "#/components/schemas/StaticPressurePressureType"
        } ]
      },
      "OneOf_FieldCalculationsPressureResultControlResultType" : {
        "title" : "Result type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PRESSURE_VALUE" : "#/components/schemas/PressureValueResultType",
            "PRESSURE_COEFFICIENT" : "#/components/schemas/PressureCoefficientResultType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PressureValueResultType"
        }, {
          "$ref" : "#/components/schemas/PressureCoefficientResultType"
        } ]
      },
      "OneOf_CoupledConjugateHeatTransferBoundaryConditions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VELOCITY_INLET_V3" : "#/components/schemas/VelocityInletBC",
            "PRESSURE_OUTLET_V30" : "#/components/schemas/PressureOutletBC",
            "WALL_V34" : "#/components/schemas/WallBC",
            "FAN" : "#/components/schemas/FanBC",
            "SYMMETRY" : "#/components/schemas/SymmetryBC",
            "NATURAL_CONVECTION_INLET_OUTLET" : "#/components/schemas/NaturalConvectionInletOutletBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/VelocityInletBC"
        }, {
          "$ref" : "#/components/schemas/PressureOutletBC"
        }, {
          "$ref" : "#/components/schemas/WallBC"
        }, {
          "$ref" : "#/components/schemas/FanBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryBC"
        }, {
          "$ref" : "#/components/schemas/NaturalConvectionInletOutletBC"
        } ]
      },
      "OneOf_ConvectiveHeatTransferTimeDependency" : {
        "title" : "Time dependency",
        "description" : "<p><strong>Steady-state</strong>: Steady-state simulations are time-independent, that is, the equations solved do not include time derivatives. If you are only interested in the converged solution, consider a steady-state simulation.</p><p><strong>Transient</strong>: Transient simulations account for time-dependent effects, that is, the associated flow variables vary with respect to time.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TRANSIENT" : "#/components/schemas/TransientTimeDependency",
            "STATIONARY" : "#/components/schemas/StationaryTimeDependency"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TransientTimeDependency"
        }, {
          "$ref" : "#/components/schemas/StationaryTimeDependency"
        } ]
      },
      "OneOf_ConvectiveHeatTransferBoundaryConditions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VELOCITY_INLET_V3" : "#/components/schemas/VelocityInletBC",
            "VELOCITY_OUTLET_V7" : "#/components/schemas/VelocityOutletBC",
            "PRESSURE_INLET_V31" : "#/components/schemas/PressureInletBC",
            "PRESSURE_OUTLET_V30" : "#/components/schemas/PressureOutletBC",
            "WALL_V34" : "#/components/schemas/WallBC",
            "FAN" : "#/components/schemas/FanBC",
            "SYMMETRY" : "#/components/schemas/SymmetryBC",
            "WEDGE" : "#/components/schemas/WedgeBC",
            "CUSTOM_V37" : "#/components/schemas/CustomFluidBC",
            "EMPTY_2D" : "#/components/schemas/Empty2DBC",
            "NATURAL_CONVECTION_INLET_OUTLET" : "#/components/schemas/NaturalConvectionInletOutletBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/VelocityInletBC"
        }, {
          "$ref" : "#/components/schemas/VelocityOutletBC"
        }, {
          "$ref" : "#/components/schemas/PressureInletBC"
        }, {
          "$ref" : "#/components/schemas/PressureOutletBC"
        }, {
          "$ref" : "#/components/schemas/WallBC"
        }, {
          "$ref" : "#/components/schemas/FanBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryBC"
        }, {
          "$ref" : "#/components/schemas/WedgeBC"
        }, {
          "$ref" : "#/components/schemas/CustomFluidBC"
        }, {
          "$ref" : "#/components/schemas/Empty2DBC"
        }, {
          "$ref" : "#/components/schemas/NaturalConvectionInletOutletBC"
        } ]
      },
      "OneOf_SolidMaterialMaterialBehavior" : {
        "title" : "Material behavior",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "LINEAR_ELASTIC" : "#/components/schemas/LinearElasticMaterialBehavior",
            "HYPER_ELASTIC" : "#/components/schemas/HyperElasticMaterialBehavior",
            "PLASTIC" : "#/components/schemas/PlasticMaterialBehavior"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/LinearElasticMaterialBehavior"
        }, {
          "$ref" : "#/components/schemas/HyperElasticMaterialBehavior"
        }, {
          "$ref" : "#/components/schemas/PlasticMaterialBehavior"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HARMONIC_ANALYSIS,FREQUENCY_ANALYSIS,THERMAL_MECHANICAL]" ]
      },
      "OneOf_SolidMaterialConductivity" : {
        "title" : "Conductivity",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ISOTROPIC" : "#/components/schemas/IsotropicConductivity",
            "ORTHOTROPIC" : "#/components/schemas/OrthotropicConductivity"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/IsotropicConductivity"
        }, {
          "$ref" : "#/components/schemas/OrthotropicConductivity"
        } ],
        "x-showWhen" : [ "type in [HEAT_TRANSFER,THERMAL_MECHANICAL]" ]
      },
      "OneOf_DimensionalVectorFunction_SpeedValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "COMPONENT" : "#/components/schemas/ComponentVectorFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedVectorFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ComponentVectorFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedVectorFunction"
        } ]
      },
      "OneOf_IncompressibleMaterialViscosityModel" : {
        "title" : "Viscosity model",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NEWTONIAN" : "#/components/schemas/NewtonianViscosityModel",
            "POWER_LAW" : "#/components/schemas/PowerLawViscosityModel",
            "HERSCHEL_BULKLEY" : "#/components/schemas/HerschelBulkleyViscosityModel",
            "CROSS_POWER_LAW" : "#/components/schemas/CrossPowerLawViscosityModel",
            "BIRD_CARREAU" : "#/components/schemas/BirdCarreauViscosityModel"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NewtonianViscosityModel"
        }, {
          "$ref" : "#/components/schemas/PowerLawViscosityModel"
        }, {
          "$ref" : "#/components/schemas/HerschelBulkleyViscosityModel"
        }, {
          "$ref" : "#/components/schemas/CrossPowerLawViscosityModel"
        }, {
          "$ref" : "#/components/schemas/BirdCarreauViscosityModel"
        } ]
      },
      "OneOf_PacefishMeshLegacyRefinements" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "REGION_PACEFISH" : "#/components/schemas/RegionRefinementPacefish",
            "SURFACE_PACEFISH" : "#/components/schemas/SurfaceRefinementPacefish"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/RegionRefinementPacefish"
        }, {
          "$ref" : "#/components/schemas/SurfaceRefinementPacefish"
        } ]
      },
      "OneOf_FluxSchemesForDefault" : {
        "title" : "Default",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TADMOR" : "#/components/schemas/TadmorFluxScheme",
            "KURGANOV" : "#/components/schemas/KurganovFluxScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TadmorFluxScheme"
        }, {
          "$ref" : "#/components/schemas/KurganovFluxScheme"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE" ]
      },
      "OneOf_DimensionalFunction_LengthValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_FrictionlessContactContactSolutionMethod" : {
        "title" : "Solution method",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUGMENTED_LAGRANGE" : "#/components/schemas/AugmentedLagrangeMethod",
            "PENALTY_METHOD" : "#/components/schemas/PenaltyMethod"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AugmentedLagrangeMethod"
        }, {
          "$ref" : "#/components/schemas/PenaltyMethod"
        } ]
      },
      "OneOf_FrictionlessContactFictitiousClearance" : {
        "title" : "Fictitious clearance",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NO_FICTITIOUS_CLEARANCE" : "#/components/schemas/NoFictitiousClearance",
            "WITH_FICTITIOUS_CLEARANCE" : "#/components/schemas/WithFictitiousClearance"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NoFictitiousClearance"
        }, {
          "$ref" : "#/components/schemas/WithFictitiousClearance"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,THERMAL_MECHANICAL]" ]
      },
      "OneOf_StressTensor_PressureSigmaXX" : {
        "title" : "<xx>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_StressTensor_PressureSigmaYY" : {
        "title" : "<yy>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_StressTensor_PressureSigmaZZ" : {
        "title" : "<zz>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_StressTensor_PressureSigmaYZ" : {
        "title" : "<yz>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_StressTensor_PressureSigmaXZ" : {
        "title" : "<xz>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_StressTensor_PressureSigmaXY" : {
        "title" : "<xy>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_FrictionContactContactSolutionMethod" : {
        "title" : "Solution method",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUGMENTED_LAGRANGE" : "#/components/schemas/AugmentedLagrangeMethod",
            "PENALTY_METHOD" : "#/components/schemas/PenaltyMethod"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AugmentedLagrangeMethod"
        }, {
          "$ref" : "#/components/schemas/PenaltyMethod"
        } ]
      },
      "OneOf_FrictionContactFrictionCoefficient" : {
        "title" : "Friction coefficient",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FRICTION_AUGMENTATION_COEF" : "#/components/schemas/FrictionAugmentedLagrangeCoef",
            "FRICTION_PENALTY_COEF" : "#/components/schemas/FrictionPenaltyCoef"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FrictionAugmentedLagrangeCoef"
        }, {
          "$ref" : "#/components/schemas/FrictionPenaltyCoef"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,THERMAL_MECHANICAL]" ]
      },
      "OneOf_FrictionContactFictitiousClearance" : {
        "title" : "Fictitious clearance",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NO_FICTITIOUS_CLEARANCE" : "#/components/schemas/NoFictitiousClearance",
            "WITH_FICTITIOUS_CLEARANCE" : "#/components/schemas/WithFictitiousClearance"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NoFictitiousClearance"
        }, {
          "$ref" : "#/components/schemas/WithFictitiousClearance"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,THERMAL_MECHANICAL]" ]
      },
      "OneOf_NaturalConvectionInletOutletBCNetRadiativeHeatFlux" : {
        "title" : "Radiative behaviour",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GREYBODY_DIFFUSIVE" : "#/components/schemas/GreybodyDiffusiveRSBC",
            "OPEN_WINDOW" : "#/components/schemas/OpenWindowRSBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GreybodyDiffusiveRSBC"
        }, {
          "$ref" : "#/components/schemas/OpenWindowRSBC"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && enableRadiation == true", "type == CONJUGATE_HEAT_TRANSFER && enableRadiation == true" ]
      },
      "OneOf_RegionInterfaceInterfaceThermal" : {
        "title" : "Interface type",
        "description" : "<p>Choose how the temperature is treated at the interface:</p><ul><li><p>For an interface where thermal energy could be exchanged freely between the two domains, choose <b>Coupled</b>.</p><li><p>For an interface where thermal energy cannot be exchanged between the domains, e.g. isolation, choose <b>Adiabatic</b>.</p><li><p>If the contact resistance is known (e.g. due to an imperfectly matching interface, choose <b>Total resistance</b>.</p><li><p>Conversely, if the contact conductance is known, choose <b>Specific conductance</b>.</p><li><p>To specify presence of thin layers with known thermal conductivity and thickness, choose <b>Thin layer resistance</b>.</p></ul><a href='https://www.simscale.com/docs/simulation-setup/contacts/#interface-settings' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "COUPLED" : "#/components/schemas/CoupledInterfaceThermal",
            "ADIABATIC" : "#/components/schemas/AdiabaticInterfaceThermal",
            "TOTAL_RESISTANCE" : "#/components/schemas/TotalResistanceInterfaceThermal",
            "SPECIFIC_CONDUCTANCE" : "#/components/schemas/SpecificConductanceInterfaceThermal",
            "CONTACT_INTERFACE_MATERIAL" : "#/components/schemas/ContactInterfaceMaterialInterfaceThermal"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CoupledInterfaceThermal"
        }, {
          "$ref" : "#/components/schemas/AdiabaticInterfaceThermal"
        }, {
          "$ref" : "#/components/schemas/TotalResistanceInterfaceThermal"
        }, {
          "$ref" : "#/components/schemas/SpecificConductanceInterfaceThermal"
        }, {
          "$ref" : "#/components/schemas/ContactInterfaceMaterialInterfaceThermal"
        } ]
      },
      "OneOf_BasicEmbeddedBoundaryMeshingRefinementStrategy" : {
        "title" : "Refinement strategy",
        "description" : "Strategy used to refine the cells adjacent to the geometry surface, the same procedure is applied to the inner and outer part of the geometry. The propagation of the refinement can be controlled by either one of the following parameters:<br> <b>Refinement propagation layers:</b> The specified number of background grid layers controls the distance from the geometry surface up which the cells will be refined. It ensures that all cells adjacent to the geometry are refined.<br> <b>Distance from surface:</b> Cells whose center lies within the specified distance from the geometry are refined. If the value of the distance is too small, some cells might not be refined.<br>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "LAYER_REFINEMENT" : "#/components/schemas/EmbeddedNumberOfCellsRefinement",
            "DISTANCE_REFINEMENT" : "#/components/schemas/EmbeddedDistanceRefinement"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/EmbeddedNumberOfCellsRefinement"
        }, {
          "$ref" : "#/components/schemas/EmbeddedDistanceRefinement"
        } ]
      },
      "OneOf_NewtonResolutionTypeConvergenceCriteria" : {
        "title" : "Convergence criteria",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "RELATIVE" : "#/components/schemas/RelativeConvergenceCriteria",
            "ABSOLUTE" : "#/components/schemas/AbsoluteConvergenceCriteria"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/RelativeConvergenceCriteria"
        }, {
          "$ref" : "#/components/schemas/AbsoluteConvergenceCriteria"
        } ]
      },
      "OneOf_NewtonResolutionTypeJacobianMatrix" : {
        "title" : "Jacobian matrix",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TANGENT" : "#/components/schemas/TangentJacobianMatrix",
            "ELASTIC" : "#/components/schemas/ElasticJacobianMatrix"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TangentJacobianMatrix"
        }, {
          "$ref" : "#/components/schemas/ElasticJacobianMatrix"
        } ]
      },
      "OneOf_PressureInletBCGaugePressure" : {
        "title" : "Pressure type",
        "description" : "Please choose a boundary condition for gauge pressure (p). <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/pressure-inlet-and-pressure-outlet/' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FIXED_VALUE" : "#/components/schemas/FixedValuePBC",
            "TOTAL_PRESSURE" : "#/components/schemas/TotalPBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FixedValuePBC"
        }, {
          "$ref" : "#/components/schemas/TotalPBC"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE", "type == SIMERICS_ANALYSIS && isCompressible == false" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type == INCOMPRESSIBLE" ],
          "default" : {
            "type" : "TOTAL_PRESSURE"
          }
        }, {
          "when" : [ "type == SIMERICS_ANALYSIS" ],
          "default" : {
            "type" : "FIXED_VALUE"
          }
        } ]
      },
      "OneOf_PressureInletBCTemperature" : {
        "title" : "(T) Temperature",
        "description" : "Please choose a boundary condition for temperature (T).",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FIXED_VALUE" : "#/components/schemas/FixedValueTBC",
            "TOTAL_TEMPERATURE" : "#/components/schemas/TotalTBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FixedValueTBC"
        }, {
          "$ref" : "#/components/schemas/TotalTBC"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER]", "type == SIMERICS_ANALYSIS && isCompressible == true" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER]" ],
          "default" : {
            "type" : "FIXED_VALUE"
          }
        }, {
          "when" : [ "type == SIMERICS_ANALYSIS" ],
          "default" : {
            "type" : "TOTAL_TEMPERATURE"
          }
        } ]
      },
      "OneOf_PressureInletBCNetRadiativeHeatFlux" : {
        "title" : "Radiative behaviour",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GREYBODY_DIFFUSIVE" : "#/components/schemas/GreybodyDiffusiveRSBC",
            "OPEN_WINDOW" : "#/components/schemas/OpenWindowRSBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GreybodyDiffusiveRSBC"
        }, {
          "$ref" : "#/components/schemas/OpenWindowRSBC"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && enableRadiation == true", "type == CONJUGATE_HEAT_TRANSFER && enableRadiation == true" ]
      },
      "OneOf_DimensionalFunction_ThermalTransmittanceValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_CoulombFrictionNonlinearityResolution" : {
        "title" : "Nonlinearity resolution",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NEWTON_V29" : "#/components/schemas/NewtonFrictionNonLinearityResolution",
            "FIXED_POINT" : "#/components/schemas/FixedPointFrictionNonLinearityResolution"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NewtonFrictionNonLinearityResolution"
        }, {
          "$ref" : "#/components/schemas/FixedPointFrictionNonLinearityResolution"
        } ]
      },
      "OneOf_FieldChangeRetimingEventFieldSelection" : {
        "title" : "Field selection",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "DISPLACEMENT" : "#/components/schemas/DisplacementField",
            "CAUCHY_STRESS_TENSOR" : "#/components/schemas/CauchyStressTensorField",
            "INTERN_VARIABLES" : "#/components/schemas/InternVariablesField"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/DisplacementField"
        }, {
          "$ref" : "#/components/schemas/CauchyStressTensorField"
        }, {
          "$ref" : "#/components/schemas/InternVariablesField"
        } ]
      },
      "OneOf_FieldChangeRetimingEventTimestepCalculationType" : {
        "title" : "Time step calculation",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "MIXED" : "#/components/schemas/MixedTimestepCalculationType",
            "FIELD_CHANGE_TARGET" : "#/components/schemas/FieldChangeTargetCalculationType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/MixedTimestepCalculationType"
        }, {
          "$ref" : "#/components/schemas/FieldChangeTargetCalculationType"
        } ]
      },
      "OneOf_PrescribedOptionalFunctionValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_DimensionalFunction_SpeedValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_RotatingMotionTypeRotation" : {
        "title" : "Rotation",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ANGULAR_ROTATION" : "#/components/schemas/AngularRotation",
            "VECTOR_ROTATION" : "#/components/schemas/VectorRotation"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AngularRotation"
        }, {
          "$ref" : "#/components/schemas/VectorRotation"
        } ]
      },
      "OneOf_DimensionalVectorFunction_AccelerationValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "COMPONENT" : "#/components/schemas/ComponentVectorFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedVectorFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ComponentVectorFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedVectorFunction"
        } ]
      },
      "OneOf_SolarCalculatorSunDirection" : {
        "title" : "Sun direction",
        "description" : "<p><b>Sun direction</b> in the solar radiation model.</p> <ul><li><b>Custom:</b> Define the sun direction vector directly.</li><li><b>Time and place:</b> Set the sun direction by defining a location, a date and a time. This assumes the Z-vector to point upwards into the sky.</li></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TIME_AND_PLACE" : "#/components/schemas/TimeAndPlaceSunDirection",
            "CUSTOM_SOLAR_DIRECTION" : "#/components/schemas/CustomSunDirection"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TimeAndPlaceSunDirection"
        }, {
          "$ref" : "#/components/schemas/CustomSunDirection"
        } ]
      },
      "OneOf_SolarCalculatorSolarLoad" : {
        "title" : "Solar load",
        "description" : "<p><b>Solar load</b> in solar radiation model. <b>Diffuse solar load</b> affects all walls with a derived heat flux boundary condition externally if the outer surface absorptivity is greater than  zero. <b>Direct solar load</b> affects all walls either externally or internally if these are not shadowed by other walls, are non-transparent and have an absorptivity greater than zero. </p> <ul><li><b>Custom:</b> Define diffusive and directed solar load directly.</li><li><b>Fair weather conditions:</b> Define the external and internal solar load by a number of coefficients in the Fair weather condtions model.This assumes the Z-vector to point upwards into the sky.</li></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUSTOM_SOLAR_LOAD" : "#/components/schemas/CustomSolarLoad",
            "FAIR_WEATHER_CONDITIONS" : "#/components/schemas/FairWeatherConditions"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CustomSolarLoad"
        }, {
          "$ref" : "#/components/schemas/FairWeatherConditions"
        } ]
      },
      "OneOf_FluidResultControlsForcesMoments" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FORCES_AND_MOMENTS" : "#/components/schemas/ForcesMomentsResultControl",
            "FORCE_AND_MOMENT_COEFFICIENTS" : "#/components/schemas/ForceMomentCoefficientsResultControl"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ForcesMomentsResultControl"
        }, {
          "$ref" : "#/components/schemas/ForceMomentCoefficientsResultControl"
        } ]
      },
      "OneOf_FluidResultControlsSurfaceData" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AREA_AVERAGE" : "#/components/schemas/AreaAverageResultControl",
            "AREA_INTEGRAL" : "#/components/schemas/AreaIntegralResultControl",
            "PRESSURE_DIFFERENCE" : "#/components/schemas/PressureDifferenceResultControl"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AreaAverageResultControl"
        }, {
          "$ref" : "#/components/schemas/AreaIntegralResultControl"
        }, {
          "$ref" : "#/components/schemas/PressureDifferenceResultControl"
        } ]
      },
      "OneOf_FluidResultControlsFieldCalculations" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PRESSURE" : "#/components/schemas/FieldCalculationsPressureResultControl",
            "TURBULENCE" : "#/components/schemas/FieldCalculationsTurbulenceResultControl",
            "VELOCITY" : "#/components/schemas/FieldCalculationsVelocityResultControl",
            "FRICTION_VELOCITY_U_TAU" : "#/components/schemas/FieldCalculationsFrictionVelocityResultControl",
            "SURFACE_NORMALS" : "#/components/schemas/FieldCalculationsSurfaceNormalsResultControl",
            "WALL_FLUXES" : "#/components/schemas/FieldCalculationsWallFluxesResultControl",
            "THERMAL_COMFORT" : "#/components/schemas/FieldCalculationsThermalComfortResultControl",
            "ADJOINT_SENSITIVITIES" : "#/components/schemas/FieldCalculationsAdjointSensitivitiesResultControl"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FieldCalculationsPressureResultControl"
        }, {
          "$ref" : "#/components/schemas/FieldCalculationsTurbulenceResultControl"
        }, {
          "$ref" : "#/components/schemas/FieldCalculationsVelocityResultControl"
        }, {
          "$ref" : "#/components/schemas/FieldCalculationsFrictionVelocityResultControl"
        }, {
          "$ref" : "#/components/schemas/FieldCalculationsSurfaceNormalsResultControl"
        }, {
          "$ref" : "#/components/schemas/FieldCalculationsWallFluxesResultControl"
        }, {
          "$ref" : "#/components/schemas/FieldCalculationsThermalComfortResultControl"
        }, {
          "$ref" : "#/components/schemas/FieldCalculationsAdjointSensitivitiesResultControl"
        } ]
      },
      "OneOf_IncompressibleTimeDependency" : {
        "title" : "Time dependency",
        "description" : "<p><strong>Steady-state</strong>: Steady-state simulations are time-independent, that is, the equations solved do not include time derivatives. If you are only interested in the converged solution, consider a steady-state simulation.</p><p><strong>Transient</strong>: Transient simulations account for time-dependent effects, that is, the associated flow variables vary with respect to time.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TRANSIENT" : "#/components/schemas/TransientTimeDependency",
            "STATIONARY" : "#/components/schemas/StationaryTimeDependency"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TransientTimeDependency"
        }, {
          "$ref" : "#/components/schemas/StationaryTimeDependency"
        } ]
      },
      "OneOf_IncompressibleBoundaryConditions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VELOCITY_INLET_V3" : "#/components/schemas/VelocityInletBC",
            "VELOCITY_OUTLET_V7" : "#/components/schemas/VelocityOutletBC",
            "PRESSURE_INLET_V31" : "#/components/schemas/PressureInletBC",
            "PRESSURE_OUTLET_V30" : "#/components/schemas/PressureOutletBC",
            "WALL_V34" : "#/components/schemas/WallBC",
            "FAN" : "#/components/schemas/FanBC",
            "SYMMETRY" : "#/components/schemas/SymmetryBC",
            "PERIODIC" : "#/components/schemas/PeriodicBC",
            "WEDGE" : "#/components/schemas/WedgeBC",
            "CUSTOM_V37" : "#/components/schemas/CustomFluidBC",
            "EMPTY_2D" : "#/components/schemas/Empty2DBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/VelocityInletBC"
        }, {
          "$ref" : "#/components/schemas/VelocityOutletBC"
        }, {
          "$ref" : "#/components/schemas/PressureInletBC"
        }, {
          "$ref" : "#/components/schemas/PressureOutletBC"
        }, {
          "$ref" : "#/components/schemas/WallBC"
        }, {
          "$ref" : "#/components/schemas/FanBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryBC"
        }, {
          "$ref" : "#/components/schemas/PeriodicBC"
        }, {
          "$ref" : "#/components/schemas/WedgeBC"
        }, {
          "$ref" : "#/components/schemas/CustomFluidBC"
        }, {
          "$ref" : "#/components/schemas/Empty2DBC"
        } ]
      },
      "OneOf_CustomFluidBCVelocity" : {
        "title" : "Velocity type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ADVECTIVE" : "#/components/schemas/AdvectiveVBC",
            "SYMMETRY" : "#/components/schemas/SymmetryVBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientVBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueVBC",
            "FIXED_MEAN" : "#/components/schemas/MeanValueVBC",
            "FLOW_RATE_INLET_VELOCITY" : "#/components/schemas/FlowRateInletVBC",
            "FLOW_RATE_MEAN_INLET_VELOCITY" : "#/components/schemas/FlowRateMeanInletVBC",
            "FREESTREAM" : "#/components/schemas/FreestreamVBC",
            "INLET_OUTLET" : "#/components/schemas/InletOutletVBC",
            "MOVING_WALL_VELOCITY" : "#/components/schemas/MovingWallVBC",
            "NO_SLIP" : "#/components/schemas/NoSlipVBC",
            "OUTLET_MEAN_PHASE" : "#/components/schemas/OutletMeanPhaseVBC",
            "PRESSURE_INLET_VELOCITY" : "#/components/schemas/PressureInletVBC",
            "PRESSURE_INLET_OUTLET_VELOCITY" : "#/components/schemas/PressureInletOutletVBC",
            "ROTATING_WALL_VELOCITY" : "#/components/schemas/RotatingWallVBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientVBC",
            "SLIP" : "#/components/schemas/SlipVBC",
            "TURBULENT_DFSEM_INLET" : "#/components/schemas/TurbulentDFSEMInletVBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AdvectiveVBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryVBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientVBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueVBC"
        }, {
          "$ref" : "#/components/schemas/MeanValueVBC"
        }, {
          "$ref" : "#/components/schemas/FlowRateInletVBC"
        }, {
          "$ref" : "#/components/schemas/FlowRateMeanInletVBC"
        }, {
          "$ref" : "#/components/schemas/FreestreamVBC"
        }, {
          "$ref" : "#/components/schemas/InletOutletVBC"
        }, {
          "$ref" : "#/components/schemas/MovingWallVBC"
        }, {
          "$ref" : "#/components/schemas/NoSlipVBC"
        }, {
          "$ref" : "#/components/schemas/OutletMeanPhaseVBC"
        }, {
          "$ref" : "#/components/schemas/PressureInletVBC"
        }, {
          "$ref" : "#/components/schemas/PressureInletOutletVBC"
        }, {
          "$ref" : "#/components/schemas/RotatingWallVBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientVBC"
        }, {
          "$ref" : "#/components/schemas/SlipVBC"
        }, {
          "$ref" : "#/components/schemas/TurbulentDFSEMInletVBC"
        } ]
      },
      "OneOf_CustomFluidBCPressure" : {
        "title" : "Pressure type",
        "description" : "Please choose a boundary condition for pressure (p). <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/pressure-inlet-and-pressure-outlet/' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ADVECTIVE" : "#/components/schemas/AdvectivePBC",
            "SYMMETRY" : "#/components/schemas/SymmetryPBC",
            "FAN_PRESSURE" : "#/components/schemas/FanPBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientPBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValuePBC",
            "FREESTREAM" : "#/components/schemas/FreestreamPBC",
            "FIXED_MEAN" : "#/components/schemas/MeanValuePBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientPBC",
            "TOTAL_PRESSURE" : "#/components/schemas/TotalPBC",
            "WAVE_TRANSMISSIVE" : "#/components/schemas/WaveTransmissivePBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AdvectivePBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryPBC"
        }, {
          "$ref" : "#/components/schemas/FanPBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientPBC"
        }, {
          "$ref" : "#/components/schemas/FixedValuePBC"
        }, {
          "$ref" : "#/components/schemas/FreestreamPBC"
        }, {
          "$ref" : "#/components/schemas/MeanValuePBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientPBC"
        }, {
          "$ref" : "#/components/schemas/TotalPBC"
        }, {
          "$ref" : "#/components/schemas/WaveTransmissivePBC"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE" ]
      },
      "OneOf_CustomFluidBCPressureRgh" : {
        "title" : "Pressure type",
        "description" : "Please choose a boundary condition for modified pressure (p_rgh). <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/pressure-inlet-and-pressure-outlet/' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SYMMETRY" : "#/components/schemas/SymmetryPBC",
            "FAN_PRESSURE" : "#/components/schemas/FanPBC",
            "FIXED_FLUX_PRESSURE" : "#/components/schemas/FixedFluxPBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientPBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValuePBC",
            "FREESTREAM" : "#/components/schemas/FreestreamPBC",
            "FIXED_MEAN" : "#/components/schemas/MeanValuePBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientPBC",
            "TOTAL_PRESSURE" : "#/components/schemas/TotalPBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SymmetryPBC"
        }, {
          "$ref" : "#/components/schemas/FanPBC"
        }, {
          "$ref" : "#/components/schemas/FixedFluxPBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientPBC"
        }, {
          "$ref" : "#/components/schemas/FixedValuePBC"
        }, {
          "$ref" : "#/components/schemas/FreestreamPBC"
        }, {
          "$ref" : "#/components/schemas/MeanValuePBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientPBC"
        }, {
          "$ref" : "#/components/schemas/TotalPBC"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == true", "type in [CONJUGATE_HEAT_TRANSFER,MULTIPHASE]" ]
      },
      "OneOf_CustomFluidBCGaugePressure" : {
        "title" : "Pressure type",
        "description" : "Please choose a boundary condition for gauge pressure (p). <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/pressure-inlet-and-pressure-outlet/' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SYMMETRY" : "#/components/schemas/SymmetryPBC",
            "FAN_PRESSURE" : "#/components/schemas/FanPBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientPBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValuePBC",
            "FREESTREAM" : "#/components/schemas/FreestreamPBC",
            "FIXED_MEAN" : "#/components/schemas/MeanValuePBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientPBC",
            "TOTAL_PRESSURE" : "#/components/schemas/TotalPBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SymmetryPBC"
        }, {
          "$ref" : "#/components/schemas/FanPBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientPBC"
        }, {
          "$ref" : "#/components/schemas/FixedValuePBC"
        }, {
          "$ref" : "#/components/schemas/FreestreamPBC"
        }, {
          "$ref" : "#/components/schemas/MeanValuePBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientPBC"
        }, {
          "$ref" : "#/components/schemas/TotalPBC"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE" ]
      },
      "OneOf_CustomFluidBCGaugePressureRgh" : {
        "title" : "Pressure type",
        "description" : "Please choose a boundary condition for modified gauge pressure (p_rgh). <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/pressure-inlet-and-pressure-outlet/' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SYMMETRY" : "#/components/schemas/SymmetryPBC",
            "FAN_PRESSURE" : "#/components/schemas/FanPBC",
            "FIXED_FLUX_PRESSURE" : "#/components/schemas/FixedFluxPBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientPBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValuePBC",
            "FREESTREAM" : "#/components/schemas/FreestreamPBC",
            "FIXED_MEAN" : "#/components/schemas/MeanValuePBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientPBC",
            "TOTAL_PRESSURE" : "#/components/schemas/TotalPBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SymmetryPBC"
        }, {
          "$ref" : "#/components/schemas/FanPBC"
        }, {
          "$ref" : "#/components/schemas/FixedFluxPBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientPBC"
        }, {
          "$ref" : "#/components/schemas/FixedValuePBC"
        }, {
          "$ref" : "#/components/schemas/FreestreamPBC"
        }, {
          "$ref" : "#/components/schemas/MeanValuePBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientPBC"
        }, {
          "$ref" : "#/components/schemas/TotalPBC"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false" ]
      },
      "OneOf_CustomFluidBCTemperature" : {
        "title" : "Temperature type",
        "description" : "Please choose a boundary condition for temperature (T).",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "EXTERNAL_WALL_HEAT_FLUX_TEMPERATURE" : "#/components/schemas/ExternalWallHeatFluxTBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientTBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueTBC",
            "INLET_OUTLET" : "#/components/schemas/InletOutletTBC",
            "ADIABATIC" : "#/components/schemas/AdiabaticTBC",
            "SYMMETRY" : "#/components/schemas/SymmetryTBC",
            "TOTAL_TEMPERATURE" : "#/components/schemas/TotalTBC",
            "TURBULENT_HEAT_FLUX_TEMPERATURE" : "#/components/schemas/TurbulentHeatFluxTBC",
            "WALL_HEAT_TRANSFER" : "#/components/schemas/WallHeatTransferTBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ExternalWallHeatFluxTBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientTBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueTBC"
        }, {
          "$ref" : "#/components/schemas/InletOutletTBC"
        }, {
          "$ref" : "#/components/schemas/AdiabaticTBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryTBC"
        }, {
          "$ref" : "#/components/schemas/TotalTBC"
        }, {
          "$ref" : "#/components/schemas/TurbulentHeatFluxTBC"
        }, {
          "$ref" : "#/components/schemas/WallHeatTransferTBC"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER]" ]
      },
      "OneOf_CustomFluidBCTurbulentKineticEnergy" : {
        "title" : "Turb. kinetic energy type",
        "description" : "Please choose a boundary condition for turbulent kinetic energy (k).",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SYMMETRY" : "#/components/schemas/SymmetryTKEBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientTKEBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueTKEBC",
            "INLET_OUTLET" : "#/components/schemas/InletOutletTKEBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientTKEBC",
            "TURBULENT_INTENSITY_KINETIC_ENERGY_INLET" : "#/components/schemas/IntensityKineticEnergyInletTKEBC",
            "WALL_FUNCTION" : "#/components/schemas/WallFunctionTKEBC",
            "FULL_RESOLUTION" : "#/components/schemas/FullResolutionTKEBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SymmetryTKEBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientTKEBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueTKEBC"
        }, {
          "$ref" : "#/components/schemas/InletOutletTKEBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientTKEBC"
        }, {
          "$ref" : "#/components/schemas/IntensityKineticEnergyInletTKEBC"
        }, {
          "$ref" : "#/components/schemas/WallFunctionTKEBC"
        }, {
          "$ref" : "#/components/schemas/FullResolutionTKEBC"
        } ],
        "x-showWhen" : [ "type in [INCOMPRESSIBLE,MULTIPHASE] && turbulenceModel in [KEPSILON,KOMEGA,KOMEGASST]", "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER] && turbulenceModel in [KEPSILON,KOMEGASST]" ]
      },
      "OneOf_CustomFluidBCOmegaDissipationRate" : {
        "title" : "Specific dissipation rate type",
        "description" : "Specific dissipation rate (omega) represents the specific rate of dissipation of turbulent kinetic energy (k). <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-omega-sst/' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SYMMETRY" : "#/components/schemas/SymmetryOBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientOBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueOBC",
            "INLET_OUTLET" : "#/components/schemas/InletOutletOBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientOBC",
            "WALL_FUNCTION" : "#/components/schemas/WallFunctionOBC",
            "FULL_RESOLUTION" : "#/components/schemas/FullResolutionOBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SymmetryOBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientOBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueOBC"
        }, {
          "$ref" : "#/components/schemas/InletOutletOBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientOBC"
        }, {
          "$ref" : "#/components/schemas/WallFunctionOBC"
        }, {
          "$ref" : "#/components/schemas/FullResolutionOBC"
        } ],
        "x-showWhen" : [ "type in [INCOMPRESSIBLE,MULTIPHASE] && turbulenceModel in [KOMEGA,KOMEGASST]", "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER] && turbulenceModel == KOMEGASST" ]
      },
      "OneOf_CustomFluidBCEpsilonDissipationRate" : {
        "title" : "Dissipation rate type",
        "description" : "Dissipation rate (epsilon) represents the rate of dissipation of turbulent kinetic energy (k). <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-epsilon/' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SYMMETRY" : "#/components/schemas/SymmetryEBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientEBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueEBC",
            "INLET_OUTLET" : "#/components/schemas/InletOutletEBC",
            "TURBULENCE_MIXING_LENGTH_DISSIPATION_RATE_INLET" : "#/components/schemas/MixingLengthInletEBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientEBC",
            "WALL_FUNCTION" : "#/components/schemas/WallFunctionEBC",
            "FULL_RESOLUTION" : "#/components/schemas/FullResolutionEBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SymmetryEBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientEBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueEBC"
        }, {
          "$ref" : "#/components/schemas/InletOutletEBC"
        }, {
          "$ref" : "#/components/schemas/MixingLengthInletEBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientEBC"
        }, {
          "$ref" : "#/components/schemas/WallFunctionEBC"
        }, {
          "$ref" : "#/components/schemas/FullResolutionEBC"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE] && turbulenceModel == KEPSILON" ]
      },
      "OneOf_CustomFluidBCEddyViscosity" : {
        "title" : "(<t>) Eddy viscosity",
        "description" : "Dynamic eddy viscosity (muSgs) is a sub-grid scale viscosity used to model the unresolved turbulent eddies in Large Eddy Simulations. Choose a boundary type.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CALCULATED" : "#/components/schemas/CalculatedEVBC",
            "SYMMETRY" : "#/components/schemas/SymmetryEVBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientEVBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueEVBC",
            "INLET_OUTLET" : "#/components/schemas/InletOutletEVBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientEVBC",
            "WALL_FUNCTION" : "#/components/schemas/WallFunctionEVBC",
            "FULL_RESOLUTION" : "#/components/schemas/FullResolutionEVBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CalculatedEVBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryEVBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientEVBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueEVBC"
        }, {
          "$ref" : "#/components/schemas/InletOutletEVBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientEVBC"
        }, {
          "$ref" : "#/components/schemas/WallFunctionEVBC"
        }, {
          "$ref" : "#/components/schemas/FullResolutionEVBC"
        } ],
        "x-showWhen" : [ "type in [INCOMPRESSIBLE,MULTIPHASE] && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS]", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS] && isCompressible == false" ]
      },
      "OneOf_CustomFluidBCEddyViscosityCompressible" : {
        "title" : "(<t>) Eddy viscosity",
        "description" : "Dissipation rate (epsilon) represents the rate of dissipation of turbulent kinetic energy (k). <a href='https://www.simscale.com/docs/simulation-setup/global-settings/k-epsilon/' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CALCULATED" : "#/components/schemas/CalculatedEVCBC",
            "SYMMETRY" : "#/components/schemas/SymmetryEVCBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientEVCBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueEVCBC",
            "INLET_OUTLET" : "#/components/schemas/InletOutletEVCBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientEVCBC",
            "WALL_FUNCTION" : "#/components/schemas/WallFunctionEVCBC",
            "FULL_RESOLUTION" : "#/components/schemas/FullResolutionEVCBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CalculatedEVCBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryEVCBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientEVCBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueEVCBC"
        }, {
          "$ref" : "#/components/schemas/InletOutletEVCBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientEVCBC"
        }, {
          "$ref" : "#/components/schemas/WallFunctionEVCBC"
        }, {
          "$ref" : "#/components/schemas/FullResolutionEVCBC"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS]", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS] && isCompressible == true", "type == CONJUGATE_HEAT_TRANSFER && turbulenceModel == SMAGORINSKY" ]
      },
      "OneOf_CustomFluidBCNuTilda" : {
        "title" : "() nuTilda",
        "description" : "nuTilda is a Spalart-Allmaras variable which is a function of eddy viscosity. Choose a boundary type.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SYMMETRY" : "#/components/schemas/SymmetryNBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientNBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueNBC",
            "INLET_OUTLET" : "#/components/schemas/InletOutletNBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientNBC",
            "WALL_FUNCTION" : "#/components/schemas/WallFunctionNBC",
            "FULL_RESOLUTION" : "#/components/schemas/FullResolutionNBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SymmetryNBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientNBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueNBC"
        }, {
          "$ref" : "#/components/schemas/InletOutletNBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientNBC"
        }, {
          "$ref" : "#/components/schemas/WallFunctionNBC"
        }, {
          "$ref" : "#/components/schemas/FullResolutionNBC"
        } ],
        "x-showWhen" : [ "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE] && turbulenceModel == SPALARTALLMARAS" ]
      },
      "OneOf_CustomFluidBCTurbulentThermalDiffusivity" : {
        "title" : "(<t>) Turb. thermal diffusivity",
        "description" : "Dynamic turbulent thermal diffusivity (alpha_t) represents the rate of turbulent heat transfer.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CALCULATED" : "#/components/schemas/CalculatedTDBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientTDBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueTDBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientTDBC",
            "SYMMETRY" : "#/components/schemas/SymmetryTDBC",
            "WALL_FUNCTION" : "#/components/schemas/WallFunctionTDBC",
            "FULL_RESOLUTION" : "#/components/schemas/FullResolutionTDBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CalculatedTDBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientTDBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueTDBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientTDBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryTDBC"
        }, {
          "$ref" : "#/components/schemas/WallFunctionTDBC"
        }, {
          "$ref" : "#/components/schemas/FullResolutionTDBC"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && turbulenceModel in [KEPSILON,KOMEGASST]", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [KEPSILON,KOMEGASST] && isCompressible == true" ]
      },
      "OneOf_CustomFluidBCTurbulentThermalDiffusivityCompressible" : {
        "title" : "(<t>) Turb. thermal diffusivity",
        "description" : "Dynamic turbulent thermal diffusivity (alpha_Sgs) represents the rate of turbulent heat transfer.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CALCULATED" : "#/components/schemas/CalculatedTDCBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientTDCBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueTDCBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientTDCBC",
            "SYMMETRY" : "#/components/schemas/SymmetryTDCBC",
            "WALL_FUNCTION" : "#/components/schemas/WallFunctionTDCBC",
            "FULL_RESOLUTION" : "#/components/schemas/FullResolutionTDCBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CalculatedTDCBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientTDCBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueTDCBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientTDCBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryTDCBC"
        }, {
          "$ref" : "#/components/schemas/WallFunctionTDCBC"
        }, {
          "$ref" : "#/components/schemas/FullResolutionTDCBC"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS]", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS] && isCompressible == true", "type == CONJUGATE_HEAT_TRANSFER && turbulenceModel == SMAGORINSKY" ]
      },
      "OneOf_CustomFluidBCTurbulentDynamicViscosity" : {
        "title" : "(<t>) Turb. dynamic viscosity",
        "description" : "Turbulent dynamic viscosity is a model viscosity. It is required to account for the transport and dissipation effects lost in averaging the turbulence. Choose a boundary type.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CALCULATED" : "#/components/schemas/CalculatedDVBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientDVBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueDVBC",
            "INLET_OUTLET" : "#/components/schemas/InletOutletDVBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientDVBC",
            "SYMMETRY" : "#/components/schemas/SymmetryDVBC",
            "WALL_FUNCTION" : "#/components/schemas/WallFunctionDVBC",
            "FULL_RESOLUTION" : "#/components/schemas/FullResolutionDVBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CalculatedDVBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientDVBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueDVBC"
        }, {
          "$ref" : "#/components/schemas/InletOutletDVBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientDVBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryDVBC"
        }, {
          "$ref" : "#/components/schemas/WallFunctionDVBC"
        }, {
          "$ref" : "#/components/schemas/FullResolutionDVBC"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && turbulenceModel in [KEPSILON,KOMEGASST]", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [NONE,KEPSILON,KOMEGASST] && isCompressible == true" ]
      },
      "OneOf_CustomFluidBCPassiveScalars" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientPSBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValuePSBC",
            "INLET_OUTLET" : "#/components/schemas/InletOutletPSBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientPSBC",
            "SYMMETRY" : "#/components/schemas/SymmetryPSBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FixedGradientPSBC"
        }, {
          "$ref" : "#/components/schemas/FixedValuePSBC"
        }, {
          "$ref" : "#/components/schemas/InletOutletPSBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientPSBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryPSBC"
        } ]
      },
      "OneOf_CustomFluidBCPhaseFraction" : {
        "title" : "Phase fraction",
        "description" : "Please choose a boundary condition for phase fraction (alpha).",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT_CONTACT_ANGLE" : "#/components/schemas/ConstantContactAnglePFBC",
            "DYNAMIC_CONTACT_ANGLE" : "#/components/schemas/DynamicContactAnglePFBC",
            "FIXED_GRADIENT" : "#/components/schemas/FixedGradientPFBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValuePFBC",
            "FLOW_DEPENDENT_VALUE" : "#/components/schemas/FlowDependentValuePFBC",
            "INLET_OUTLET" : "#/components/schemas/InletOutletPFBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientPFBC",
            "SYMMETRY" : "#/components/schemas/SymmetryPFBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantContactAnglePFBC"
        }, {
          "$ref" : "#/components/schemas/DynamicContactAnglePFBC"
        }, {
          "$ref" : "#/components/schemas/FixedGradientPFBC"
        }, {
          "$ref" : "#/components/schemas/FixedValuePFBC"
        }, {
          "$ref" : "#/components/schemas/FlowDependentValuePFBC"
        }, {
          "$ref" : "#/components/schemas/InletOutletPFBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientPFBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryPFBC"
        } ],
        "x-showWhen" : [ "type == MULTIPHASE" ]
      },
      "OneOf_CustomFluidBCNetRadiativeHeatFlux" : {
        "title" : "Radiative behaviour",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GREYBODY_DIFFUSIVE" : "#/components/schemas/GreybodyDiffusiveRSBC",
            "OPEN_WINDOW" : "#/components/schemas/OpenWindowRSBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GreybodyDiffusiveRSBC"
        }, {
          "$ref" : "#/components/schemas/OpenWindowRSBC"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && enableRadiation == true", "type == CONJUGATE_HEAT_TRANSFER && enableRadiation == true" ]
      },
      "OneOf_FrequencyAnalysisBoundaryConditions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "BOLT_PRELOAD" : "#/components/schemas/BoltPreloadBC",
            "ELASTIC_SUPPORT" : "#/components/schemas/ElasticSupportBC",
            "FIXED_SUPPORT" : "#/components/schemas/FixedSupportBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueBC",
            "POINT_MASS" : "#/components/schemas/PointMassBC",
            "REMOTE_DISPLACEMENT_LOAD" : "#/components/schemas/RemoteDisplacementLoadBC",
            "SYMMETRY_PLANE" : "#/components/schemas/SymmetryPlaneBC",
            "CENTRIFUGAL_FORCE" : "#/components/schemas/CentrifugalForceBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/BoltPreloadBC"
        }, {
          "$ref" : "#/components/schemas/ElasticSupportBC"
        }, {
          "$ref" : "#/components/schemas/FixedSupportBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueBC"
        }, {
          "$ref" : "#/components/schemas/PointMassBC"
        }, {
          "$ref" : "#/components/schemas/RemoteDisplacementLoadBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryPlaneBC"
        }, {
          "$ref" : "#/components/schemas/CentrifugalForceBC"
        } ]
      },
      "OneOf_FixedCoeffMediumOrientation" : {
        "title" : "Orientation",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CARTESIAN" : "#/components/schemas/CartesianOrientation",
            "CUSTOM" : "#/components/schemas/CustomOrientation"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CartesianOrientation"
        }, {
          "$ref" : "#/components/schemas/CustomOrientation"
        } ]
      },
      "OneOf_DimensionalFunction_VolumetricFlowRateValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_PrandtlLesDeltaDeltaCoefficient" : {
        "title" : "Delta coefficient",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SMOOTH" : "#/components/schemas/SmoothLesDelta",
            "CUBE_ROOT_VOL" : "#/components/schemas/CubeRootVolLesDelta"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SmoothLesDelta"
        }, {
          "$ref" : "#/components/schemas/CubeRootVolLesDelta"
        } ]
      },
      "OneOf_PETSCSolverPreconditioner" : {
        "title" : "Preconditioner",
        "description" : "Choose the preconditioner for the iterative solver:<ul><li><p><b>incomplete LDLT</b> performs an incomplete Cholesky decomposition.</p></ul><ul><li><p><b>MUMPS LDLT</b> performs a complete Cholesky decomposition in single precision via the MUMPS package.</p></ul><ul><li><p><b>Jacobi</b> is a standard diagonal preconditioner.</p></ul><ul><li><p><b>SOR</b> uses the method of <i>Successive Over-Relaxation</i>.</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "MUMPS_LDLT" : "#/components/schemas/MUMPSPreconditoner",
            "INCOMPLETE_LDLT_V33" : "#/components/schemas/IncompletePreconditionerV33",
            "JACOBI" : "#/components/schemas/JacobiPreconditioner",
            "SOR" : "#/components/schemas/SorPreconditioner",
            "INACTIVE" : "#/components/schemas/InactivePreconditioner"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/MUMPSPreconditoner"
        }, {
          "$ref" : "#/components/schemas/IncompletePreconditionerV33"
        }, {
          "$ref" : "#/components/schemas/JacobiPreconditioner"
        }, {
          "$ref" : "#/components/schemas/SorPreconditioner"
        }, {
          "$ref" : "#/components/schemas/InactivePreconditioner"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL]" ]
      },
      "OneOf_StaticAnalysisConnectionGroups" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONTACT" : "#/components/schemas/Contact",
            "PHYSICAL_CONTACT_V36" : "#/components/schemas/PhysicalContact"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/Contact"
        }, {
          "$ref" : "#/components/schemas/PhysicalContact"
        } ]
      },
      "OneOf_StaticAnalysisBoundaryConditions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "BOLT_PRELOAD" : "#/components/schemas/BoltPreloadBC",
            "ELASTIC_SUPPORT" : "#/components/schemas/ElasticSupportBC",
            "FIXED_SUPPORT" : "#/components/schemas/FixedSupportBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueBC",
            "POINT_MASS" : "#/components/schemas/PointMassBC",
            "REMOTE_DISPLACEMENT_LOAD" : "#/components/schemas/RemoteDisplacementLoadBC",
            "ROTATING_MOTION" : "#/components/schemas/RotatingMotionBC",
            "SYMMETRY_PLANE" : "#/components/schemas/SymmetryPlaneBC",
            "CENTRIFUGAL_FORCE" : "#/components/schemas/CentrifugalForceBC",
            "FOLLOWER_PRESSURE" : "#/components/schemas/FollowerPressureBC",
            "FORCE_LOAD" : "#/components/schemas/ForceLoadBC",
            "NODAL_LOAD" : "#/components/schemas/NodalLoadBC",
            "PRESSURE" : "#/components/schemas/PressureBC",
            "REMOTE_FORCE_LOAD" : "#/components/schemas/RemoteForceLoadBC",
            "SURFACE_LOAD" : "#/components/schemas/SurfaceLoadBC",
            "VOLUME_LOAD" : "#/components/schemas/VolumeLoadBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/BoltPreloadBC"
        }, {
          "$ref" : "#/components/schemas/ElasticSupportBC"
        }, {
          "$ref" : "#/components/schemas/FixedSupportBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueBC"
        }, {
          "$ref" : "#/components/schemas/PointMassBC"
        }, {
          "$ref" : "#/components/schemas/RemoteDisplacementLoadBC"
        }, {
          "$ref" : "#/components/schemas/RotatingMotionBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryPlaneBC"
        }, {
          "$ref" : "#/components/schemas/CentrifugalForceBC"
        }, {
          "$ref" : "#/components/schemas/FollowerPressureBC"
        }, {
          "$ref" : "#/components/schemas/ForceLoadBC"
        }, {
          "$ref" : "#/components/schemas/NodalLoadBC"
        }, {
          "$ref" : "#/components/schemas/PressureBC"
        }, {
          "$ref" : "#/components/schemas/RemoteForceLoadBC"
        }, {
          "$ref" : "#/components/schemas/SurfaceLoadBC"
        }, {
          "$ref" : "#/components/schemas/VolumeLoadBC"
        } ]
      },
      "OneOf_FlowRateStableOutletVBCFlowRate" : {
        "title" : "Flow rate type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "MASS" : "#/components/schemas/MassFlow",
            "VOLUMETRIC" : "#/components/schemas/VolumetricFlow"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/MassFlow"
        }, {
          "$ref" : "#/components/schemas/VolumetricFlow"
        } ]
      },
      "OneOf_SolidSimulationControlTimestepDefinition" : {
        "title" : "Time step definition",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC_V27" : "#/components/schemas/AutoTimestepDefinition",
            "MANUAL_V19" : "#/components/schemas/ManualTimestepDefinition"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutoTimestepDefinition"
        }, {
          "$ref" : "#/components/schemas/ManualTimestepDefinition"
        } ],
        "x-showWhen" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == DYNAMIC_ANALYSIS", "type == THERMAL_MECHANICAL && timeDependency.type == TRANSIENT && nonLinearAnalysis == true" ]
      },
      "OneOf_SolidSimulationControlPseudoTimeStepping" : {
        "title" : "Pseudo time stepping",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SINGLE_STEP" : "#/components/schemas/SingleStepPseudoTimeStepping",
            "STEPPING_LIST_V18" : "#/components/schemas/SteppingListPseudoTimeStepping"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SingleStepPseudoTimeStepping"
        }, {
          "$ref" : "#/components/schemas/SteppingListPseudoTimeStepping"
        } ],
        "x-showWhen" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == false", "type == HEAT_TRANSFER && timeDependency.type == TRANSIENT", "type == THERMAL_MECHANICAL && nonLinearAnalysis == false && inertiaEffect == STATIC && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_SolidSimulationControlWriteControlDefinition" : {
        "title" : "Write control definition",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "WRITE_INTERVAL" : "#/components/schemas/WriteIntervalWriteControl",
            "ALL_COMPUTED" : "#/components/schemas/AllComputedWriteControl",
            "INITIAL" : "#/components/schemas/InitialTimestepsWriteControl",
            "USER_DEFINED_V21" : "#/components/schemas/UserDefinedWriteControl"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/WriteIntervalWriteControl"
        }, {
          "$ref" : "#/components/schemas/AllComputedWriteControl"
        }, {
          "$ref" : "#/components/schemas/InitialTimestepsWriteControl"
        }, {
          "$ref" : "#/components/schemas/UserDefinedWriteControl"
        } ],
        "x-showWhen" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == DYNAMIC_ANALYSIS", "type == HEAT_TRANSFER && timeDependency.type == TRANSIENT", "type == THERMAL_MECHANICAL && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_SolidSimulationControlExcitationFrequencies" : {
        "title" : "Excitation frequencies",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SINGLE" : "#/components/schemas/SingleFrequency",
            "LIST_V20" : "#/components/schemas/FrequencyList"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SingleFrequency"
        }, {
          "$ref" : "#/components/schemas/FrequencyList"
        } ],
        "x-showWhen" : [ "type == HARMONIC_ANALYSIS" ]
      },
      "OneOf_SolidSimulationControlEigenfrequencyScope" : {
        "title" : "Eigenfrequency Scope",
        "description" : "<p>Select how you want to control natural frequencies to be computed:<br> <li><b>First modes</b>: The first <i>Number of modes</i> will be searched and computed, in the order of low to high frequency.</li><li><b>Frequency range</b>: All the modes within the range of frequencies will be searched and computed. The frequency range is specified by a <i>Start frequency</i> and an <i>End frequency</i>.</li><li><b>Center frequency</b>: Compute the <i>Number of modes</i> closest to the frequency defined by <i>Center frequency</i>.</li></p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FIRSTMODE" : "#/components/schemas/FirstMode",
            "RANGE" : "#/components/schemas/FrequencyRange",
            "CENTER" : "#/components/schemas/CenterFrequency"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FirstMode"
        }, {
          "$ref" : "#/components/schemas/FrequencyRange"
        }, {
          "$ref" : "#/components/schemas/CenterFrequency"
        } ],
        "x-showWhen" : [ "type == FREQUENCY_ANALYSIS" ]
      },
      "OneOf_ForceFieldSelectionForceType" : {
        "title" : "Force type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "REACTION" : "#/components/schemas/ReactionForceType",
            "NODAL" : "#/components/schemas/NodalForceType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ReactionForceType"
        }, {
          "$ref" : "#/components/schemas/NodalForceType"
        } ]
      },
      "OneOf_AdvancedModellingPorousObjects" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GENERAL_POROSITY" : "#/components/schemas/GeneralDarcyForchheimerPacefish",
            "POROUS_TREE" : "#/components/schemas/PorousTree"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GeneralDarcyForchheimerPacefish"
        }, {
          "$ref" : "#/components/schemas/PorousTree"
        } ]
      },
      "OneOf_TemporalResponseResultControlItemFieldSelection" : {
        "title" : "Field selection",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "DISPLACEMENT" : "#/components/schemas/DisplacementFieldSelection",
            "FORCE" : "#/components/schemas/ForceFieldSelection",
            "MOMENT" : "#/components/schemas/MomentFieldSelection",
            "STRAIN" : "#/components/schemas/StrainFieldSelection",
            "STRESS" : "#/components/schemas/StressFieldSelection",
            "VELOCITY" : "#/components/schemas/VelocityFieldSelection",
            "ACCELERATION" : "#/components/schemas/AccelerationFieldSelection",
            "TEMPERATURE" : "#/components/schemas/TemperatureFieldSelection",
            "HEAT_FLUX" : "#/components/schemas/HeatFluxFieldSelection"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/DisplacementFieldSelection"
        }, {
          "$ref" : "#/components/schemas/ForceFieldSelection"
        }, {
          "$ref" : "#/components/schemas/MomentFieldSelection"
        }, {
          "$ref" : "#/components/schemas/StrainFieldSelection"
        }, {
          "$ref" : "#/components/schemas/StressFieldSelection"
        }, {
          "$ref" : "#/components/schemas/VelocityFieldSelection"
        }, {
          "$ref" : "#/components/schemas/AccelerationFieldSelection"
        }, {
          "$ref" : "#/components/schemas/TemperatureFieldSelection"
        }, {
          "$ref" : "#/components/schemas/HeatFluxFieldSelection"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,HEAT_TRANSFER,THERMAL_MECHANICAL]" ]
      },
      "OneOf_ProbePointsResultControlWriteControl" : {
        "title" : "Write control",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TIME_STEP" : "#/components/schemas/TimeStepWriteControl",
            "OUTPUT_TIME" : "#/components/schemas/SynchronizeWithFieldOutputWriteControl",
            "HIGH_RESOLUTION" : "#/components/schemas/HighResolution",
            "MODERATE_RESOLUTION" : "#/components/schemas/ModerateResolution",
            "COARSE_RESOLUTION" : "#/components/schemas/CoarseResolution",
            "CUSTOM_RESOLUTION" : "#/components/schemas/CustomResolution"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TimeStepWriteControl"
        }, {
          "$ref" : "#/components/schemas/SynchronizeWithFieldOutputWriteControl"
        }, {
          "$ref" : "#/components/schemas/HighResolution"
        }, {
          "$ref" : "#/components/schemas/ModerateResolution"
        }, {
          "$ref" : "#/components/schemas/CoarseResolution"
        }, {
          "$ref" : "#/components/schemas/CustomResolution"
        } ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE,EMBEDDED_BOUNDARY]" ],
          "default" : {
            "type" : "TIME_STEP"
          }
        }, {
          "when" : [ "type in [INCOMPRESSIBLE_PACEFISH,WIND_COMFORT]" ],
          "default" : {
            "type" : "MODERATE_RESOLUTION"
          }
        } ]
      },
      "OneOf_ConstCrossPlaneOrthotropicTransportOrientation" : {
        "title" : "Orientation",
        "description" : "<p>Defines the direction on which the thermal conductivity will act:<br> <ul><li><strong>Cartesian</strong>: the cross-plane conductivity acts along the Z-axis and the in-plane conductivity acts on the X-Y plane.</li><li><strong>Custom</strong>: the cross-plane conductivity is aligned with the cross-plane orientation defined by the X, Y, Z components, and the in-plane conductivity acts on the plane orthogonal to the cross-plane orientation.</li></ul></p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CARTESIAN" : "#/components/schemas/CartesianOrientation",
            "CROSS_PLANE" : "#/components/schemas/CrossPlaneCustomOrientation"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CartesianOrientation"
        }, {
          "$ref" : "#/components/schemas/CrossPlaneCustomOrientation"
        } ]
      },
      "OneOf_DimensionalVectorFunction_LengthValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "COMPONENT" : "#/components/schemas/ComponentVectorFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedVectorFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ComponentVectorFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedVectorFunction"
        } ]
      },
      "OneOf_MomentFieldSelectionMomentType" : {
        "title" : "Moment type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "REACTION" : "#/components/schemas/ReactionMomentType",
            "NODAL" : "#/components/schemas/NodalMomentType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ReactionMomentType"
        }, {
          "$ref" : "#/components/schemas/NodalMomentType"
        } ]
      },
      "OneOf_SolidCompressibleMaterialTransport" : {
        "title" : "Conductivity type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONST_ISO" : "#/components/schemas/ConstIsoTransport",
            "CONST_AN_ISO" : "#/components/schemas/ConstAnIsoTransport",
            "CONST_CROSS_PLANE_ORTHO" : "#/components/schemas/ConstCrossPlaneOrthotropicTransport"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstIsoTransport"
        }, {
          "$ref" : "#/components/schemas/ConstAnIsoTransport"
        }, {
          "$ref" : "#/components/schemas/ConstCrossPlaneOrthotropicTransport"
        } ]
      },
      "OneOf_DerivedHeatFluxWallThermal" : {
        "title" : "Wall thermal",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NO_RESISTANCE" : "#/components/schemas/NoWallThermal",
            "TOTAL_RESISTANCE" : "#/components/schemas/TotalResistanceWallThermal",
            "SPECIFIC_CONDUCTANCE" : "#/components/schemas/SpecificConductanceWallThermal",
            "CONTACT_INTERFACE_MATERIAL" : "#/components/schemas/LayerWallThermal"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NoWallThermal"
        }, {
          "$ref" : "#/components/schemas/TotalResistanceWallThermal"
        }, {
          "$ref" : "#/components/schemas/SpecificConductanceWallThermal"
        }, {
          "$ref" : "#/components/schemas/LayerWallThermal"
        } ]
      },
      "OneOf_NewRegionRefinementPacefishV38MeshSizing" : {
        "title" : "Sizing",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC" : "#/components/schemas/AutomaticMeshSizing",
            "MANUAL_REGION_PACEFISH" : "#/components/schemas/ManualRegionSizingPacefish"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutomaticMeshSizing"
        }, {
          "$ref" : "#/components/schemas/ManualRegionSizingPacefish"
        } ]
      },
      "OneOf_FluidSimulationControlAdjustableTimestep" : {
        "title" : "Adjustable time step",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "INACTIVE_TIMESTEP" : "#/components/schemas/InactiveAdjustableTimestep",
            "ACTIVE_TIMESTEP" : "#/components/schemas/ActiveAdjustableTimestep"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/InactiveAdjustableTimestep"
        }, {
          "$ref" : "#/components/schemas/ActiveAdjustableTimestep"
        } ],
        "x-showWhen" : [ "type == MULTIPHASE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT", "type == CONJUGATE_HEAT_TRANSFER && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && timeDependency.type == TRANSIENT", "type == INCOMPRESSIBLE && timeDependency.type == TRANSIENT && algorithm == PIMPLE" ]
      },
      "OneOf_FluidSimulationControlWriteControl" : {
        "title" : "Write control",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TIME_STEP" : "#/components/schemas/TimeStepWriteControl",
            "CLOCK_TIME" : "#/components/schemas/ClockTimeWriteControl",
            "RUNTIME" : "#/components/schemas/RunTimeWriteControl",
            "CPU_TIME" : "#/components/schemas/CpuTimeWriteControl",
            "ADJUSTABLE_RUNTIME" : "#/components/schemas/AdjustableRuntimeWriteControl",
            "NUMBER_OF_ITERATIONS_STEADY_STATE" : "#/components/schemas/NumberIterationsWriteControl"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TimeStepWriteControl"
        }, {
          "$ref" : "#/components/schemas/ClockTimeWriteControl"
        }, {
          "$ref" : "#/components/schemas/RunTimeWriteControl"
        }, {
          "$ref" : "#/components/schemas/CpuTimeWriteControl"
        }, {
          "$ref" : "#/components/schemas/AdjustableRuntimeWriteControl"
        }, {
          "$ref" : "#/components/schemas/NumberIterationsWriteControl"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,MULTIPHASE]", "type in [CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]", "type == SIMERICS_ANALYSIS" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type == SIMERICS_ANALYSIS && timeDependency.type == STATIONARY" ],
          "default" : {
            "type" : "NUMBER_OF_ITERATIONS_STEADY_STATE"
          }
        }, {
          "when" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,MULTIPHASE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && timeDependency.type == STATIONARY", "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]", "type == SIMERICS_ANALYSIS && timeDependency.type == TRANSIENT" ],
          "default" : {
            "type" : "TIME_STEP"
          }
        }, {
          "when" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,MULTIPHASE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && timeDependency.type == TRANSIENT" ],
          "default" : {
            "type" : "ADJUSTABLE_RUNTIME"
          }
        } ]
      },
      "OneOf_FluidSimulationControlDecomposeAlgorithm" : {
        "title" : "Decompose algorithm",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SCOTCH" : "#/components/schemas/ScotchDecomposeAlgorithm",
            "HIERARCHICAL" : "#/components/schemas/HierarchicalDecomposeAlgorithm",
            "SIMPLE" : "#/components/schemas/SimpleDecomposeAlgorithm"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ScotchDecomposeAlgorithm"
        }, {
          "$ref" : "#/components/schemas/HierarchicalDecomposeAlgorithm"
        }, {
          "$ref" : "#/components/schemas/SimpleDecomposeAlgorithm"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ]
      },
      "OneOf_PartialVectorFunctionX" : {
        "title" : "X",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PRESCRIBED" : "#/components/schemas/PrescribedOptionalFunction",
            "UNCONSTRAINED" : "#/components/schemas/UnconstrainedOptionalFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PrescribedOptionalFunction"
        }, {
          "$ref" : "#/components/schemas/UnconstrainedOptionalFunction"
        } ]
      },
      "OneOf_PartialVectorFunctionY" : {
        "title" : "Y",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PRESCRIBED" : "#/components/schemas/PrescribedOptionalFunction",
            "UNCONSTRAINED" : "#/components/schemas/UnconstrainedOptionalFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PrescribedOptionalFunction"
        }, {
          "$ref" : "#/components/schemas/UnconstrainedOptionalFunction"
        } ]
      },
      "OneOf_PartialVectorFunctionZ" : {
        "title" : "Z",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "PRESCRIBED" : "#/components/schemas/PrescribedOptionalFunction",
            "UNCONSTRAINED" : "#/components/schemas/UnconstrainedOptionalFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PrescribedOptionalFunction"
        }, {
          "$ref" : "#/components/schemas/UnconstrainedOptionalFunction"
        } ]
      },
      "OneOf_DirectionalDependencyDarcyForchheimerType" : {
        "title" : "Permeability type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ISOTROPIC" : "#/components/schemas/IsotropicDarcyForchheimer",
            "RECTIFYING" : "#/components/schemas/RectifyingDarcyForchheimer"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/IsotropicDarcyForchheimer"
        }, {
          "$ref" : "#/components/schemas/RectifyingDarcyForchheimer"
        } ]
      },
      "OneOf_HyperElasticMaterialBehaviorHyperElasticModel" : {
        "title" : "Hyper elastic model",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "MOONEY_RIVLIN" : "#/components/schemas/MooneyRivlinHyperElasticModel",
            "NEO_HOOKE" : "#/components/schemas/NeoHookeHyperElasticModel",
            "SIGNORINI" : "#/components/schemas/SignoriniHyperElasticModel"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/MooneyRivlinHyperElasticModel"
        }, {
          "$ref" : "#/components/schemas/NeoHookeHyperElasticModel"
        }, {
          "$ref" : "#/components/schemas/SignoriniHyperElasticModel"
        } ],
        "x-showWhen" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true", "type == DYNAMIC_ANALYSIS" ]
      },
      "OneOf_DimensionalFunction_PowerValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_ConstTransportThermo" : {
        "title" : "Thermo",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ECONST" : "#/components/schemas/EConstThermo",
            "HCONST" : "#/components/schemas/HConstThermo"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/EConstThermo"
        }, {
          "$ref" : "#/components/schemas/HConstThermo"
        } ]
      },
      "OneOf_ConstAnIsoTransportOrientation" : {
        "title" : "Orientation",
        "description" : "<p>Defines the direction on which the thermal conductivity will act:<br> <ul><li><strong>Cartesian</strong>: the conductivities &kappa;<sub>x</sub>, &kappa;<sub>y</sub>, and &kappa;<sub>z</sub> are aligned with the X, Y, and Z-axis, respectively.</li><li><strong>Custom</strong>: the conductivities &kappa;<sub>x</sub> and &kappa;<sub>y</sub> are aligned with the unit vectors x and y, respectively, and the conductivity &kappa;<sub>z</sub> is aligned with the resultant of the cross product of unit vectors x and y.</li></ul></p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CARTESIAN" : "#/components/schemas/CartesianOrientation",
            "CUSTOM" : "#/components/schemas/CustomOrientation"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CartesianOrientation"
        }, {
          "$ref" : "#/components/schemas/CustomOrientation"
        } ]
      },
      "OneOf_ForcesMomentsResultControlWriteControl" : {
        "title" : "Write control",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TIME_STEP" : "#/components/schemas/TimeStepWriteControl",
            "OUTPUT_TIME" : "#/components/schemas/SynchronizeWithFieldOutputWriteControl",
            "HIGH_RESOLUTION" : "#/components/schemas/HighResolution",
            "MODERATE_RESOLUTION" : "#/components/schemas/ModerateResolution",
            "COARSE_RESOLUTION" : "#/components/schemas/CoarseResolution",
            "CUSTOM_RESOLUTION" : "#/components/schemas/CustomResolution"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TimeStepWriteControl"
        }, {
          "$ref" : "#/components/schemas/SynchronizeWithFieldOutputWriteControl"
        }, {
          "$ref" : "#/components/schemas/HighResolution"
        }, {
          "$ref" : "#/components/schemas/ModerateResolution"
        }, {
          "$ref" : "#/components/schemas/CoarseResolution"
        }, {
          "$ref" : "#/components/schemas/CustomResolution"
        } ],
        "x-showWhen" : [ "type in [INCOMPRESSIBLE,INCOMPRESSIBLE_PACEFISH,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE,WIND_COMFORT]" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE]" ],
          "default" : {
            "type" : "TIME_STEP"
          }
        }, {
          "when" : [ "type in [INCOMPRESSIBLE_PACEFISH,WIND_COMFORT]" ],
          "default" : {
            "type" : "MODERATE_RESOLUTION"
          }
        } ]
      },
      "OneOf_WindComfortMeshWindComfortFineness" : {
        "title" : "Fineness",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VERY_COARSE" : "#/components/schemas/PacefishFinenessVeryCoarse",
            "COARSE" : "#/components/schemas/PacefishFinenessCoarse",
            "MODERATE" : "#/components/schemas/PacefishFinenessModerate",
            "FINE" : "#/components/schemas/PacefishFinenessFine",
            "VERY_FINE" : "#/components/schemas/PacefishFinenessVeryFine",
            "TARGET_SIZE" : "#/components/schemas/PacefishFinenessTargetSize"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PacefishFinenessVeryCoarse"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessCoarse"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessModerate"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessFine"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessVeryFine"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessTargetSize"
        } ]
      },
      "OneOf_WindComfortMeshReynoldsScalingType" : {
        "title" : "Reynolds scaling",
        "description" : "Use this factor to scale the Reynolds number of your simulation. For example, to change the Reynolds number from 10<sup>8</sup> to 10<sup>6</sup>, set this factor to 0.01. <a href= https://www.simscale.com/docs/incompressible-lbm-lattice-boltzmann-advanced/#reynolds-scaling-factor' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC_REYNOLDS_SCALING" : "#/components/schemas/AutomaticReynoldsScaling",
            "MANUAL_REYNOLDS_SCALING" : "#/components/schemas/ManualReynoldsScaling"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutomaticReynoldsScaling"
        }, {
          "$ref" : "#/components/schemas/ManualReynoldsScaling"
        } ]
      },
      "OneOf_WindComfortMeshRefinements" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "SURFACE_REFINEMENT_WIND_COMFORT" : "#/components/schemas/SurfaceRefinementWindComfort",
            "REGION_REFINEMENT_WIND_COMFORT" : "#/components/schemas/RegionRefinementWindComfort"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/SurfaceRefinementWindComfort"
        }, {
          "$ref" : "#/components/schemas/RegionRefinementWindComfort"
        } ]
      },
      "OneOf_FixedPointContactNonLinearityResolutionIterationControl" : {
        "title" : "Iteration control",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "MAXIMUM_NUMBER" : "#/components/schemas/MaximumNumberIterationControl",
            "MULTIPLIED_SLAVE_NODE" : "#/components/schemas/MultipliedSlaveNodesIterationControl"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/MaximumNumberIterationControl"
        }, {
          "$ref" : "#/components/schemas/MultipliedSlaveNodesIterationControl"
        } ]
      },
      "OneOf_ContactConnections" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "BONDED_CONTACT" : "#/components/schemas/BondedContact",
            "CYCLIC_SYMMETRY" : "#/components/schemas/CyclicSymmetryContact",
            "SLIDING_CONTACT" : "#/components/schemas/SlidingContact"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/BondedContact"
        }, {
          "$ref" : "#/components/schemas/CyclicSymmetryContact"
        }, {
          "$ref" : "#/components/schemas/SlidingContact"
        } ]
      },
      "OneOf_PacefishMeshV38PrimaryTopology" : {
        "title" : "Region of interest",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NO_PRIMARY_TOPOLOGY" : "#/components/schemas/NoPrimaryTopology",
            "BUILDINGS_OF_INTEREST" : "#/components/schemas/BuildingsOfInterest"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NoPrimaryTopology"
        }, {
          "$ref" : "#/components/schemas/BuildingsOfInterest"
        } ]
      },
      "OneOf_PacefishMeshV38Refinements" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "REGION_PACEFISH_V38" : "#/components/schemas/NewRegionRefinementPacefishV38",
            "SURFACE_PACEFISH_V38" : "#/components/schemas/NewSurfaceRefinementPacefishV38"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NewRegionRefinementPacefishV38"
        }, {
          "$ref" : "#/components/schemas/NewSurfaceRefinementPacefishV38"
        } ]
      },
      "OneOf_VelocityOutletBCVelocity" : {
        "title" : "Velocity type",
        "description" : "Please choose the type of velocity boundary condition. <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/velocity-inlet-and-velocity-outlet/' target='_blank'>Learn more</a>.",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FIXED_VALUE" : "#/components/schemas/FixedValueVBC",
            "FIXED_MEAN" : "#/components/schemas/MeanValueVBC",
            "FREESTREAM" : "#/components/schemas/FreestreamVBC",
            "OUTLET_MEAN_PHASE" : "#/components/schemas/OutletMeanPhaseVBC",
            "FLOW_RATE_OUTLET_VELOCITY" : "#/components/schemas/FlowRateOutletVBC",
            "FLOW_RATE_MEAN_OUTLET_VELOCITY" : "#/components/schemas/FlowRateMeanOutletVBC",
            "FLOW_RATE_STABLE_OUTLET_VELOCITY" : "#/components/schemas/FlowRateStableOutletVBC",
            "MEAN_VALUE_OUTLET_VELOCITY" : "#/components/schemas/MeanValueOutletVBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FixedValueVBC"
        }, {
          "$ref" : "#/components/schemas/MeanValueVBC"
        }, {
          "$ref" : "#/components/schemas/FreestreamVBC"
        }, {
          "$ref" : "#/components/schemas/OutletMeanPhaseVBC"
        }, {
          "$ref" : "#/components/schemas/FlowRateOutletVBC"
        }, {
          "$ref" : "#/components/schemas/FlowRateMeanOutletVBC"
        }, {
          "$ref" : "#/components/schemas/FlowRateStableOutletVBC"
        }, {
          "$ref" : "#/components/schemas/MeanValueOutletVBC"
        } ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type == MULTIPHASE" ],
          "default" : {
            "type" : "FIXED_VALUE"
          }
        }, {
          "when" : [ "type == SIMERICS_ANALYSIS" ],
          "default" : {
            "type" : "FLOW_RATE_STABLE_OUTLET_VELOCITY"
          }
        }, {
          "when" : [ "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER]" ],
          "default" : {
            "type" : "MEAN_VALUE_OUTLET_VELOCITY"
          }
        } ]
      },
      "OneOf_VelocityOutletBCPhaseFraction" : {
        "title" : "Phase fraction",
        "description" : "Please choose a boundary condition for phase fraction (alpha).",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "FIXED_VALUE" : "#/components/schemas/FixedValuePFBC",
            "FLOW_DEPENDENT_VALUE" : "#/components/schemas/FlowDependentValuePFBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FixedValuePFBC"
        }, {
          "$ref" : "#/components/schemas/FlowDependentValuePFBC"
        } ],
        "x-showWhen" : [ "type == MULTIPHASE" ]
      },
      "OneOf_VelocityOutletBCNetRadiativeHeatFlux" : {
        "title" : "Radiative behaviour",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GREYBODY_DIFFUSIVE" : "#/components/schemas/GreybodyDiffusiveRSBC",
            "OPEN_WINDOW" : "#/components/schemas/OpenWindowRSBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GreybodyDiffusiveRSBC"
        }, {
          "$ref" : "#/components/schemas/OpenWindowRSBC"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && enableRadiation == true", "type == CONJUGATE_HEAT_TRANSFER && enableRadiation == true" ]
      },
      "OneOf_VelocityOutletBCRadiativeIntensityRay" : {
        "title" : "Radiative behaviour",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GREYBODY_DIFFUSIVE_RAY" : "#/components/schemas/GreybodyDiffusiveRayBC",
            "OPEN_BOUNDARY_RAY" : "#/components/schemas/OpenBoundaryRayBC",
            "SEMI_OPEN_BOUNDARY_RAY" : "#/components/schemas/SemiOpenBoundaryRayBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GreybodyDiffusiveRayBC"
        }, {
          "$ref" : "#/components/schemas/OpenBoundaryRayBC"
        }, {
          "$ref" : "#/components/schemas/SemiOpenBoundaryRayBC"
        } ],
        "x-showWhen" : [ "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableSolarLoad == true" ]
      },
      "OneOf_SimericsAnalysisTimeDependency" : {
        "title" : "Time dependency",
        "description" : "<p><strong>Steady-state</strong>: Steady-state simulations are time-independent, that is, the equations solved do not include time derivatives. If you are only interested in the converged solution, consider a steady-state simulation.</p><p><strong>Transient</strong>: Transient simulations account for time-dependent effects, that is, the associated flow variables vary with respect to time.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TRANSIENT" : "#/components/schemas/TransientTimeDependency",
            "STATIONARY" : "#/components/schemas/StationaryTimeDependency"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TransientTimeDependency"
        }, {
          "$ref" : "#/components/schemas/StationaryTimeDependency"
        } ]
      },
      "OneOf_SimericsAnalysisBoundaryConditions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VELOCITY_INLET_V3" : "#/components/schemas/VelocityInletBC",
            "VELOCITY_OUTLET_V7" : "#/components/schemas/VelocityOutletBC",
            "PRESSURE_INLET_V31" : "#/components/schemas/PressureInletBC",
            "PRESSURE_OUTLET_V30" : "#/components/schemas/PressureOutletBC",
            "WALL_V34" : "#/components/schemas/WallBC",
            "SYMMETRY" : "#/components/schemas/SymmetryBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/VelocityInletBC"
        }, {
          "$ref" : "#/components/schemas/VelocityOutletBC"
        }, {
          "$ref" : "#/components/schemas/PressureInletBC"
        }, {
          "$ref" : "#/components/schemas/PressureOutletBC"
        }, {
          "$ref" : "#/components/schemas/WallBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryBC"
        } ]
      },
      "OneOf_SimericsAnalysisMeshSettings" : {
        "title" : "Mesh settings",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC_SETTINGS" : "#/components/schemas/AutomaticSimericsMeshSettings",
            "MANUAL_SETTINGS" : "#/components/schemas/ManualSimericsMeshSettings"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutomaticSimericsMeshSettings"
        }, {
          "$ref" : "#/components/schemas/ManualSimericsMeshSettings"
        } ]
      },
      "OneOf_RegionRefinementWindComfortNewFineness" : {
        "title" : "Fineness",
        "description" : "<p>This parameter determines the <b>fineness of the mesh</b> and affects the overall number of cells. It is recommended to start with the <i>coarse</i> setting. <a href='https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/mesh-settings/' target='_blank'>Find out more.</a></p><p><b>Note:</b> This setting will impact the accuracy of your results as well as computing time and result size. A finer mesh will be more demanding in terms of machine size and memory but lead to more accurate results in most cases.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "VERY_COARSE" : "#/components/schemas/PacefishFinenessVeryCoarse",
            "COARSE" : "#/components/schemas/PacefishFinenessCoarse",
            "MODERATE" : "#/components/schemas/PacefishFinenessModerate",
            "FINE" : "#/components/schemas/PacefishFinenessFine",
            "VERY_FINE" : "#/components/schemas/PacefishFinenessVeryFine",
            "TARGET_SIZE" : "#/components/schemas/PacefishFinenessTargetSize"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PacefishFinenessVeryCoarse"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessCoarse"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessModerate"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessFine"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessVeryFine"
        }, {
          "$ref" : "#/components/schemas/PacefishFinenessTargetSize"
        } ]
      },
      "OneOf_FixedPointNonLinearityResolutionGeometryReactualization" : {
        "title" : "Geometry update",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "AUTOMATIC" : "#/components/schemas/AutomaticReactualization",
            "MANUAL" : "#/components/schemas/ManualReactualization",
            "NONE" : "#/components/schemas/NoneReactualization"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AutomaticReactualization"
        }, {
          "$ref" : "#/components/schemas/ManualReactualization"
        }, {
          "$ref" : "#/components/schemas/NoneReactualization"
        } ]
      },
      "OneOf_FlowRateInletVBCFlowRate" : {
        "title" : "Flow rate type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "MASS" : "#/components/schemas/MassFlow",
            "VOLUMETRIC" : "#/components/schemas/VolumetricFlow"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/MassFlow"
        }, {
          "$ref" : "#/components/schemas/VolumetricFlow"
        } ]
      },
      "OneOf_WallBCVelocity" : {
        "title" : "(U) Velocity",
        "description" : "<p>Please choose the wall boundary condition sub-type based on the wall movement (U). <a href='https://www.simscale.com/docs/simulation-setup/boundary-conditions/wall/' target='_blank'>Learn more</a>.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "MOVING_WALL_VELOCITY" : "#/components/schemas/MovingWallVBC",
            "NO_SLIP" : "#/components/schemas/NoSlipVBC",
            "ROTATING_WALL_VELOCITY" : "#/components/schemas/RotatingWallVBC",
            "SLIP" : "#/components/schemas/SlipVBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/MovingWallVBC"
        }, {
          "$ref" : "#/components/schemas/NoSlipVBC"
        }, {
          "$ref" : "#/components/schemas/RotatingWallVBC"
        }, {
          "$ref" : "#/components/schemas/SlipVBC"
        } ]
      },
      "OneOf_WallBCTemperature" : {
        "title" : "Temperature type",
        "description" : "Please choose a boundary condition for temperature (T).",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "EXTERNAL_WALL_HEAT_FLUX_TEMPERATURE" : "#/components/schemas/ExternalWallHeatFluxTBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueTBC",
            "ADIABATIC" : "#/components/schemas/AdiabaticTBC",
            "TURBULENT_HEAT_FLUX_TEMPERATURE" : "#/components/schemas/TurbulentHeatFluxTBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ExternalWallHeatFluxTBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueTBC"
        }, {
          "$ref" : "#/components/schemas/AdiabaticTBC"
        }, {
          "$ref" : "#/components/schemas/TurbulentHeatFluxTBC"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY]" ]
      },
      "OneOf_WallBCPhaseFraction" : {
        "title" : "Phase fraction",
        "description" : "Please choose a boundary condition for phase fraction (alpha).",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT_CONTACT_ANGLE" : "#/components/schemas/ConstantContactAnglePFBC",
            "DYNAMIC_CONTACT_ANGLE" : "#/components/schemas/DynamicContactAnglePFBC",
            "ZERO_GRADIENT" : "#/components/schemas/ZeroGradientPFBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantContactAnglePFBC"
        }, {
          "$ref" : "#/components/schemas/DynamicContactAnglePFBC"
        }, {
          "$ref" : "#/components/schemas/ZeroGradientPFBC"
        } ],
        "x-showWhen" : [ "type == MULTIPHASE" ]
      },
      "OneOf_WallBCNetRadiativeHeatFlux" : {
        "title" : "Radiative behaviour",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GREYBODY_DIFFUSIVE" : "#/components/schemas/GreybodyDiffusiveRSBC",
            "OPEN_WINDOW" : "#/components/schemas/OpenWindowRSBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GreybodyDiffusiveRSBC"
        }, {
          "$ref" : "#/components/schemas/OpenWindowRSBC"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && enableRadiation == true", "type == CONJUGATE_HEAT_TRANSFER && enableRadiation == true" ]
      },
      "OneOf_WallBCRadiativeIntensityRay" : {
        "title" : "Radiative behaviour",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GREYBODY_DIFFUSIVE_RAY" : "#/components/schemas/GreybodyDiffusiveRayBC",
            "OPEN_BOUNDARY_RAY" : "#/components/schemas/OpenBoundaryRayBC",
            "SEMI_OPEN_BOUNDARY_RAY" : "#/components/schemas/SemiOpenBoundaryRayBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GreybodyDiffusiveRayBC"
        }, {
          "$ref" : "#/components/schemas/OpenBoundaryRayBC"
        }, {
          "$ref" : "#/components/schemas/SemiOpenBoundaryRayBC"
        } ],
        "x-showWhen" : [ "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableRadiation == true", "type == COUPLED_CONJUGATE_HEAT_TRANSFER && enableSolarLoad == true" ]
      },
      "OneOf_HarmonicResponseResultControlItemFieldSelection" : {
        "title" : "Field selection",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "DISPLACEMENT" : "#/components/schemas/DisplacementFieldSelection",
            "VELOCITY" : "#/components/schemas/VelocityFieldSelection",
            "ACCELERATION" : "#/components/schemas/AccelerationFieldSelection"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/DisplacementFieldSelection"
        }, {
          "$ref" : "#/components/schemas/VelocityFieldSelection"
        }, {
          "$ref" : "#/components/schemas/AccelerationFieldSelection"
        } ],
        "x-showWhen" : [ "type == HARMONIC_ANALYSIS" ]
      },
      "OneOf_StrainFieldSelectionStrainType" : {
        "title" : "() Strain type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TOTAL_LINEAR" : "#/components/schemas/TotalLinearStrainType",
            "TOTAL_NONLINEAR" : "#/components/schemas/TotalNonLinearStrainType",
            "TOTAL_EQUI_PLASTIC" : "#/components/schemas/TotalEquivalentPlasticStrainType",
            "UNELASTIC" : "#/components/schemas/UnelasticStrainType",
            "PRINCIPAL" : "#/components/schemas/PrincipalStrainType",
            "PRINCIPAL_GREEN_LAGRANGE" : "#/components/schemas/PrincipalGreenLagrangeStrainType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TotalLinearStrainType"
        }, {
          "$ref" : "#/components/schemas/TotalNonLinearStrainType"
        }, {
          "$ref" : "#/components/schemas/TotalEquivalentPlasticStrainType"
        }, {
          "$ref" : "#/components/schemas/UnelasticStrainType"
        }, {
          "$ref" : "#/components/schemas/PrincipalStrainType"
        }, {
          "$ref" : "#/components/schemas/PrincipalGreenLagrangeStrainType"
        } ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true", "type == DYNAMIC_ANALYSIS" ],
          "default" : {
            "type" : "TOTAL_NONLINEAR"
          }
        }, {
          "when" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == false", "type == THERMAL_MECHANICAL && nonLinearAnalysis == false" ],
          "default" : {
            "type" : "TOTAL_LINEAR"
          }
        } ]
      },
      "OneOf_DimensionalVectorFunction_VolumeForceValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "COMPONENT" : "#/components/schemas/ComponentVectorFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedVectorFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ComponentVectorFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedVectorFunction"
        } ]
      },
      "OneOf_HarmonicAnalysisBoundaryConditions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "BASE_EXCITATION" : "#/components/schemas/BaseExcitationBC",
            "BOLT_PRELOAD" : "#/components/schemas/BoltPreloadBC",
            "ELASTIC_SUPPORT" : "#/components/schemas/ElasticSupportBC",
            "FIXED_SUPPORT" : "#/components/schemas/FixedSupportBC",
            "FIXED_VALUE" : "#/components/schemas/FixedValueBC",
            "POINT_MASS" : "#/components/schemas/PointMassBC",
            "REMOTE_DISPLACEMENT_LOAD" : "#/components/schemas/RemoteDisplacementLoadBC",
            "SYMMETRY_PLANE" : "#/components/schemas/SymmetryPlaneBC",
            "CENTRIFUGAL_FORCE" : "#/components/schemas/CentrifugalForceBC",
            "FORCE_LOAD" : "#/components/schemas/ForceLoadBC",
            "NODAL_LOAD" : "#/components/schemas/NodalLoadBC",
            "PRESSURE" : "#/components/schemas/PressureBC",
            "REMOTE_FORCE_LOAD" : "#/components/schemas/RemoteForceLoadBC",
            "SURFACE_LOAD" : "#/components/schemas/SurfaceLoadBC",
            "VOLUME_LOAD" : "#/components/schemas/VolumeLoadBC"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/BaseExcitationBC"
        }, {
          "$ref" : "#/components/schemas/BoltPreloadBC"
        }, {
          "$ref" : "#/components/schemas/ElasticSupportBC"
        }, {
          "$ref" : "#/components/schemas/FixedSupportBC"
        }, {
          "$ref" : "#/components/schemas/FixedValueBC"
        }, {
          "$ref" : "#/components/schemas/PointMassBC"
        }, {
          "$ref" : "#/components/schemas/RemoteDisplacementLoadBC"
        }, {
          "$ref" : "#/components/schemas/SymmetryPlaneBC"
        }, {
          "$ref" : "#/components/schemas/CentrifugalForceBC"
        }, {
          "$ref" : "#/components/schemas/ForceLoadBC"
        }, {
          "$ref" : "#/components/schemas/NodalLoadBC"
        }, {
          "$ref" : "#/components/schemas/PressureBC"
        }, {
          "$ref" : "#/components/schemas/RemoteForceLoadBC"
        }, {
          "$ref" : "#/components/schemas/SurfaceLoadBC"
        }, {
          "$ref" : "#/components/schemas/VolumeLoadBC"
        } ]
      },
      "OneOf_PedestrianComfortSurfaceGround" : {
        "title" : "Ground",
        "description" : "<p>Ground reference can be either <i>absolute</i> (uses bottom of region of interest as reference) or <i>relative</i> (uses each assignment as a reference) and elevates those by the height defined. <a href= https://www.simscale.com/docs/analysis-types/pedestrian-wind-comfort-analysis/pedestrian-comfort-map/#ground' target='_blank'>Learn more</a>.</p> <img src=\"/spec/resources/help/imgs/Ground_absolute_relative.jpg\", class=\"helpPopupImage\"/>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GROUND_ABSOLUTE" : "#/components/schemas/GroundAbsolute",
            "GROUND_RELATIVE" : "#/components/schemas/GroundRelative"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GroundAbsolute"
        }, {
          "$ref" : "#/components/schemas/GroundRelative"
        } ]
      },
      "OneOf_SolidResultControlSolutionFields" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONTACT" : "#/components/schemas/ContactResultControlItem",
            "DISPLACEMENT" : "#/components/schemas/DisplacementResultControlItem",
            "FORCE" : "#/components/schemas/ForceResultControlItem",
            "STRAIN" : "#/components/schemas/StrainResultControlItem",
            "STRESS" : "#/components/schemas/StressResultControlItem",
            "VELOCITY" : "#/components/schemas/VelocityResultControlItem",
            "ACCELERATION" : "#/components/schemas/AccelerationResultControlItem",
            "TEMPERATURE" : "#/components/schemas/TemperatureResultControlItem",
            "HEAT_FLUX" : "#/components/schemas/HeatFluxResultControlItem"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ContactResultControlItem"
        }, {
          "$ref" : "#/components/schemas/DisplacementResultControlItem"
        }, {
          "$ref" : "#/components/schemas/ForceResultControlItem"
        }, {
          "$ref" : "#/components/schemas/StrainResultControlItem"
        }, {
          "$ref" : "#/components/schemas/StressResultControlItem"
        }, {
          "$ref" : "#/components/schemas/VelocityResultControlItem"
        }, {
          "$ref" : "#/components/schemas/AccelerationResultControlItem"
        }, {
          "$ref" : "#/components/schemas/TemperatureResultControlItem"
        }, {
          "$ref" : "#/components/schemas/HeatFluxResultControlItem"
        } ]
      },
      "OneOf_SolidResultControlEdgeCalculation" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "MIN_MAX_FIELDS_CALCULATION" : "#/components/schemas/MinMaxFieldsCalculationResultControlItem",
            "AVERAGE_FIELDS_CALCULATION" : "#/components/schemas/AverageFieldsCalculationResultControlItem",
            "SUM_FIELDS_CALCULATION" : "#/components/schemas/SumFieldsCalculationResultControlItem"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/MinMaxFieldsCalculationResultControlItem"
        }, {
          "$ref" : "#/components/schemas/AverageFieldsCalculationResultControlItem"
        }, {
          "$ref" : "#/components/schemas/SumFieldsCalculationResultControlItem"
        } ]
      },
      "OneOf_SolidResultControlAreaCalculation" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "MIN_MAX_FIELDS_CALCULATION" : "#/components/schemas/MinMaxFieldsCalculationResultControlItem",
            "AVERAGE_FIELDS_CALCULATION" : "#/components/schemas/AverageFieldsCalculationResultControlItem",
            "SUM_FIELDS_CALCULATION" : "#/components/schemas/SumFieldsCalculationResultControlItem"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/MinMaxFieldsCalculationResultControlItem"
        }, {
          "$ref" : "#/components/schemas/AverageFieldsCalculationResultControlItem"
        }, {
          "$ref" : "#/components/schemas/SumFieldsCalculationResultControlItem"
        } ]
      },
      "OneOf_SolidResultControlVolumeCalculation" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "MIN_MAX_FIELDS_CALCULATION" : "#/components/schemas/MinMaxFieldsCalculationResultControlItem",
            "AVERAGE_FIELDS_CALCULATION" : "#/components/schemas/AverageFieldsCalculationResultControlItem",
            "SUM_FIELDS_CALCULATION" : "#/components/schemas/SumFieldsCalculationResultControlItem"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/MinMaxFieldsCalculationResultControlItem"
        }, {
          "$ref" : "#/components/schemas/AverageFieldsCalculationResultControlItem"
        }, {
          "$ref" : "#/components/schemas/SumFieldsCalculationResultControlItem"
        } ]
      },
      "OneOf_SolidResultControlPointData" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TEMPORAL_RESPONSE" : "#/components/schemas/TemporalResponseResultControlItem",
            "HARMONIC_RESPONSE" : "#/components/schemas/HarmonicResponseResultControlItem"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TemporalResponseResultControlItem"
        }, {
          "$ref" : "#/components/schemas/HarmonicResponseResultControlItem"
        } ]
      },
      "OneOf_NonMonotomousResidualRetimingEventTimestepCalculationType" : {
        "title" : "Time step calculation",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NEWTON_ITERATION" : "#/components/schemas/NewtonIterationTimestepCalculationType",
            "MANUAL" : "#/components/schemas/ManualTimestepCalculationType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NewtonIterationTimestepCalculationType"
        }, {
          "$ref" : "#/components/schemas/ManualTimestepCalculationType"
        } ]
      },
      "OneOf_TimeDifferentiationSchemesForDefault" : {
        "title" : "Default",
        "description" : "<p>With this option, you can choose your desired time-differentiation scheme:</p><ul><li><p>For steady-state simulations, choose <b>steadyState</b>.</p><li><p>For transient simulations, you may choose a large variety of schemes.</p><li><p><b>Euler</b> is a first-order implicit and bounded scheme. If unsure, try this scheme first.</p><li><p><b>Backward</b> is a second-order time-differentiation scheme which features higher accuracy but may impair stability</p><li><p><b>CrankNicholson</b> is another very common second-order scheme with relatively low computational cost</p><li><p>The other numerical schemes are not generally recommended; use them only if you feel familiar enough with them</p></ul>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "EULER" : "#/components/schemas/EulerTimeDifferentiationScheme",
            "LOCAL_EULER" : "#/components/schemas/LocalEulerTimeDifferentiationScheme",
            "BACKWARD" : "#/components/schemas/BackwardTimeDifferentiationScheme",
            "STEADYSTATE" : "#/components/schemas/SteadystateTimeDifferentiationScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/EulerTimeDifferentiationScheme"
        }, {
          "$ref" : "#/components/schemas/LocalEulerTimeDifferentiationScheme"
        }, {
          "$ref" : "#/components/schemas/BackwardTimeDifferentiationScheme"
        }, {
          "$ref" : "#/components/schemas/SteadystateTimeDifferentiationScheme"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE]" ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && timeDependency.type == TRANSIENT" ],
          "default" : {
            "type" : "EULER"
          }
        }, {
          "when" : [ "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,CONJUGATE_HEAT_TRANSFER] && timeDependency.type == STATIONARY" ],
          "default" : {
            "type" : "STEADYSTATE"
          }
        }, {
          "when" : [ "type == MULTIPHASE && useLocalTimeStepping == false" ],
          "default" : {
            "type" : "EULER"
          }
        }, {
          "when" : [ "type == MULTIPHASE && useLocalTimeStepping == true" ],
          "default" : {
            "type" : "LOCAL_EULER"
          }
        } ]
      },
      "OneOf_LaplacianSchemesForDefault" : {
        "title" : "Default",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE]" ]
      },
      "OneOf_LaplacianSchemesLaplacian_NuEff_velocity" : {
        "title" : "laplacian(nuEff,U)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && algorithm in [PIMPLE,PISO,SIMPLE]", "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false", "type == MULTIPHASE && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS,KEPSILON,KOMEGA,KOMEGASST]" ]
      },
      "OneOf_LaplacianSchemesLaplacian_1A_U_pressure" : {
        "title" : "laplacian((1|A(U)),p)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS,KOMEGASST,NONE,KEPSILON,KOMEGA] && algorithm != PIMPLE" ]
      },
      "OneOf_LaplacianSchemesLaplacian_Nu_velocity" : {
        "title" : "laplacian(nu,U)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && algorithm == ICO && turbulenceModel == NONE", "type == INCOMPRESSIBLE && algorithm in [PISO,SIMPLE] && turbulenceModel in [KOMEGA,KOMEGASST]" ]
      },
      "OneOf_LaplacianSchemesLaplacian_DREff_R" : {
        "title" : "laplacian(DREff,R)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS,NONE,KEPSILON] && algorithm in [PISO,SIMPLE]" ]
      },
      "OneOf_LaplacianSchemesLaplacian_DnuTildaEff_nuTilda" : {
        "title" : "laplacian(DnuTildaEff,nuTilda)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type in [COMPRESSIBLE,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE] && turbulenceModel == SPALARTALLMARAS", "type == INCOMPRESSIBLE && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS] && algorithm == PISO", "type == INCOMPRESSIBLE && turbulenceModel == SPALARTALLMARAS && algorithm == PIMPLE", "type == INCOMPRESSIBLE && turbulenceModel in [NONE,KEPSILON] && algorithm in [PISO,SIMPLE]" ]
      },
      "OneOf_LaplacianSchemesLaplacian_DkEff_turbulentKineticEnergy" : {
        "title" : "laplacian(DkEff,k)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && turbulenceModel == KEPSILON", "type == INCOMPRESSIBLE && turbulenceModel in [KOMEGA,KOMEGASST] && algorithm == PIMPLE", "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER] && turbulenceModel in [KEPSILON,KOMEGASST]", "type == MULTIPHASE && turbulenceModel in [KEPSILON,KOMEGA,KOMEGASST]", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [KEPSILON,KOMEGASST] && timeDependency.type == STATIONARY", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [KEPSILON,KOMEGASST] && timeDependency.type == TRANSIENT && isCompressible == false" ]
      },
      "OneOf_LaplacianSchemesLaplacian_alphaEff_enthalpy" : {
        "title" : "laplacian(alphaEff, h)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_LaplacianSchemesLaplacian_alpha_enthalpy" : {
        "title" : "laplacian(alpha, h)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_LaplacianSchemesLaplacian_muEff_velocity" : {
        "title" : "laplacian(muEff, U)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_LaplacianSchemesLaplacian_alphaEff_internalEnergy" : {
        "title" : "laplacian(alphaEff, e)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [NONE,KEPSILON,KOMEGASST] && timeDependency.type == STATIONARY && isCompressible == true", "type == COMPRESSIBLE && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == STATIONARY", "type == COMPRESSIBLE && turbulenceModel == NONE && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_LaplacianSchemesLaplacian_rhorAUf_pressureRgh" : {
        "title" : "laplacian(rhorAUf, p_rgh)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == CONJUGATE_HEAT_TRANSFER" ]
      },
      "OneOf_LaplacianSchemesLaplacian_DepsilonEff_epsilonDissipationRate" : {
        "title" : "laplacian(DepsilonEff, eps)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type in [INCOMPRESSIBLE,COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,MULTIPHASE] && turbulenceModel == KEPSILON", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel == KEPSILON && timeDependency.type != TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel == KEPSILON && isCompressible == false" ]
      },
      "OneOf_LaplacianSchemesLaplacian_DomegaEff_omegaDissipationRate" : {
        "title" : "laplacian(DomegaEff,omega)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && turbulenceModel in [KOMEGA,KOMEGASST] && algorithm == PIMPLE", "type in [COMPRESSIBLE,CONJUGATE_HEAT_TRANSFER] && turbulenceModel == KOMEGASST", "type == MULTIPHASE && turbulenceModel in [KOMEGA,KOMEGASST]", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel == KOMEGASST && timeDependency.type != TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel == KOMEGASST && isCompressible == false" ]
      },
      "OneOf_LaplacianSchemesLaplacian_rAUf_pressure" : {
        "title" : "laplacian(rAUf, p)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && algorithm == PIMPLE" ]
      },
      "OneOf_LaplacianSchemesLaplacian_DT_passiveScalar" : {
        "title" : "laplacian(DT, T)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == INCOMPRESSIBLE && numOfPassiveSpecies > 0", "type == CONVECTIVE_HEAT_TRANSFER && numOfPassiveSpecies > 0" ]
      },
      "OneOf_LaplacianSchemesLaplacian_Dp_pressure" : {
        "title" : "laplacian(Dp,p)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT" ]
      },
      "OneOf_LaplacianSchemesLaplacian_rhorAUf_pressure" : {
        "title" : "laplacian(rhorAUf, p)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && timeDependency.type == TRANSIENT && turbulenceModel != NONE", "type == COMPRESSIBLE && timeDependency.type == TRANSIENT", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [SMAGORINSKY,SPALARTALLMARAS] && isCompressible == true" ]
      },
      "OneOf_LaplacianSchemesLaplacian_rho_1_A_U_pressure" : {
        "title" : "laplacian(rho*(1|A(U)),p)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && timeDependency.type == STATIONARY && turbulenceModel in [NONE,KEPSILON,KOMEGASST]" ]
      },
      "OneOf_LaplacianSchemesLaplacian_mut_velocity" : {
        "title" : "laplacian(mut, U)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == COMPRESSIBLE && turbulenceModel in [KEPSILON,KOMEGASST]", "type == CONVECTIVE_HEAT_TRANSFER && turbulenceModel in [KEPSILON,KOMEGASST] && timeDependency.type == STATIONARY && isCompressible == true" ]
      },
      "OneOf_LaplacianSchemesLaplacian_alphaEff_temperature" : {
        "title" : "laplacian(alphaEff, T)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false" ]
      },
      "OneOf_LaplacianSchemesLaplacian_rAUf_pressureRgh" : {
        "title" : "laplacian(rAUf, p_rgh)",
        "description" : "<p>With this option you can choose your desired laplacian scheme.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "GAUSS_LINEAR_CORRECTED" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme",
            "GAUSS_LINEAR_LIMITED_CORRECTED" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme",
            "GAUSS_LINEAR_UNCORRECTED" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/GaussLinearCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearLimitedCorrectedLaplacianScheme"
        }, {
          "$ref" : "#/components/schemas/GaussLinearUncorrectedLaplacianScheme"
        } ],
        "x-showWhen" : [ "type == CONVECTIVE_HEAT_TRANSFER && isCompressible == false" ]
      },
      "OneOf_PBICGSolverPreconditioner" : {
        "title" : "Preconditioner",
        "description" : "<p>Choose a preconditioner for your solver. A preconditioner improves the convergence speed of your system. Therefore, it is generally recommended. DILU is a very common diagonal incomplete lower-upper decomposition preconditioner.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "DILU" : "#/components/schemas/DILUPreconditioner",
            "ILUCP" : "#/components/schemas/ILUCpPreconditioner"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/DILUPreconditioner"
        }, {
          "$ref" : "#/components/schemas/ILUCpPreconditioner"
        } ],
        "x-conditionalDefaults" : [ {
          "when" : [ "type in [COMPRESSIBLE,INCOMPRESSIBLE,CONJUGATE_HEAT_TRANSFER,CONVECTIVE_HEAT_TRANSFER,MULTIPHASE]", "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY] && 1# in [velocitySolver,radiativeIntensityRaySolver,turbulentKineticEnergySolver,omegaDissipationRateSolver,passiveScalarSolver]" ],
          "default" : {
            "type" : "DILU"
          }
        }, {
          "when" : [ "type in [COUPLED_CONJUGATE_HEAT_TRANSFER,EMBEDDED_BOUNDARY] && 1# == temperatureSolver" ],
          "default" : {
            "type" : "ILUCP"
          }
        } ]
      },
      "OneOf_SimericsFluidMaterialsFluids" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "INCOMPRESSIBLE" : "#/components/schemas/IncompressibleMaterial",
            "COMPRESSIBLE" : "#/components/schemas/FluidCompressibleMaterial"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/IncompressibleMaterial"
        }, {
          "$ref" : "#/components/schemas/FluidCompressibleMaterial"
        } ]
      },
      "OneOf_ComponentVectorFunctionX" : {
        "title" : "X",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_ComponentVectorFunctionY" : {
        "title" : "Y",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_ComponentVectorFunctionZ" : {
        "title" : "Z",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_StressFieldSelectionStressType" : {
        "title" : "Stress type",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TRESCA" : "#/components/schemas/TrescaStressType",
            "CAUCHY" : "#/components/schemas/CauchyStressType",
            "PRINCIPAL" : "#/components/schemas/PrincipalStressType",
            "VON_MISES" : "#/components/schemas/VonMisesStressType",
            "SIGNED_VON_MISES" : "#/components/schemas/SignedVonMisesStressType"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TrescaStressType"
        }, {
          "$ref" : "#/components/schemas/CauchyStressType"
        }, {
          "$ref" : "#/components/schemas/PrincipalStressType"
        }, {
          "$ref" : "#/components/schemas/VonMisesStressType"
        }, {
          "$ref" : "#/components/schemas/SignedVonMisesStressType"
        } ]
      },
      "OneOf_ForceMomentCoefficientsResultControlWriteControl" : {
        "title" : "Write control",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TIME_STEP" : "#/components/schemas/TimeStepWriteControl",
            "OUTPUT_TIME" : "#/components/schemas/SynchronizeWithFieldOutputWriteControl"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TimeStepWriteControl"
        }, {
          "$ref" : "#/components/schemas/SynchronizeWithFieldOutputWriteControl"
        } ]
      },
      "OneOf_IsotropicSpringStiffnessStiffnessDefinition" : {
        "title" : "Stiffness definition",
        "description" : "<p>The resulting stiffness of the elastic support can be defined either via the <b>total stiffness</b> expressed as force per length or the <b>distributed stiffness</b> expressed as force per length per area.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TOTAL_ISOTROPIC" : "#/components/schemas/TotalIsotropicStiffnessDefinition",
            "DISTRIBUTED_ISOTROPIC" : "#/components/schemas/DistributedIsotropicStiffnessDefinition"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TotalIsotropicStiffnessDefinition"
        }, {
          "$ref" : "#/components/schemas/DistributedIsotropicStiffnessDefinition"
        } ]
      },
      "OneOf_ElasticSupportBCSpringStiffness" : {
        "title" : "Spring stiffness",
        "description" : "<p>The stiffness can either be assumed equal in all directions by selecting <b>isotropic</b> or it can depend on the force direction by selecting <b>orthotropic</b>. For an orthotropic stiffness the stiffness value along each global coordinate direction can be given independently.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ISOTROPIC" : "#/components/schemas/IsotropicSpringStiffness",
            "ORTHOTROPIC" : "#/components/schemas/OrthotropicSpringStiffness"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/IsotropicSpringStiffness"
        }, {
          "$ref" : "#/components/schemas/OrthotropicSpringStiffness"
        } ],
        "x-showWhen" : [ "type in [STATIC_ANALYSIS,DYNAMIC_ANALYSIS,THERMAL_MECHANICAL,HARMONIC_ANALYSIS,FREQUENCY_ANALYSIS]" ]
      },
      "OneOf_PorousTreeTreeType" : {
        "title" : "Type of tree",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CUSTOM_TREE" : "#/components/schemas/CustomTree",
            "PLANE_TREE" : "#/components/schemas/PlaneTree",
            "OAK" : "#/components/schemas/Oak",
            "SYCAMORE" : "#/components/schemas/Sycamore",
            "SILVER_BIRCH" : "#/components/schemas/SilverBirch",
            "CHESTNUT" : "#/components/schemas/Chestnut"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CustomTree"
        }, {
          "$ref" : "#/components/schemas/PlaneTree"
        }, {
          "$ref" : "#/components/schemas/Oak"
        }, {
          "$ref" : "#/components/schemas/Sycamore"
        }, {
          "$ref" : "#/components/schemas/SilverBirch"
        }, {
          "$ref" : "#/components/schemas/Chestnut"
        } ]
      },
      "OneOf_DimensionalFunction_HeatFluxValue" : {
        "title" : "Value",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONSTANT" : "#/components/schemas/ConstantFunction",
            "EXPRESSION" : "#/components/schemas/ExpressionFunction",
            "POLYNOMIAL" : "#/components/schemas/PolynomialFunction",
            "TABLE_DEFINED" : "#/components/schemas/TableDefinedFunction"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstantFunction"
        }, {
          "$ref" : "#/components/schemas/ExpressionFunction"
        }, {
          "$ref" : "#/components/schemas/PolynomialFunction"
        }, {
          "$ref" : "#/components/schemas/TableDefinedFunction"
        } ]
      },
      "OneOf_LinearElasticMaterialBehaviorDamping" : {
        "title" : "Damping",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NONE" : "#/components/schemas/NoneDamping",
            "RAYLEIGH" : "#/components/schemas/RayleighDamping",
            "HYSTERETIC" : "#/components/schemas/HystereticDamping"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NoneDamping"
        }, {
          "$ref" : "#/components/schemas/RayleighDamping"
        }, {
          "$ref" : "#/components/schemas/HystereticDamping"
        } ],
        "x-showWhen" : [ "type in [HARMONIC_ANALYSIS,DYNAMIC_ANALYSIS]", "type == THERMAL_MECHANICAL && inertiaEffect == DYNAMIC" ]
      },
      "OneOf_LinearElasticMaterialBehaviorCreepFormulation" : {
        "title" : "Creep formulation",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NORTON" : "#/components/schemas/NortonCreepFormulation",
            "NO_CREEP" : "#/components/schemas/NoCreepFormulation",
            "STRAIN_HARDENING" : "#/components/schemas/StrainHardeningCreepFormulation",
            "TIME_HARDENING" : "#/components/schemas/TimeHardeningCreepFormulation",
            "GAROFALO" : "#/components/schemas/GarofaloCreepFormulation"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NortonCreepFormulation"
        }, {
          "$ref" : "#/components/schemas/NoCreepFormulation"
        }, {
          "$ref" : "#/components/schemas/StrainHardeningCreepFormulation"
        }, {
          "$ref" : "#/components/schemas/TimeHardeningCreepFormulation"
        }, {
          "$ref" : "#/components/schemas/GarofaloCreepFormulation"
        } ],
        "x-showWhen" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true", "type == DYNAMIC_ANALYSIS" ]
      },
      "OneOf_PlasticMaterialBehaviorCreepFormulation" : {
        "title" : "Creep formulation",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "NORTON" : "#/components/schemas/NortonCreepFormulation",
            "NO_CREEP" : "#/components/schemas/NoCreepFormulation",
            "STRAIN_HARDENING" : "#/components/schemas/StrainHardeningCreepFormulation",
            "TIME_HARDENING" : "#/components/schemas/TimeHardeningCreepFormulation",
            "GAROFALO" : "#/components/schemas/GarofaloCreepFormulation"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/NortonCreepFormulation"
        }, {
          "$ref" : "#/components/schemas/NoCreepFormulation"
        }, {
          "$ref" : "#/components/schemas/StrainHardeningCreepFormulation"
        }, {
          "$ref" : "#/components/schemas/TimeHardeningCreepFormulation"
        }, {
          "$ref" : "#/components/schemas/GarofaloCreepFormulation"
        } ],
        "x-showWhen" : [ "type == STATIC_ANALYSIS && nonLinearAnalysis == true", "type == THERMAL_MECHANICAL && nonLinearAnalysis == true", "type == DYNAMIC_ANALYSIS" ]
      },
      "OneOf_FluidCompressibleMaterialTransport" : {
        "title" : "Transport",
        "description" : "<p>The Transport model defines the calculation of dynamic viscosity.The available models are:</p><p><b>Const:</b> This will assume constant  dynamic viscosity.</p><p><b>Sutherland:</b> The dynamic viscosity is a function of temperature based on sutherland's relation.</p><p><a href='https://www.simscale.com/docs/simulation-setup/materials/thermophysical-fluid-models/#transport-model' target='_blank'>Learn more</a>.</p>",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "CONST" : "#/components/schemas/ConstTransport",
            "SUTHERLAND" : "#/components/schemas/SutherlandTransport"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ConstTransport"
        }, {
          "$ref" : "#/components/schemas/SutherlandTransport"
        } ]
      },
      "OneOf_AutoTimestepDefinitionRetimingEvent" : {
        "title" : "Retiming event",
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "ERROR" : "#/components/schemas/ErrorRetimingEvent",
            "COLLISION" : "#/components/schemas/CollisionRetimingEvent",
            "FIELD_CHANGE" : "#/components/schemas/FieldChangeRetimingEvent",
            "NON_MONOTOMOUS_RESIDUAL" : "#/components/schemas/NonMonotomousResidualRetimingEvent"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/ErrorRetimingEvent"
        }, {
          "$ref" : "#/components/schemas/CollisionRetimingEvent"
        }, {
          "$ref" : "#/components/schemas/FieldChangeRetimingEvent"
        }, {
          "$ref" : "#/components/schemas/NonMonotomousResidualRetimingEvent"
        } ]
      },
      "DataType" : {
        "type" : "string",
        "enum" : [ "POINT", "CELL" ]
      },
      "RenderMode" : {
        "type" : "string",
        "enum" : [ "SURFACES_WITH_WIREFRAME", "WIREFRAME", "SURFACES", "SURFACES_WITH_MESH", "MESH" ]
      },
      "Color" : {
        "required" : [ "b", "g", "r" ],
        "type" : "object",
        "properties" : {
          "r" : {
            "maximum" : 1.0,
            "exclusiveMaximum" : false,
            "minimum" : 0.0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "format" : "double"
          },
          "g" : {
            "maximum" : 1.0,
            "exclusiveMaximum" : false,
            "minimum" : 0.0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "format" : "double"
          },
          "b" : {
            "maximum" : 1.0,
            "exclusiveMaximum" : false,
            "minimum" : 0.0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "format" : "double"
          }
        }
      },
      "CuttingPlane" : {
        "required" : [ "center", "clipping", "name", "normal", "projectVectorsOntoPlane" ],
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "center" : {
            "$ref" : "#/components/schemas/Vector3D"
          },
          "normal" : {
            "$ref" : "#/components/schemas/Vector3D"
          },
          "opacity" : {
            "$ref" : "#/components/schemas/Opacity"
          },
          "clipping" : {
            "type" : "boolean",
            "default" : true
          },
          "vectorGridSpacing" : {
            "maximum" : 0.04,
            "exclusiveMaximum" : false,
            "minimum" : 0.002,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "This field is required if projectVectorsOntoPlane is set to true.",
            "format" : "double",
            "default" : 0.02
          },
          "scalarField" : {
            "$ref" : "#/components/schemas/ScalarField"
          },
          "vectorField" : {
            "$ref" : "#/components/schemas/VectorField"
          },
          "projectVectorsOntoPlane" : {
            "type" : "boolean",
            "description" : "If a vectorField is provided, this flag will project the vector field onto the cutting plane.",
            "default" : false
          },
          "renderMode" : {
            "$ref" : "#/components/schemas/RenderMode"
          }
        }
      },
      "IsoSurface" : {
        "properties" : {
          "isoScalar" : {
            "$ref" : "#/components/schemas/ScalarField"
          },
          "isoValue" : {
            "type" : "number",
            "description" : "The iso scalar value. Should be within the selected scalar range. Default value is the average between the min and max in the range.",
            "format" : "float"
          },
          "scalarField" : {
            "$ref" : "#/components/schemas/ScalarField"
          },
          "solidColor" : {
            "$ref" : "#/components/schemas/Color"
          },
          "vectorField" : {
            "$ref" : "#/components/schemas/VectorField"
          },
          "opacity" : {
            "$ref" : "#/components/schemas/Opacity"
          }
        }
      },
      "IsoVolume" : {
        "properties" : {
          "isoScalar" : {
            "$ref" : "#/components/schemas/ScalarField"
          },
          "minimumIsoValue" : {
            "type" : "number",
            "description" : "The iso scalar minimum value. Should be within the selected scalar range and smaller than the maximumIsoValue. Default value is the third of the range between min and max.",
            "format" : "float"
          },
          "maximumIsoValue" : {
            "type" : "number",
            "description" : "The iso scalar maximum value. Should be within the selected scalar range and larger than the minimumIsoValue. Default value is 2 thirds of the range between min and max.",
            "format" : "float"
          },
          "scalarField" : {
            "$ref" : "#/components/schemas/ScalarField"
          },
          "solidColor" : {
            "$ref" : "#/components/schemas/Color"
          },
          "vectorField" : {
            "$ref" : "#/components/schemas/VectorField"
          },
          "opacity" : {
            "$ref" : "#/components/schemas/Opacity"
          }
        }
      },
      "Displacement" : {
        "required" : [ "field", "scaleFactor" ],
        "type" : "object",
        "properties" : {
          "field" : {
            "$ref" : "#/components/schemas/VectorField"
          },
          "scaleFactor" : {
            "minimum" : 0.01,
            "exclusiveMinimum" : false,
            "type" : "number",
            "format" : "double",
            "default" : 1.0
          }
        }
      },
      "ParticleTrace" : {
        "required" : [ "seedSettings", "traceBothDirections", "visualizationStyle" ],
        "type" : "object",
        "properties" : {
          "seedSettings" : {
            "$ref" : "#/components/schemas/SeedSettings"
          },
          "visualizationStyle" : {
            "$ref" : "#/components/schemas/OneOfVisualizationStyle"
          },
          "traceBothDirections" : {
            "type" : "boolean",
            "description" : "If set to true, the trace will be computed both forwards and backwards from the seed points.",
            "default" : true
          },
          "scalarField" : {
            "$ref" : "#/components/schemas/ScalarField"
          },
          "solidColor" : {
            "$ref" : "#/components/schemas/Color"
          }
        }
      },
      "SeedSettings" : {
        "required" : [ "center", "horizontalDimension", "normal", "verticalDimension" ],
        "properties" : {
          "center" : {
            "$ref" : "#/components/schemas/Vector3D"
          },
          "normal" : {
            "$ref" : "#/components/schemas/Vector3D"
          },
          "horizontalDimension" : {
            "maximum" : 100,
            "minimum" : 1,
            "type" : "integer",
            "description" : "Number of seed points in the horizontal direction.",
            "default" : 10
          },
          "verticalDimension" : {
            "maximum" : 100,
            "minimum" : 1,
            "type" : "integer",
            "description" : "Number of seed points in the vertical direction.",
            "default" : 10
          },
          "spacing" : {
            "type" : "number",
            "description" : "The distance between the seed points. Default is size * 4.",
            "format" : "float"
          },
          "size" : {
            "type" : "number",
            "description" : "The radius of the particle trace geometry (cylinder, sphere, comet). Default is the extent of the bounding box of the moddel divided by 800.",
            "format" : "float"
          }
        }
      },
      "OneOfVisualizationStyle" : {
        "discriminator" : {
          "propertyName" : "representation",
          "mapping" : {
            "CYLINDERS" : "#/components/schemas/CylindersVisualizationStyle",
            "SPHERES" : "#/components/schemas/SpheresVisualizationStyle",
            "COMETS" : "#/components/schemas/CometsVisualizationStyle"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/CylindersVisualizationStyle"
        }, {
          "$ref" : "#/components/schemas/SpheresVisualizationStyle"
        }, {
          "$ref" : "#/components/schemas/CometsVisualizationStyle"
        } ]
      },
      "CylindersVisualizationStyle" : {
        "required" : [ "representation" ],
        "type" : "object",
        "properties" : {
          "representation" : {
            "type" : "string",
            "description" : "The representation to use for particle traces.",
            "default" : "CYLINDERS"
          }
        },
        "x-implements" : "OneOfVisualizationStyle"
      },
      "SpheresVisualizationStyle" : {
        "required" : [ "numPulses", "representation" ],
        "type" : "object",
        "properties" : {
          "representation" : {
            "type" : "string",
            "description" : "The representation to use for particle traces.",
            "default" : "SPHERES"
          },
          "numPulses" : {
            "maximum" : 200,
            "minimum" : 5,
            "type" : "integer",
            "description" : "This value specifies how many pulses there should be in the model.",
            "default" : 15
          }
        },
        "x-implements" : "OneOfVisualizationStyle"
      },
      "CometsVisualizationStyle" : {
        "required" : [ "numPulses", "relativeCometLength", "representation" ],
        "type" : "object",
        "properties" : {
          "representation" : {
            "type" : "string",
            "description" : "The representation to use for particle traces.",
            "default" : "COMETS"
          },
          "numPulses" : {
            "maximum" : 200,
            "minimum" : 5,
            "type" : "integer",
            "description" : "This value specifies how many pulses there should be in the model.",
            "default" : 15
          },
          "relativeCometLength" : {
            "maximum" : 0.1,
            "exclusiveMaximum" : false,
            "minimum" : 1.0E-5,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "The length of the tail of the comets. It is specified in time and is a fraction of the global total time range for all particles in this particle trace. For example, if the total trace time is 2, and the relativeCometLength is 0.01, then the length of the tail will be 0.02.",
            "format" : "double",
            "default" : 1.0E-5
          }
        },
        "x-implements" : "OneOfVisualizationStyle"
      },
      "Filters" : {
        "type" : "object",
        "properties" : {
          "cuttingPlanes" : {
            "minItems" : 1,
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CuttingPlane"
            }
          },
          "isoSurfaces" : {
            "minItems" : 1,
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IsoSurface"
            }
          },
          "isoVolumes" : {
            "minItems" : 1,
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IsoVolume"
            }
          },
          "displacement" : {
            "$ref" : "#/components/schemas/Displacement"
          },
          "particleTraces" : {
            "minItems" : 1,
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ParticleTrace"
            }
          }
        }
      },
      "ModelSettings" : {
        "required" : [ "hideSelectedParts" ],
        "type" : "object",
        "properties" : {
          "parts" : {
            "type" : "array",
            "description" : "The parts to show or hide in the report (see hideSelectedParts).",
            "items" : {
              "$ref" : "#/components/schemas/Part"
            }
          },
          "hideSelectedParts" : {
            "type" : "boolean",
            "description" : "If set to true, the parts array indicates the hidden parts, while the rest of the model parts are visible (blacklist). On the other hand, if set to false, then the parts array indicate the visible parts while the rest of the model parts are hidden (whitelist). If the parts array is empty, then setting this value to true will hide all the model parts, while setting it to false will show all the model parts.",
            "default" : false
          },
          "showVolumes" : {
            "type" : "boolean",
            "description" : "If set to false, then volumes will be hidden unless they are mentioned explicitly, i.e. when a volume is included in the parts array, and hideSelectedParts is set to false.",
            "default" : false
          },
          "scalarField" : {
            "$ref" : "#/components/schemas/ScalarField"
          },
          "scalarSettings" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ScalarSettings"
            }
          },
          "vectorSettings" : {
            "type" : "array",
            "description" : "The settings for the different vectors of the model.",
            "items" : {
              "$ref" : "#/components/schemas/VectorSettings"
            }
          },
          "opacity" : {
            "$ref" : "#/components/schemas/Opacity"
          },
          "renderMode" : {
            "$ref" : "#/components/schemas/RenderMode"
          },
          "solidColor" : {
            "$ref" : "#/components/schemas/Color"
          }
        }
      },
      "OneOfCameraSettings" : {
        "discriminator" : {
          "propertyName" : "settingType",
          "mapping" : {
            "USER_INPUT" : "#/components/schemas/UserInputCameraSettings",
            "TOP_VIEW" : "#/components/schemas/TopViewPredefinedCameraSettings",
            "FORTY_FIVE_FORTY_FIVE_VIEW" : "#/components/schemas/FortyFiveViewPredefinedCameraSettings"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/UserInputCameraSettings"
        }, {
          "$ref" : "#/components/schemas/TopViewPredefinedCameraSettings"
        }, {
          "$ref" : "#/components/schemas/FortyFiveViewPredefinedCameraSettings"
        } ]
      },
      "OneOfAnimationOutputSettings" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "TIME_STEP" : "#/components/schemas/TimeStepAnimationOutputSettings",
            "PARTICLE_TRACE" : "#/components/schemas/ParticleTraceAnimationOutputSettings",
            "SHAPE" : "#/components/schemas/ShapeAnimationOutputSettings"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/TimeStepAnimationOutputSettings"
        }, {
          "$ref" : "#/components/schemas/ParticleTraceAnimationOutputSettings"
        }, {
          "$ref" : "#/components/schemas/ShapeAnimationOutputSettings"
        } ]
      },
      "AnimationOutputSettings" : {
        "required" : [ "format", "frameRate", "name", "resolution", "showCube", "showLegend" ],
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "format" : {
            "type" : "string",
            "default" : "GIF",
            "enum" : [ "GIF", "MP4" ]
          },
          "resolution" : {
            "$ref" : "#/components/schemas/ResolutionInfo"
          },
          "frameRate" : {
            "maximum" : 60,
            "minimum" : 1,
            "type" : "integer",
            "default" : 20
          },
          "showLegend" : {
            "type" : "boolean",
            "default" : true
          },
          "showCube" : {
            "type" : "boolean",
            "default" : true
          },
          "backgroundColor" : {
            "$ref" : "#/components/schemas/Color"
          }
        }
      },
      "TimeStepAnimationOutputSettings" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AnimationOutputSettings"
        }, {
          "required" : [ "fromFrameIndex", "skipFrames", "toFrameIndex", "type" ],
          "type" : "object",
          "properties" : {
            "type" : {
              "type" : "string",
              "default" : "TIME_STEP"
            },
            "fromFrameIndex" : {
              "minimum" : 0,
              "type" : "integer",
              "default" : 0
            },
            "toFrameIndex" : {
              "minimum" : 0,
              "type" : "integer"
            },
            "skipFrames" : {
              "minimum" : 0,
              "type" : "integer",
              "default" : 0
            }
          }
        } ],
        "x-implements" : "OneOfAnimationOutputSettings"
      },
      "ParticleTraceAnimationOutputSettings" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AnimationOutputSettings"
        }, {
          "required" : [ "steps", "type" ],
          "type" : "object",
          "properties" : {
            "type" : {
              "type" : "string",
              "default" : "PARTICLE_TRACE"
            },
            "frameIndex" : {
              "minimum" : 0,
              "type" : "integer",
              "description" : "Default is the last frame (time step) in the result."
            },
            "steps" : {
              "maximum" : 1000,
              "minimum" : 1,
              "type" : "integer",
              "description" : "The number of steps to generate for the particle trace animation.",
              "default" : 300
            }
          }
        } ],
        "x-implements" : "OneOfAnimationOutputSettings"
      },
      "ShapeAnimationOutputSettings" : {
        "allOf" : [ {
          "$ref" : "#/components/schemas/AnimationOutputSettings"
        }, {
          "required" : [ "range", "steps" ],
          "type" : "object",
          "properties" : {
            "type" : {
              "type" : "string",
              "default" : "SHAPE"
            },
            "frameIndex" : {
              "minimum" : 0,
              "type" : "integer",
              "description" : "Frame (or frequency) for which to create a mode shape animation.Default is the last frame in the result."
            },
            "steps" : {
              "maximum" : 100,
              "minimum" : 1,
              "type" : "integer",
              "description" : "The number of steps to generate for the shape animation",
              "default" : 30
            },
            "range" : {
              "type" : "string",
              "description" : "How to deform the model for the animation. FULL implies animating from the original, undeformed shape to the maximum displaced position, then back to original shape; do the same for the negative maximum deformation, then back (x_0 -> +x_max -> x_0 -> -x_max -> x_0). HALF implies animating from the original, undeformed shape to the maximum displaced position, then back to original shape (x_0 -> +x_max -> x_0). QUARTER implies animating from the original, undeformed shape to the maxiumum displaced position (x_0 -> +x_max)",
              "default" : "FULL",
              "enum" : [ "FULL", "HALF", "QUARTER" ]
            },
            "backgroundColor" : {
              "$ref" : "#/components/schemas/Color"
            }
          }
        } ],
        "x-implements" : "OneOfAnimationOutputSettings"
      },
      "ScreenshotOutputSettings" : {
        "required" : [ "format", "name", "resolution", "showCube", "showLegend" ],
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "format" : {
            "type" : "string",
            "default" : "PNG",
            "enum" : [ "PNG" ]
          },
          "resolution" : {
            "$ref" : "#/components/schemas/ResolutionInfo"
          },
          "frameIndex" : {
            "minimum" : 0,
            "type" : "integer",
            "description" : "Default to the last timestep or frame in the result."
          },
          "showLegend" : {
            "type" : "boolean",
            "default" : true
          },
          "showCube" : {
            "type" : "boolean",
            "default" : true
          },
          "backgroundColor" : {
            "$ref" : "#/components/schemas/Color"
          }
        }
      },
      "Part" : {
        "required" : [ "partIdentifier" ],
        "type" : "object",
        "properties" : {
          "partIdentifier" : {
            "type" : "string",
            "description" : "The identifier of the part in the result."
          },
          "opacity" : {
            "$ref" : "#/components/schemas/Opacity"
          },
          "renderMode" : {
            "$ref" : "#/components/schemas/RenderMode"
          },
          "solidColor" : {
            "$ref" : "#/components/schemas/Color"
          }
        }
      },
      "OneOfReportProperties" : {
        "discriminator" : {
          "propertyName" : "reportType",
          "mapping" : {
            "ANIMATION" : "#/components/schemas/AnimationReportProperties",
            "SCREENSHOT" : "#/components/schemas/ScreenshotReportProperties"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/AnimationReportProperties"
        }, {
          "$ref" : "#/components/schemas/ScreenshotReportProperties"
        } ]
      },
      "AnimationReportProperties" : {
        "required" : [ "cameraSettings", "modelSettings", "outputSettings", "reportType" ],
        "type" : "object",
        "properties" : {
          "reportType" : {
            "type" : "string",
            "default" : "ANIMATION"
          },
          "modelSettings" : {
            "$ref" : "#/components/schemas/ModelSettings"
          },
          "filters" : {
            "$ref" : "#/components/schemas/Filters"
          },
          "cameraSettings" : {
            "$ref" : "#/components/schemas/OneOfCameraSettings"
          },
          "outputSettings" : {
            "$ref" : "#/components/schemas/OneOfAnimationOutputSettings"
          }
        },
        "x-implements" : "OneOfReportProperties"
      },
      "ScreenshotReportProperties" : {
        "required" : [ "cameraSettings", "modelSettings", "outputSettings", "reportType" ],
        "type" : "object",
        "properties" : {
          "reportType" : {
            "type" : "string",
            "default" : "SCREENSHOT"
          },
          "modelSettings" : {
            "$ref" : "#/components/schemas/ModelSettings"
          },
          "filters" : {
            "$ref" : "#/components/schemas/Filters"
          },
          "cameraSettings" : {
            "$ref" : "#/components/schemas/OneOfCameraSettings"
          },
          "outputSettings" : {
            "$ref" : "#/components/schemas/ScreenshotOutputSettings"
          }
        },
        "x-implements" : "OneOfReportProperties"
      },
      "ReportRequest" : {
        "required" : [ "name", "reportProperties", "resultIds" ],
        "type" : "object",
        "properties" : {
          "name" : {
            "maxLength" : 200,
            "minLength" : 1,
            "type" : "string",
            "description" : "The name of the report."
          },
          "description" : {
            "maxLength" : 1000,
            "minLength" : 1,
            "type" : "string",
            "description" : "The description of the report."
          },
          "resultIds" : {
            "maxItems" : 1,
            "minItems" : 1,
            "type" : "array",
            "description" : "The resultIds the report should be created for.",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            }
          },
          "reportProperties" : {
            "$ref" : "#/components/schemas/OneOfReportProperties"
          }
        }
      },
      "ResolutionInfo" : {
        "required" : [ "x", "y" ],
        "type" : "object",
        "properties" : {
          "x" : {
            "maximum" : 8000,
            "minimum" : 1,
            "type" : "integer"
          },
          "y" : {
            "maximum" : 8000,
            "minimum" : 1,
            "type" : "integer"
          }
        }
      },
      "ScalarField" : {
        "required" : [ "dataType", "fieldName" ],
        "type" : "object",
        "properties" : {
          "fieldName" : {
            "type" : "string"
          },
          "component" : {
            "type" : "string"
          },
          "dataType" : {
            "$ref" : "#/components/schemas/DataType"
          }
        }
      },
      "VectorField" : {
        "required" : [ "dataType", "fieldName" ],
        "type" : "object",
        "properties" : {
          "fieldName" : {
            "type" : "string"
          },
          "dataType" : {
            "$ref" : "#/components/schemas/DataType"
          }
        }
      },
      "ScalarSettings" : {
        "required" : [ "scalarField" ],
        "properties" : {
          "scalarField" : {
            "$ref" : "#/components/schemas/ScalarField"
          },
          "minimumRange" : {
            "type" : "number",
            "description" : "The minimum value for the color scheme to fill. Default is the minimum value of the scalar.",
            "format" : "float"
          },
          "maximumRange" : {
            "type" : "number",
            "description" : "The maximum value for the color scheme to fill. Default is the maximum value of the scalar.",
            "format" : "float"
          },
          "nodeAverageValue" : {
            "type" : "boolean",
            "description" : "Specify if the scalar result should be shown as a node averaged result or not.",
            "default" : false
          },
          "numberOfDivisions" : {
            "maximum" : 75,
            "minimum" : 0,
            "type" : "integer",
            "description" : "The number of divisions in the legend. If set to 0, this will create a continuous (gradient) legend with a smooth interpolation between the colors.",
            "default" : 20
          },
          "colorScheme" : {
            "type" : "string",
            "description" : "The color scheme to use to map scalar values on the model and legend bar.",
            "default" : "NORMAL",
            "enum" : [ "NORMAL", "NORMAL_INVERTED", "BLACK_TO_WHITE", "WHITE_TO_BLACK", "GREEN_TO_BROWN", "WHITE_TO_BROWN", "METAL_CASTING", "BLUE_TO_WHITE_TO_RED", "THERMAL_1", "THERMAL_2", "THERMAL_3" ]
          }
        }
      },
      "VectorSettings" : {
        "required" : [ "coloring", "scaleFactor", "vectorField" ],
        "properties" : {
          "vectorField" : {
            "$ref" : "#/components/schemas/VectorField"
          },
          "scaleFactor" : {
            "maximum" : 1.0,
            "exclusiveMaximum" : false,
            "minimum" : 0.0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "format" : "double",
            "default" : 0.2
          },
          "solidColor" : {
            "$ref" : "#/components/schemas/Color"
          },
          "coloring" : {
            "type" : "string",
            "default" : "BY_VECTOR_FIELD",
            "enum" : [ "BY_VECTOR_FIELD", "SOLID_COLOR" ]
          },
          "minimumClampingRange" : {
            "type" : "number",
            "description" : "The minimum length of (non-zero) vectors will be drawn as. Must not be larger than maximumClampingRange. Default value is the minimum length of the specified vector field.",
            "format" : "float"
          },
          "maximumClampingRange" : {
            "type" : "number",
            "description" : "The maximum length of (non-zero) vectors will be drawn as. Must not be smaller than minimumClampingRange. Default value is the maximum length of the specified vector field.",
            "format" : "float"
          },
          "minimumFilteringRange" : {
            "type" : "number",
            "description" : "The required minimum length of the vectors in order to be drawn. Must not be larger than maximumFilteringRange. Default value is the minimum length of the specified vector field.",
            "format" : "float"
          },
          "maximumFilteringRange" : {
            "type" : "number",
            "description" : "The required maximum length of the vectors in order to be drawn. Must not be smaller than minimumFilteringRange. Default value is the maximum length of the specified vector field.",
            "format" : "float"
          }
        }
      },
      "UserInputCameraSettings" : {
        "required" : [ "center", "eye", "projectionType", "settingType", "up" ],
        "type" : "object",
        "properties" : {
          "settingType" : {
            "type" : "string",
            "default" : "USER_INPUT"
          },
          "projectionType" : {
            "$ref" : "#/components/schemas/ProjectionType"
          },
          "up" : {
            "$ref" : "#/components/schemas/Vector3D"
          },
          "eye" : {
            "$ref" : "#/components/schemas/Vector3D"
          },
          "center" : {
            "$ref" : "#/components/schemas/Vector3D"
          },
          "frontPlaneFrustumHeight" : {
            "minimum" : 0.0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "required only for orthogonal projection type."
          },
          "fieldOfViewYDegrees" : {
            "minimum" : 0.0,
            "exclusiveMinimum" : false,
            "type" : "number",
            "description" : "The total field of view in Y direction in degrees. Required onlyf for perspective projection type."
          }
        },
        "x-implements" : "OneOfCameraSettings"
      },
      "FortyFiveViewPredefinedCameraSettings" : {
        "required" : [ "directionSpecifier", "projectionType", "settingType" ],
        "type" : "object",
        "properties" : {
          "settingType" : {
            "type" : "string",
            "default" : "FORTY_FIVE_FORTY_FIVE_VIEW"
          },
          "projectionType" : {
            "$ref" : "#/components/schemas/ProjectionType"
          },
          "directionSpecifier" : {
            "type" : "string",
            "enum" : [ "X_NEGATIVE_Y_NEGATIVE_Z_NEGATIVE", "X_NEGATIVE_Y_NEGATIVE_Z_POSITIVE", "X_NEGATIVE_Y_POSITIVE_Z_NEGATIVE", "X_NEGATIVE_Y_POSITIVE_Z_POSITIVE", "X_POSITIVE_Y_NEGATIVE_Z_NEGATIVE", "X_POSITIVE_Y_NEGATIVE_Z_POSITIVE", "X_POSITIVE_Y_POSITIVE_Z_NEGATIVE", "X_POSITIVE_Y_POSITIVE_Z_POSITIVE" ]
          }
        },
        "x-implements" : "OneOfCameraSettings"
      },
      "TopViewPredefinedCameraSettings" : {
        "required" : [ "directionSpecifier", "projectionType", "settingType" ],
        "type" : "object",
        "properties" : {
          "settingType" : {
            "type" : "string",
            "default" : "TOP_VIEW"
          },
          "projectionType" : {
            "$ref" : "#/components/schemas/ProjectionType"
          },
          "directionSpecifier" : {
            "type" : "string",
            "enum" : [ "X_NEGATIVE", "X_POSITIVE", "Y_NEGATIVE", "Y_POSITIVE", "Z_NEGATIVE", "Z_POSITIVE" ]
          }
        },
        "x-implements" : "OneOfCameraSettings"
      },
      "Vector3D" : {
        "required" : [ "x", "y", "z" ],
        "type" : "object",
        "properties" : {
          "x" : {
            "type" : "number"
          },
          "y" : {
            "type" : "number"
          },
          "z" : {
            "type" : "number"
          }
        }
      },
      "ProjectionType" : {
        "type" : "string",
        "enum" : [ "ORTHOGONAL", "PERSPECTIVE" ]
      },
      "Opacity" : {
        "maximum" : 1.0,
        "exclusiveMaximum" : false,
        "minimum" : 0.0,
        "exclusiveMinimum" : false,
        "type" : "number",
        "format" : "double"
      },
      "DownloadInfo" : {
        "type" : "object",
        "properties" : {
          "format" : {
            "type" : "string",
            "description" : "The result format.",
            "readOnly" : true
          },
          "uncompressedSizeInBytes" : {
            "type" : "integer",
            "description" : "The uncompressed size of the report result content.",
            "format" : "int64",
            "readOnly" : true
          },
          "url" : {
            "type" : "string",
            "description" : "URL for downloading the report result content.",
            "format" : "uri",
            "readOnly" : true
          },
          "compression" : {
            "type" : "string",
            "description" : "The compression used for the report result download archive.",
            "readOnly" : true,
            "enum" : [ "NONE", "ZIP64" ]
          }
        }
      },
      "ReportResponse" : {
        "required" : [ "createdAt", "description", "name", "reportId", "status" ],
        "type" : "object",
        "properties" : {
          "reportId" : {
            "type" : "string",
            "description" : "The ID of the report.",
            "format" : "uuid",
            "readOnly" : true
          },
          "name" : {
            "type" : "string",
            "description" : "The name of the report."
          },
          "description" : {
            "type" : "string",
            "description" : "The description of the report."
          },
          "createdAt" : {
            "type" : "string",
            "description" : "The time the report was created.",
            "format" : "date-time",
            "readOnly" : true
          },
          "startedAt" : {
            "type" : "string",
            "description" : "The time the report was started.",
            "format" : "date-time",
            "readOnly" : true
          },
          "finishedAt" : {
            "type" : "string",
            "description" : "The time the report was finished.",
            "format" : "date-time",
            "readOnly" : true
          },
          "status" : {
            "type" : "string",
            "description" : "Status of the report operation.",
            "readOnly" : true,
            "enum" : [ "READY", "QUEUED", "RUNNING", "FINISHED", "CANCELED", "FAILED" ]
          },
          "resultIds" : {
            "type" : "array",
            "description" : "The resultIds the report has been created for.",
            "items" : {
              "type" : "string",
              "format" : "uuid"
            }
          },
          "reportProperties" : {
            "$ref" : "#/components/schemas/OneOfReportProperties"
          },
          "download" : {
            "$ref" : "#/components/schemas/DownloadInfo"
          },
          "failureReason" : {
            "required" : [ "severity code message" ],
            "type" : "object",
            "properties" : {
              "severity" : {
                "type" : "string",
                "readOnly" : true,
                "enum" : [ "INFO", "SUCCESS", "WARNING", "ERROR" ]
              },
              "code" : {
                "type" : "string",
                "description" : "Code for e.g. programmatic handling of error conditions.",
                "readOnly" : true
              },
              "message" : {
                "type" : "string",
                "description" : "Human-readable description of the entry.",
                "readOnly" : true
              },
              "details" : {
                "type" : "object",
                "additionalProperties" : true,
                "description" : "Additional data to interpret and handle the entry.",
                "readOnly" : true
              }
            }
          }
        }
      },
      "CreateMaterialGroupRequest" : {
        "required" : [ "name" ],
        "type" : "object",
        "properties" : {
          "name" : {
            "maxLength" : 40,
            "minLength" : 1,
            "type" : "string",
            "description" : "The name of the material group."
          },
          "metadata" : {
            "type" : "object"
          },
          "public" : {
            "type" : "boolean",
            "default" : false
          },
          "teamGroupId" : {
            "type" : "integer",
            "description" : "The material group will be assigned to this team group id. This field can only be used by support group members."
          }
        }
      },
      "CreateNestedMaterialGroupRequest" : {
        "required" : [ "name" ],
        "type" : "object",
        "properties" : {
          "name" : {
            "maxLength" : 40,
            "minLength" : 1,
            "type" : "string",
            "description" : "The name of the material group."
          },
          "metadata" : {
            "type" : "object"
          }
        }
      },
      "UpdateMaterialGroupRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "maxLength" : 40,
            "minLength" : 1,
            "type" : "string",
            "description" : "The name of the material group."
          },
          "metadata" : {
            "type" : "object"
          }
        }
      },
      "CreateMaterialRequest" : {
        "required" : [ "name", "properties" ],
        "type" : "object",
        "properties" : {
          "name" : {
            "pattern" : "^(?!\\s*$).+",
            "type" : "string",
            "description" : "The material name."
          },
          "metadata" : {
            "type" : "object"
          },
          "properties" : {
            "$ref" : "#/components/schemas/MaterialProperties"
          }
        }
      },
      "MaterialResponse" : {
        "required" : [ "createdAt", "id", "materialGroupId", "modifiedAt", "name" ],
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "string",
            "description" : "The material unique identifier.",
            "readOnly" : true
          },
          "materialGroupId" : {
            "type" : "string",
            "description" : "The material group unique identifier.",
            "readOnly" : true
          },
          "name" : {
            "type" : "string",
            "description" : "The material name."
          },
          "createdAt" : {
            "type" : "string",
            "description" : "The time the material was created.",
            "format" : "date-time",
            "readOnly" : true
          },
          "modifiedAt" : {
            "type" : "string",
            "description" : "The time the material was modified.",
            "format" : "date-time",
            "readOnly" : true
          },
          "properties" : {
            "$ref" : "#/components/schemas/MaterialProperties"
          },
          "metadata" : {
            "type" : "object"
          }
        }
      },
      "MaterialGroupResponse" : {
        "required" : [ "createdAt", "materialGroupId", "metadata", "modifiedAt", "name" ],
        "type" : "object",
        "properties" : {
          "materialGroupId" : {
            "type" : "string",
            "description" : "The ID of the material group.",
            "readOnly" : true
          },
          "parentId" : {
            "type" : "string",
            "description" : "The ID of parent of the material group.",
            "readOnly" : true
          },
          "name" : {
            "type" : "string",
            "description" : "The name of the material group."
          },
          "groupType" : {
            "$ref" : "#/components/schemas/MaterialGroupType"
          },
          "createdAt" : {
            "type" : "string",
            "description" : "The time the material group was created.",
            "format" : "date-time",
            "readOnly" : true
          },
          "modifiedAt" : {
            "type" : "string",
            "description" : "The time the material group was modified.",
            "format" : "date-time",
            "readOnly" : true
          },
          "metadata" : {
            "type" : "object",
            "description" : "Material group metadata.",
            "readOnly" : true
          }
        }
      },
      "MaterialProperties" : {
        "minProperties" : 1,
        "type" : "object",
        "additionalProperties" : {
          "$ref" : "#/components/schemas/OneOfMaterialProperty"
        },
        "description" : "The material properties.",
        "x-constraints" : "@ConsistentParameterKeys"
      },
      "OneOfMaterialProperty" : {
        "discriminator" : {
          "propertyName" : "valueType",
          "mapping" : {
            "fixed" : "#/components/schemas/FixedMaterialProperty",
            "parametric" : "#/components/schemas/ParametricMaterialProperty"
          }
        },
        "oneOf" : [ {
          "$ref" : "#/components/schemas/FixedMaterialProperty"
        }, {
          "$ref" : "#/components/schemas/ParametricMaterialProperty"
        } ]
      },
      "FixedMaterialProperty" : {
        "required" : [ "value", "valueType" ],
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "The material property name"
          },
          "label" : {
            "type" : "string",
            "description" : "The material property label to support internationalization. The content of this field is a i18n key. If this field is not present, the name field can be used as a fallback for English language."
          },
          "unit" : {
            "type" : "string",
            "description" : "The material property unit"
          },
          "valueType" : {
            "type" : "string",
            "default" : "fixed"
          },
          "dataType" : {
            "$ref" : "#/components/schemas/PropertyDataType"
          },
          "value" : {
            "type" : "object",
            "description" : "The property value"
          }
        },
        "description" : "A material property that has a fixed (constant) value.",
        "x-implements" : "OneOfMaterialProperty"
      },
      "ParametricMaterialProperty" : {
        "required" : [ "parameters", "valueType" ],
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "The material property name"
          },
          "label" : {
            "type" : "string",
            "description" : "The material property label to support internationalization. The content of this field is a i18n key. If this field is not present, the name field can be used as a fallback for English language."
          },
          "unit" : {
            "type" : "string",
            "description" : "The material property unit"
          },
          "valueType" : {
            "type" : "string",
            "default" : "parametric"
          },
          "dataType" : {
            "$ref" : "#/components/schemas/PropertyDataType"
          },
          "parameters" : {
            "minItems" : 1,
            "type" : "array",
            "description" : "Parameter properties of the material",
            "items" : {
              "$ref" : "#/components/schemas/MaterialPropertyParameter"
            }
          },
          "parametricValues" : {
            "minItems" : 1,
            "type" : "array",
            "items" : {
              "type" : "object",
              "properties" : {
                "value" : {
                  "type" : "object"
                }
              },
              "additionalProperties" : {
                "type" : "object"
              }
            }
          }
        },
        "description" : "A material property containing a set of parametric values.",
        "x-implements" : "OneOfMaterialProperty"
      },
      "MaterialPropertyParameter" : {
        "required" : [ "key" ],
        "type" : "object",
        "properties" : {
          "key" : {
            "type" : "string",
            "description" : "The unique identifier of the parameter, meaningful from the physics/business perspective"
          },
          "name" : {
            "type" : "string",
            "description" : "Optional user facing name or label key for human identification"
          },
          "unit" : {
            "type" : "string",
            "description" : "The parameter unit"
          }
        }
      },
      "PropertyDataType" : {
        "type" : "string",
        "description" : "The data type of the property value field (can be either numeric or string)",
        "enum" : [ "numeric", "string" ]
      },
      "MaterialGroupType" : {
        "type" : "string",
        "description" : "Indicates the owner of the material group. Default groups are provided and managed by SimScale. Custom groups can belong to a user or to a company/team.",
        "readOnly" : true,
        "enum" : [ "SIMSCALE_DEFAULT", "USER_CUSTOM", "COMPANY_CUSTOM" ]
      },
      "PermissionDto" : {
        "type" : "string",
        "enum" : [ "READ", "WRITE", "ADMIN" ]
      }
    },
    "responses" : {
      "BadRequest" : {
        "description" : "Bad request.",
        "content" : {
          "application/json" : {
            "schema" : {
              "$ref" : "#/components/schemas/ErrorResponse"
            },
            "example" : {
              "severity" : "ERROR",
              "entries" : [ {
                "severity" : "ERROR",
                "code" : "invalid-input",
                "message" : "Invalid text input",
                "details" : {
                  "path" : "$.name"
                }
              }, {
                "severity" : "ERROR",
                "code" : "invalid-input",
                "message" : "Size must be between 0 and 250",
                "details" : {
                  "path" : "$.description"
                }
              } ],
              "trace" : "abcd1234"
            }
          }
        }
      },
      "NotFound" : {
        "description" : "Not found.",
        "content" : {
          "application/json" : {
            "schema" : {
              "$ref" : "#/components/schemas/ErrorResponse"
            },
            "example" : {
              "severity" : "ERROR",
              "code" : "not-found",
              "message" : "Not found.",
              "trace" : "abcd1234"
            }
          }
        }
      },
      "UnprocessableEntity" : {
        "description" : "Unprocessable entity.",
        "content" : {
          "application/json" : {
            "schema" : {
              "$ref" : "#/components/schemas/ErrorResponse"
            },
            "example" : {
              "severity" : "ERROR",
              "code" : "unprocessable-entity",
              "message" : "Unprocessable entity.",
              "trace" : "abcd1234"
            }
          }
        }
      }
    },
    "parameters" : {
      "collectionLimit" : {
        "name" : "limit",
        "in" : "query",
        "description" : "The number of items to return.",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "maximum" : 1000,
          "minimum" : 10,
          "type" : "integer",
          "default" : 100
        }
      },
      "collectionPage" : {
        "name" : "page",
        "in" : "query",
        "description" : "The page number. Use in combination with limit.",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "maximum" : 1000,
          "minimum" : 1,
          "type" : "integer",
          "default" : 1
        }
      },
      "resultType" : {
        "name" : "type",
        "in" : "query",
        "description" : "The result type.\nThe possible values are 'SOLUTION_FIELD', 'CONVERGENCE_PLOT', 'PLOT', 'TABLE'.\n",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "$ref" : "#/components/schemas/SimulationRunResultType"
        }
      },
      "resultCategory" : {
        "name" : "category",
        "in" : "query",
        "description" : "The result category.\nFor solution fields values include 'SOLUTION', 'AVERAGED_SOLUTION', 'TRANSIENT_SOLUTION', 'STATISTICAL_SURFACE_SOLUTION', etc.\nFor convergence plots values include 'RESIDUALS_PLOT', 'NUMBER_OF_NEWTON_ITERATIONS', etc.\nFor plots values include 'FORCE_PLOT', 'FORCE_COEFFICIENTS_PLOT', 'PROBE_POINT_PLOT', 'AREA_AVERAGE', 'FACE_CALC', etc.\n",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "$ref" : "#/components/schemas/SimulationRunResultCategory"
        }
      },
      "resultQuantity" : {
        "name" : "quantity",
        "in" : "query",
        "description" : "The result quantity, only applies to plot result types.\nValid values include 'Ux', 'Uy', 'Uz', 'p', 'k', 'omega', 'T', 'displacement', 'von Mises stress', etc.\n",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "$ref" : "#/components/schemas/SimulationRunResultQuantity"
        }
      },
      "resultName" : {
        "name" : "name",
        "in" : "query",
        "description" : "The name that was defined for extra simulation result outputs.",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "$ref" : "#/components/schemas/SimulationRunResultName"
        }
      },
      "resultDirection" : {
        "name" : "direction",
        "in" : "query",
        "description" : "The result direction, only applies to Pedestrian Wind Comfort analysis.",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "$ref" : "#/components/schemas/SimulationRunResultDirection"
        }
      },
      "class" : {
        "name" : "class",
        "in" : "query",
        "description" : "The entity class to filter.",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "type" : "string"
        }
      },
      "bodies" : {
        "name" : "bodies",
        "in" : "query",
        "description" : "The body names to filter. If multiple body names are provided any match.",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "uniqueItems" : true,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "entities" : {
        "name" : "entities",
        "in" : "query",
        "description" : "The entity names to filter. If multiple entity names are provided any match.",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "uniqueItems" : true,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "attributes" : {
        "name" : "attributes",
        "in" : "query",
        "description" : "The attribute names to filter. If multiple attribute names are provided any match.",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "uniqueItems" : true,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "values" : {
        "name" : "values",
        "in" : "query",
        "description" : "The attribute values to filter. If multiple attribute values are provided any match.",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "uniqueItems" : true,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "projectId" : {
        "name" : "projectId",
        "in" : "path",
        "description" : "The project ID",
        "required" : true,
        "style" : "simple",
        "explode" : false,
        "schema" : {
          "type" : "string",
          "example" : "1234123412341234"
        }
      },
      "reportId" : {
        "name" : "reportId",
        "in" : "path",
        "description" : "The report ID",
        "required" : true,
        "style" : "simple",
        "explode" : false,
        "schema" : {
          "type" : "string",
          "format" : "uuid",
          "example" : "159c159c-159c-159c-159c-159c159c159c"
        }
      },
      "geometryImportId" : {
        "name" : "geometryImportId",
        "in" : "path",
        "description" : "The geometry import ID",
        "required" : true,
        "style" : "simple",
        "explode" : false,
        "schema" : {
          "type" : "string",
          "format" : "uuid",
          "example" : "f48bf48b-f48b-f48b-f48b-f48bf48bf48b"
        }
      },
      "geometryId" : {
        "name" : "geometryId",
        "in" : "path",
        "description" : "The geometry ID",
        "required" : true,
        "style" : "simple",
        "explode" : false,
        "schema" : {
          "type" : "string",
          "format" : "uuid",
          "example" : "159c159c-159c-159c-159c-159c159c159c"
        }
      },
      "meshId" : {
        "name" : "meshId",
        "in" : "path",
        "description" : "The mesh ID",
        "required" : true,
        "style" : "simple",
        "explode" : false,
        "schema" : {
          "type" : "string",
          "format" : "uuid",
          "example" : "159c159c-159c-159c-159c-159c159c159c"
        }
      },
      "simulationId" : {
        "name" : "simulationId",
        "in" : "path",
        "description" : "The simulation ID",
        "required" : true,
        "style" : "simple",
        "explode" : false,
        "schema" : {
          "type" : "string",
          "format" : "uuid",
          "example" : "260d260d-260d-260d-260d-260d260d260d"
        }
      },
      "simulationIdOptional" : {
        "name" : "simulationId",
        "in" : "query",
        "description" : "The simulation ID if given",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "type" : "string",
          "format" : "uuid",
          "example" : "260d260d-260d-260d-260d-260d260d260d"
        }
      },
      "simulationIdQuery" : {
        "name" : "simulationId",
        "in" : "query",
        "description" : "The related simulation ID of a physics based mesh operation",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "type" : "string",
          "format" : "uuid",
          "example" : "260d260d-260d-260d-260d-260d260d260d"
        }
      },
      "simulationSpecSchemaVersion" : {
        "name" : "simulationSpecSchemaVersion",
        "in" : "query",
        "description" : "Version of the schema the simulation spec should conform to",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "type" : "string",
          "example" : "11.0",
          "default" : "11.0"
        }
      },
      "meshingSpecSchemaVersion" : {
        "name" : "meshingSpecSchemaVersion",
        "in" : "query",
        "description" : "Version of the schema the meshing spec should conform to",
        "required" : true,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "type" : "string",
          "example" : "0.5",
          "default" : "0.5"
        }
      },
      "sdkVersion" : {
        "name" : "sdkVersion",
        "in" : "query",
        "description" : "Version of the SDK to generate code for",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "pattern" : "latest|\\d+\\.\\d+\\.\\d+",
          "type" : "string",
          "example" : "0.2.0",
          "default" : "latest"
        }
      },
      "sdkLanguage" : {
        "name" : "sdkLanguage",
        "in" : "query",
        "description" : "Language of the SDK to generate code for. Only Python is currently supported.",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "type" : "string",
          "example" : "python",
          "default" : "python",
          "enum" : [ "python" ]
        }
      },
      "runId" : {
        "name" : "runId",
        "in" : "path",
        "description" : "The simulation run ID",
        "required" : true,
        "style" : "simple",
        "explode" : false,
        "schema" : {
          "type" : "string",
          "format" : "uuid",
          "example" : "37ae37ae-37ae-37ae-37ae-37ae37ae37ae"
        }
      },
      "runIdOptional" : {
        "name" : "runId",
        "in" : "query",
        "description" : "The simulation run ID if given",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "type" : "string",
          "format" : "uuid",
          "example" : "37ae37ae-37ae-37ae-37ae-37ae37ae37ae"
        }
      },
      "meshOperationId" : {
        "name" : "meshOperationId",
        "in" : "path",
        "description" : "The mesh operation ID",
        "required" : true,
        "style" : "simple",
        "explode" : false,
        "schema" : {
          "type" : "string",
          "format" : "uuid",
          "example" : "37ae37ae-37ae-37ae-37ae-37ae37ae37ae"
        }
      },
      "subRunId" : {
        "name" : "subRunId",
        "in" : "path",
        "description" : "The simulation sub-run ID",
        "required" : true,
        "style" : "simple",
        "explode" : false,
        "schema" : {
          "type" : "string",
          "format" : "uuid",
          "example" : "37ae37ae-37ae-37ae-37ae-37ae37ae37ae"
        }
      },
      "materialGroupId" : {
        "name" : "materialGroupId",
        "in" : "path",
        "description" : "ID of a material group",
        "required" : true,
        "style" : "simple",
        "explode" : false,
        "schema" : {
          "type" : "string"
        }
      },
      "materialId" : {
        "name" : "materialId",
        "in" : "path",
        "description" : "ID of a material",
        "required" : true,
        "style" : "simple",
        "explode" : false,
        "schema" : {
          "type" : "string"
        }
      },
      "materialUpdatePreview" : {
        "name" : "preview",
        "in" : "query",
        "description" : "If present and true, the update material operation(s) will not be persisted and the returned response will only be a preview of the simulation.",
        "required" : false,
        "style" : "form",
        "explode" : true,
        "schema" : {
          "type" : "boolean",
          "default" : false
        }
      }
    },
    "examples" : {
      "WindComfort" : {
        "summary" : "Wind Comfort",
        "value" : {
          "simulationId" : "260d260d-260d-260d-260d-260d260d260d",
          "name" : "My first simulation",
          "version" : "2.0",
          "createdAt" : "2020-05-20T11:32:12.730Z",
          "modifiedAt" : "2020-05-20T11:32:12.730Z",
          "geometryId" : "159c159c-159c-159c-159c-159c159c159c",
          "meshId" : null,
          "parameters" : null,
          "model" : {
            "type" : "WIND_COMFORT",
            "regionOfInterest" : {
              "discRadius" : {
                "value" : 278.4222937219507,
                "unit" : "m"
              },
              "centerPoint" : {
                "value" : {
                  "x" : 12.114788527587606,
                  "y" : 14.600237051446499
                },
                "unit" : "m"
              },
              "groundHeight" : {
                "value" : -12.800801325539402,
                "unit" : "m"
              },
              "northAngle" : {
                "value" : 0,
                "unit" : ""
              },
              "advancedSettings" : {
                "windTunnelSize" : {
                  "type" : "WIND_TUNNEL_SIZE_MODERATE"
                }
              }
            },
            "windConditions" : {
              "geographicalLocation" : {
                "latitude" : {
                  "value" : 48.1351253,
                  "unit" : ""
                },
                "longitude" : {
                  "value" : 11.5819805,
                  "unit" : ""
                }
              },
              "windRose" : {
                "numDirections" : 4,
                "velocityBuckets" : [ {
                  "to" : 0.278,
                  "fractions" : [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
                }, {
                  "from" : 0.278,
                  "to" : 1.389,
                  "fractions" : [ 0.004, 0.003, 0.002, 0.004, 0.002, 0.003, 0.002, 0.002, 0.003, 0.003, 0.003, 0.003, 0.004, 0.003, 0.003, 0.002 ]
                }, {
                  "from" : 1.389,
                  "to" : 3.333,
                  "fractions" : [ 0.015, 0.014, 0.014, 0.016, 0.013, 0.014, 0.012, 0.012, 0.016, 0.015, 0.017, 0.014, 0.016, 0.012, 0.013, 0.013 ]
                }, {
                  "from" : 3.333,
                  "to" : 5.278,
                  "fractions" : [ 0.017, 0.015, 0.015, 0.017, 0.014, 0.012, 0.013, 0.015, 0.02, 0.025, 0.029, 0.023, 0.021, 0.016, 0.017, 0.015 ]
                }, {
                  "from" : 5.278,
                  "to" : 7.778,
                  "fractions" : [ 0.01, 0.009, 0.009, 0.011, 0.009, 0.007, 0.006, 0.01, 0.019, 0.026, 0.037, 0.028, 0.023, 0.016, 0.014, 0.012 ]
                }, {
                  "from" : 7.778,
                  "to" : 10.556,
                  "fractions" : [ 0.003, 0.003, 0.004, 0.005, 0.003, 0.003, 0.002, 0.004, 0.011, 0.017, 0.024, 0.018, 0.012, 0.007, 0.005, 0.004 ]
                }, {
                  "from" : 10.556,
                  "to" : 13.889,
                  "fractions" : [ 0.001, 0.001, 0.001, 0.003, 0.001, 0, 0, 0.001, 0.004, 0.007, 0.011, 0.007, 0.005, 0.003, 0.002, 0.001 ]
                }, {
                  "from" : 13.889,
                  "to" : 16.944,
                  "fractions" : [ 0, 0, 0, 0.001, 0, 0, 0, 0, 0.001, 0.002, 0.003, 0.003, 0.002, 0.001, 0.001, 0 ]
                }, {
                  "from" : 16.944,
                  "fractions" : [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.001, 0.001, 0.001, 0.001, 0, 0, 0 ]
                } ],
                "velocityUnit" : "m/s",
                "exposureCategories" : [ "EC4", "EC4", "EC4", "EC4" ],
                "windEngineeringStandard" : "EU",
                "windDataSource" : "METEOBLUE",
                "addSurfaceRoughness" : false
              }
            },
            "pedestrianComfortMap" : [ {
              "name" : "Pedestrian level 1",
              "heightAboveGround" : {
                "value" : 1.5,
                "unit" : "m"
              },
              "ground" : {
                "type" : "GROUND_ABSOLUTE"
              }
            } ],
            "simulationControl" : {
              "maxDirectionRunTime" : {
                "value" : 10000,
                "unit" : "s"
              },
              "numberOfFluidPasses" : 0.2
            },
            "advancedModelling" : {
              "surfaceRoughness" : [ ],
              "porousObjects" : [ ]
            },
            "additionalResultExport" : {
              "forcesMoments" : [ ],
              "probePoints" : [ ],
              "transientResultControl" : {
                "type" : "TRANSIENT",
                "writeControl" : {
                  "type" : "MODERATE_RESOLUTION"
                },
                "fractionFromEnd" : 0.2,
                "exportFluid" : true,
                "exportSurface" : false,
                "geometryPrimitiveUuids" : [ ]
              },
              "statisticalAveragingResultControl" : {
                "type" : "STATISTICAL_AVERAGING_V2",
                "fractionFromEnd" : 0.2,
                "samplingInterval" : {
                  "type" : "MODERATE_RESOLUTION"
                },
                "exportFluid" : true,
                "exportSurface" : false,
                "geometryPrimitiveUuids" : [ ]
              }
            },
            "meshSettings" : {
              "windComfortFineness" : {
                "type" : "COARSE"
              },
              "refinements" : [ ]
            }
          }
        }
      },
      "Incompressible" : {
        "summary" : "Incompressible using OpenFoam",
        "value" : {
          "simulationId" : "260d260d-260d-260d-260d-260d260d260d",
          "name" : "My first simulation",
          "version" : "2.0",
          "createdAt" : "2020-05-20T11:32:12.730Z",
          "modifiedAt" : "2020-05-20T11:32:12.730Z",
          "geometryId" : "159c159c-159c-159c-159c-159c159c159c",
          "meshId" : "679316b6-68d3-4027-ac66-10bf0a3beb3e",
          "model" : {
            "type" : "INCOMPRESSIBLE",
            "isCompressible" : false,
            "turbulenceModel" : "KOMEGASST",
            "timeDependency" : {
              "type" : "STATIONARY"
            },
            "algorithm" : "SIMPLE",
            "numOfPassiveSpecies" : 0,
            "model" : { },
            "materials" : {
              "fluids" : [ {
                "type" : "INCOMPRESSIBLE",
                "name" : "Water",
                "viscosityModel" : {
                  "type" : "NEWTONIAN",
                  "kinematicViscosity" : {
                    "value" : 9.3379E-7,
                    "unit" : "m/s"
                  }
                },
                "density" : {
                  "value" : 997.33,
                  "unit" : "kg/m"
                },
                "topologicalReference" : {
                  "entities" : [ "B1_TE39" ],
                  "sets" : [ ]
                },
                "builtInMaterial" : "builtInWater"
              } ]
            },
            "initialConditions" : {
              "gaugePressure" : {
                "global" : {
                  "value" : 0,
                  "unit" : "Pa"
                }
              },
              "velocity" : {
                "global" : {
                  "value" : {
                    "x" : 0,
                    "y" : 0,
                    "z" : 0
                  },
                  "unit" : "m/s"
                },
                "subdomains" : [ ]
              },
              "turbulentKineticEnergy" : {
                "global" : {
                  "value" : 0.00375,
                  "unit" : "m/s"
                }
              },
              "omegaDissipationRate" : {
                "global" : {
                  "value" : 3.375,
                  "unit" : "1/s"
                }
              }
            },
            "boundaryConditions" : [ {
              "name" : "Velocity inlet 1",
              "type" : "VELOCITY_INLET_V3",
              "velocity" : {
                "type" : "FIXED_VALUE",
                "value" : {
                  "value" : {
                    "type" : "COMPONENT",
                    "x" : {
                      "type" : "CONSTANT",
                      "value" : 0
                    },
                    "y" : {
                      "type" : "CONSTANT",
                      "value" : 0
                    },
                    "z" : {
                      "type" : "CONSTANT",
                      "value" : -1.5
                    }
                  },
                  "unit" : "m/s"
                }
              },
              "topologicalReference" : {
                "entities" : [ "B1_TE3" ],
                "sets" : [ ]
              }
            }, {
              "name" : "Velocity inlet 2",
              "type" : "VELOCITY_INLET_V3",
              "velocity" : {
                "type" : "FIXED_VALUE",
                "value" : {
                  "value" : {
                    "type" : "COMPONENT",
                    "x" : {
                      "type" : "CONSTANT",
                      "value" : 0
                    },
                    "y" : {
                      "type" : "CONSTANT",
                      "value" : -1
                    },
                    "z" : {
                      "type" : "CONSTANT",
                      "value" : 0
                    }
                  },
                  "unit" : "m/s"
                }
              },
              "topologicalReference" : {
                "entities" : [ "B1_TE30" ],
                "sets" : [ ]
              }
            }, {
              "name" : "Pressure outlet 3",
              "type" : "PRESSURE_OUTLET_V30",
              "gaugePressure" : {
                "type" : "FIXED_VALUE",
                "value" : {
                  "value" : {
                    "type" : "CONSTANT",
                    "value" : 0
                  },
                  "unit" : "Pa"
                }
              },
              "topologicalReference" : {
                "entities" : [ "B1_TE37" ],
                "sets" : [ ]
              }
            } ],
            "advancedConcepts" : {
              "rotatingZones" : [ ],
              "porousMediums" : [ ],
              "momentumSources" : [ ]
            },
            "numerics" : {
              "relaxationType" : "AUTOMATIC",
              "relaxationFactor" : {
                "pressureField" : 0.3,
                "velocityEquation" : 0.7,
                "turbulentKineticEnergyEquation" : 0.3,
                "omegaDissipationRateEquation" : 0.3
              },
              "numNonOrthogonalCorrectors" : 0,
              "pressureReferenceCell" : 0,
              "pressureReferenceValue" : {
                "value" : 0,
                "unit" : "Pa"
              },
              "residualControls" : {
                "velocity" : {
                  "absoluteTolerance" : 1.0E-6
                },
                "pressure" : {
                  "absoluteTolerance" : 1.0E-6
                },
                "turbulentKineticEnergy" : {
                  "absoluteTolerance" : 1.0E-6
                },
                "omegaDissipationRate" : {
                  "absoluteTolerance" : 1.0E-6
                }
              },
              "solvers" : {
                "velocitySolver" : {
                  "type" : "SMOOTH",
                  "absoluteTolerance" : 1.0E-6,
                  "relativeTolerance" : 0.01,
                  "smoother" : "GAUSSSEIDEL",
                  "numSweeps" : 1
                },
                "pressureSolver" : {
                  "type" : "GAMG",
                  "absoluteTolerance" : 1.0E-6,
                  "relativeTolerance" : 0.001,
                  "smoother" : "GAUSSSEIDEL",
                  "numPreSweeps" : 2,
                  "numPostSweeps" : 1,
                  "cacheAgglomerationOn" : true,
                  "numCellsCoarsestLevel" : 100,
                  "numMergeLevels" : 1
                },
                "turbulentKineticEnergySolver" : {
                  "type" : "SMOOTH",
                  "absoluteTolerance" : 1.0E-6,
                  "relativeTolerance" : 0.01,
                  "smoother" : "GAUSSSEIDEL",
                  "numSweeps" : 1
                },
                "omegaDissipationRateSolver" : {
                  "type" : "SMOOTH",
                  "absoluteTolerance" : 1.0E-6,
                  "relativeTolerance" : 0.01,
                  "smoother" : "GAUSSSEIDEL",
                  "numSweeps" : 1
                }
              },
              "schemes" : {
                "timeDifferentiation" : {
                  "forDefault" : {
                    "type" : "STEADYSTATE"
                  }
                },
                "gradient" : {
                  "forDefault" : {
                    "type" : "CELLLIMITED_LEASTSQUARES",
                    "limiterCoefficient" : 1
                  },
                  "grad_pressure" : {
                    "type" : "CELLLIMITED_LEASTSQUARES",
                    "limiterCoefficient" : 1
                  },
                  "grad_velocity" : {
                    "type" : "CELLLIMITED_LEASTSQUARES",
                    "limiterCoefficient" : 1
                  }
                },
                "divergence" : {
                  "forDefault" : {
                    "type" : "GAUSS_LINEAR"
                  },
                  "div_Phi_velocity" : {
                    "type" : "GAUSS_LINEARUPWINDV_GRAD_U_"
                  },
                  "div_Phi_turbulentKineticEnergy" : {
                    "type" : "BOUNDED_GAUSS_UPWIND"
                  },
                  "div_NuEff_dev_T_grad_velocity" : {
                    "type" : "GAUSS_LINEAR"
                  },
                  "div_Phi_omegaDissipationRate" : {
                    "type" : "BOUNDED_GAUSS_UPWIND"
                  }
                },
                "laplacian" : {
                  "forDefault" : {
                    "type" : "GAUSS_LINEAR_LIMITED_CORRECTED",
                    "limiterCoefficient" : 0.5
                  },
                  "laplacian_NuEff_velocity" : {
                    "type" : "GAUSS_LINEAR_LIMITED_CORRECTED",
                    "limiterCoefficient" : 0.5
                  },
                  "laplacian_1A_U_pressure" : {
                    "type" : "GAUSS_LINEAR_LIMITED_CORRECTED",
                    "limiterCoefficient" : 0.5
                  },
                  "laplacian_Nu_velocity" : {
                    "type" : "GAUSS_LINEAR_LIMITED_CORRECTED",
                    "limiterCoefficient" : 0.5
                  }
                },
                "interpolation" : {
                  "forDefault" : {
                    "type" : "LINEAR"
                  },
                  "interpolate_HbyA" : {
                    "type" : "LINEAR"
                  }
                },
                "surfaceNormalGradient" : {
                  "forDefault" : {
                    "type" : "LIMITED",
                    "limiterCoefficient" : 0.5
                  }
                }
              }
            },
            "simulationControl" : {
              "endTime" : {
                "value" : 1000,
                "unit" : "s"
              },
              "deltaT" : {
                "value" : 1,
                "unit" : "s"
              },
              "writeControl" : {
                "type" : "TIME_STEP",
                "writeInterval" : 1000
              },
              "numProcessors" : -1,
              "maxRunTime" : {
                "value" : 10000,
                "unit" : "s"
              },
              "potentialFoamInitialization" : false,
              "decomposeAlgorithm" : {
                "type" : "SCOTCH"
              }
            },
            "resultControl" : {
              "forcesMoments" : [ ],
              "surfaceData" : [ ],
              "scalarTransport" : [ ],
              "probePoints" : [ ],
              "fieldCalculations" : [ ]
            }
          }
        }
      },
      "Simerics" : {
        "summary" : "Simerics",
        "value" : {
          "version" : "104",
          "simulationId" : "d2811649-0eba-4ad2-b518-9fabe008aa87",
          "createdAt" : "2021-09-23T09:37:03.892Z",
          "geometryId" : "d0021fb0-d80a-48f0-86a3-5cc7f836b441",
          "model" : {
            "type" : "SIMERICS_ANALYSIS",
            "materials" : {
              "fluids" : [ {
                "type" : "INCOMPRESSIBLE",
                "name" : "Water",
                "viscosityModel" : {
                  "type" : "NEWTONIAN",
                  "kinematicViscosity" : {
                    "value" : 9.3379E-7,
                    "unit" : "m/s"
                  }
                },
                "density" : {
                  "value" : 997.33,
                  "unit" : "kg/m"
                },
                "topologicalReference" : {
                  "entities" : [ "B1_TE39" ],
                  "sets" : [ ]
                },
                "builtInMaterial" : "builtInWater"
              } ]
            },
            "isCompressible" : false,
            "turbulenceModel" : "NONE",
            "boundaryConditions" : [ {
              "name" : "Velocity inlet 1",
              "type" : "VELOCITY_INLET_V3",
              "velocity" : {
                "type" : "FLOW_RATE_INLET_VELOCITY",
                "flowRate" : {
                  "type" : "VOLUMETRIC",
                  "value" : {
                    "value" : {
                      "type" : "CONSTANT",
                      "value" : 1
                    },
                    "unit" : "m/s"
                  }
                }
              },
              "topologicalReference" : {
                "entities" : [ "B1_TE37" ],
                "sets" : [ ]
              }
            } ],
            "simulationControl" : {
              "numberOfIterations" : 500,
              "writeControl" : {
                "type" : "NUMBER_OF_ITERATIONS_STEADY_STATE",
                "writeInterval" : 100
              },
              "maxRunTime" : {
                "value" : 10000,
                "unit" : "s"
              },
              "relativeConvergenceCriteria" : 0.001
            },
            "meshSettings" : {
              "type" : "AUTOMATIC_SETTINGS",
              "fineness" : 6.9
            },
            "resultControl" : {
              "forcesMoments" : [ ],
              "surfaceData" : [ ]
            },
            "advancedConcepts" : {
              "rotatingZones" : [ ]
            }
          }
        }
      },
      "LocalCartesianBox" : {
        "value" : {
          "type" : "LOCAL_CARTESIAN_BOX",
          "geometryPrimitiveId" : "159c159c-159c-159c-159c-159c159c159c",
          "name" : "Local cartesian box 1",
          "orientationReference" : "GEOMETRY",
          "min" : {
            "value" : {
              "x" : -5,
              "y" : -3.5,
              "z" : 0
            },
            "unit" : "m"
          },
          "max" : {
            "value" : {
              "x" : 5,
              "y" : 3.5,
              "z" : 3
            },
            "unit" : "m"
          }
        }
      }
    },
    "securitySchemes" : {
      "apiKey" : {
        "type" : "apiKey",
        "description" : "The API key assigned to the user. For sandbox environment, use `sandbox-example-api-key`.",
        "name" : "X-API-KEY",
        "in" : "header"
      }
    }
  }
}
